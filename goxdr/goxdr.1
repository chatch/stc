.\" Automatically generated by Pandoc 2.2.3.2
.\"
.TH "goxdr" "1" "" "" ""
.hy
.SH NAME
.PP
goxdr \- Go XDR compiler
.SH SYNOPSIS
.PP
goxdr [\-b] [\-o \f[I]output.go\f[]] [\-p \f[I]package\f[]]
[\f[I]file1.x\f[] [\f[I]file2.x\f[] \&...]]
.SH DESCRIPTION
.PP
goxdr compiles an RFC4506 XDR interface file to a set of go data
structures that can be either marshaled to or unmarshaled from standard
XDR binary format or traversed for other purposes such as
pretty\-printing.
It does not rely on go's reflection facilities, and so can be used to
special\-case handling of different XDR typedefs that represent
identical go types.
.PP
goxdr\-compiled XDR types map to the most intuitive go equivalent:
strings map to strings, pointers map to pointers, fixed\-size arrays map
to arrays, and variable\-length arrays map to slices, without new type
declarations that might complicating assignment.
E.g., the XDR \f[C]typedef\ string\ mystring<32>\f[] is just a string,
and so can be assigned from a string.
This does mean you can assign a string longer than 32 bytes, but length
limits are rigorously enforced during both marshaling and unmarshaling.
.SS Type representations
.PP
To be consistent with go's symbol export policy, all types, enum
constants, and struct/union fields defined in an XDR file are
capitalized in the corresponding go representation.
Base XDR types are mapped to their equivalent go types as follows:
.IP
.nf
\f[C]
XDR\ type\ \ \ \ \ \ \ \ Go\ type\ \ \ \ \ notes
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\ \ \-\-\-\-\-\-\-\-\-\ \ \ \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
bool\ \ \ \ \ \ \ \ \ \ \ \ bool\ \ \ \ \ \ \ \ const\ (TRUE=true;\ FALSE=false)
int\ \ \ \ \ \ \ \ \ \ \ \ \ int32
unsigned\ int\ \ \ \ uint32
hyper\ \ \ \ \ \ \ \ \ \ \ int64
unsigned\ hyper\ \ uint64
float\ \ \ \ \ \ \ \ \ \ \ float32
double\ \ \ \ \ \ \ \ \ \ float64
quadruple\ \ \ \ \ \ \ float128\ \ \ \ but\ float128\ is\ not\ defined
string<n>\ \ \ \ \ \ \ string
opaque<n>\ \ \ \ \ \ \ []byte
opaque[n]\ \ \ \ \ \ \ [n]byte
T*\ \ \ \ \ \ \ \ \ \ \ \ \ \ *T\ \ \ \ \ \ \ \ \ \ for\ any\ XDR\ type\ T
T<n>\ \ \ \ \ \ \ \ \ \ \ \ []T\ \ \ \ \ \ \ \ \ for\ any\ XDR\ type\ T
T[n]\ \ \ \ \ \ \ \ \ \ \ \ [n]T\ \ \ \ \ \ \ \ for\ any\ XDR\ type\ T
\f[]
.fi
.PP
Each XDR \f[C]typedef\f[] is compiled to a go type alias
(\f[C]type\ Alias\ =\ Original\f[]).
.PP
Each XDR \f[C]enum\f[] declaration compiles to a defined type whose
representation is an \f[C]int32\f[].
The constants of the enum are defined as go constants of the new defined
type.
.PP
XDR defines bools as equivalent to an \f[C]enum\f[] with name
identifiers \f[C]TRUE\f[] and \f[C]FALSE\f[].
Hence, goxdr introduces these names as aliases for go's \f[C]true\f[]
and \f[C]false\f[].
Be sure to use the capitalized versions in case statements of XDR source
files so as to maintain compatibility with other languages and
implementations.
.PP
An XDR \f[C]struct\f[] is compiled to a defined type represented as a go
struct containing each field of the XDR struct.
.PP
An XDR \f[C]union\f[] is compiled to a data structure with one public
field for the discriminant and one method for each non\-void \[lq]arm
declaration\[rq] (i.e., declaration in a case statement) that returns a
pointer to a value of the appropriate type.
There is no need to initialize the union when setting the discriminant;
changing its value just causes the appropriate method to return a
non\-nil pointer.
Invoking the wrong method for the current discriminant value calls
panic.
.PP
As an example, the following XDR:
.IP
.nf
\f[C]
enum\ myenum\ {
\ \ \ \ tag1\ =\ 1,
\ \ \ \ tag2\ =\ 2,
\ \ \ \ tag3\ =\ 3
};

union\ myunion\ switch\ (myenum\ discriminant)\ {
\ \ \ \ case\ tag1:
\ \ \ \ \ \ \ \ int\ one;
\ \ \ \ case\ tag2:
\ \ \ \ \ \ \ \ string\ two<>;
\ \ \ \ default:
\ \ \ \ \ \ \ \ void;
};
\f[]
.fi
.PP
compiles to this go code:
.IP
.nf
\f[C]
type\ Myenum\ int32
const\ (
\ \ \ \ Tag1\ =\ Myenum(1)
\ \ \ \ Tag2\ =\ Myenum(2)
\ \ \ \ Tag3\ =\ Myenum(3)
)
func\ XDR_Myenum(x\ XDR,\ name\ string,\ v\ *Myenum)\ {...}

type\ Myunion\ struct\ {
\ \ \ \ Discriminant\ Myenum
\ \ \ \ ....
}
func\ (u\ *Myunion)\ One()\ *int32\ {...}
func\ (u\ *Myunion)\ Two()\ *string\ {...}
func\ XDR_Myunion(x\ XDR,\ name\ string,\ v\ *Myunion)\ {...}
\f[]
.fi
.SS The XDR interface
.PP
For every type \f[C]T\f[] generated by goxdr (where \f[C]T\f[] is the
capitalized go type), including typedefs, goxdr generates a function
.IP
.nf
\f[C]
func\ XDR_T(x\ XDR,\ name\ string,\ v\ *T)\ {...}
\f[]
.fi
.PP
that can be used to marshal, unmarshal, or otherwise traverse the data
structure.
The \f[C]name\f[] argument has no effect for RFC4506\-compliant binary
marshaling, and can safely be supplied as the empty string \f[C]""\f[].
However, when traversing an XDR type for other purposes such as
pretty\-printing, \f[C]name\f[] will be set to the nested name of the
field (with components separated by period).
.PP
The argument \f[C]x\f[] implements the XDR interface and determines what
XDR_T actually does (i.e., marshal or unmarshal).
It has the following interface:
.IP
.nf
\f[C]
type\ XdrType\ interface\ {
\ \ \ \ XdrValue()\ interface{}
\ \ \ \ XdrPointer()\ interface{}
}

type\ XDR\ interface\ {
\ \ \ \ Marshal(name\ string,\ val\ XdrType)
\ \ \ \ Sprintf(string,\ ...interface{})\ string
}
\f[]
.fi
.PP
\f[C]Sprintf\f[] is expected to be a copy of \f[C]fmt.Sprintf\f[].
However, XDR back\-ends that do not make use of the \f[C]name\f[]
argument (notably marshaling to RFC4506 binary format) can save some
overhead by returning an empty string.
Hence, the following are the two sensible implementations of
\f[C]Sprintf\f[]:
.IP
.nf
\f[C]
func\ (xp\ *MyXDR1)\ Sprintf(f\ string,\ args\ ...interface{})\ string\ {
\ \ \ \ return\ fmt.Sprintf(f,\ args...)
}

func\ (xp\ *MyXDR2)\ Sprintf(f\ string,\ args\ ...interface{})\ string\ {
\ \ \ \ return\ ""
}
\f[]
.fi
.PP
\f[C]Marshal\f[] is the method that actually does whatever work will be
applied to the data structure.
The second argument, \f[C]val\f[], will be the go value that must be
marshaled/unmarshaled.
To simplify data structure traversal, the value is not always just a
pointer to the value to be marshaled\[en]in some cases the value is cast
to or wrapped in a defined type that allows handling of many different
types to be collapsed together.
Specifically, here is the type of \f[C]val\f[] depending on what is
being marshaled:
.IP \[bu] 2
For bool and all 32\-bit numeric types (including the size of
variable\-length arrays), \f[C]val\f[] is passed as a pointer
implementing \f[C]XdrNum32\f[], which allows the value to be extracted
and set as a \f[C]uint32\f[].
.IP \[bu] 2
For all 64\-bit numeric types, \f[C]val\f[] is passed as a pointer
implementing \f[C]XdrNum64\f[], which allows the value to be extracted
and set as a \f[C]uint64\f[].
.IP \[bu] 2
For \f[C]struct\f[] and \f[C]union\f[] types, \f[C]val\f[] is just a
pointer to the type being marshaled.
However, these types implement the \f[C]XdrAggregate\f[] interface,
which allows the \f[C]Marshal\f[] method of \f[C]XDR\f[] to call the
\f[C]XdrMarshal(x\ XDR,\ name\ string)\f[] method on \f[C]val\f[] to
recurse through all fields of \f[C]val\f[].
.IP \[bu] 2
\f[C]enum\f[] types are also passed as a simple pointer to the
underlying field, but \f[C]enum\f[] types implement \f[C]XdrNum32\f[]
instead of \f[C]XdrAggregate\f[].
.IP \[bu] 2
Fixed\-length arrays (other than \f[C]opaque[]\f[]) are passed to
\f[C]Marshal\f[] one element at a time, so \f[C]Marshal\f[] is never
called on the whole array (or on a pointer to the whole array).
.IP \[bu] 2
Variable\-length arrays (other than \f[C]opaque<>\f[]) are passed first
as a pointer to a defined type implementing the \f[C]XdrVec\f[] and
\f[C]XdrAggregate\f[] interfaces.
If \f[C]Marshal\f[] calls the \f[C]XdrMarshal\f[] function (as for a
\f[C]struct\f[] or \f[C]union\f[]), it recurses, first calling
\f[C]Marshal\f[] on a value of \f[C]XdrSize\f[], then on each element of
the vector.
.IP \[bu] 2
Similar to variable\-length arrays, pointers use a defined type that
implements the \f[C]XdrPtr\f[] and \f[C]XdrAggregate\f[] interfaces.
When recursing, \f[C]Marshal\f[] is called first on another defined type
that implements \f[C]XdrUint32\f[] (capable of containing the value 0 or
1 to indicate nil or value\-present), then, if the pointer is non\-nil,
on the underlying value.
.IP \[bu] 2
\f[C]string\f[] is passed as an \f[C]XdrString\f[], which also encodes
the size bound of the string and implements the \f[C]XdrVarBytes\f[] and
\f[C]XdrBytes\f[] interfaces.
.IP \[bu] 2
\f[C]opaque<>\f[] is passed as an \f[C]XdrVecOpaque\f[] structure, which
also implements the \f[C]XdrVarBytes\f[] and \f[C]XdrBytes\f[]
interfaces.
.IP \[bu] 2
\f[C]opaque[]\f[] is passed as an \f[C]XdrArrayOpaque\f[] (user\-defined
slice type pointing to the entire array).
This type implements \f[C]XdrBytes\f[] but not \f[C]XdrVarBytes\f[].
.PP
For most types, the original type or a pointer to it can be retrieved
via the \f[C]XdrPointer()\f[] and \f[C]XdrValue()\f[] methods, which
return an \f[C]interface{}\f[].
Two exceptions are \f[C]XdrArrayOpaque\f[] (for which
\f[C]XdrValue()\f[] returns a slice and \f[C]XdrPointer\f[] returns
\f[C]nil\f[]), and the fake \f[C]bool\f[] on which \f[C]Marshal\f[] is
called for a pointer type (which bool supports \f[C]XdrValue()\f[], but
returns \f[C]nil\f[] from \f[C]XdrPointer()\f[]).
.SS XDR functions
.PP
As previously mentioned, each (capitalized) type \f[C]T\f[] output by
goxdr also has function \f[C]XDR_T\f[].
For types that are instances of \f[C]XdrAggregate\f[] (that is
\f[C]struct\f[] and \f[C]union\f[] types, as well as pointers and
variable\-length arrays), this function is a simple wrapper around the
\f[C]Marshal\f[] method:
.IP
.nf
\f[C]
func\ XDR_T(x\ XDR,\ name\ string,\ v\ *T)\ {
\ \ \ \ x.Marshal(name,\ v)
}
\f[]
.fi
.PP
For other types, however, this generated function casts \f[C]v\f[] to a
more convenient alternate type implementing the interfaces described in
the previous subsection.
As an example, the following function in the pre\-defined boilerplate
casts an ordinary \f[C]*int32\f[] into the defined type
\f[C]*XdrInt32\f[] which implements the \f[C]XdrNum32\f[] interface:
.IP
.nf
\f[C]
func\ XDR_int32(x\ XDR,\ name\ string,\ v\ *int32)\ {
\ \ \ \ \ \ \ \ x.Marshal(name,\ (*XdrInt32)(v))
}
\f[]
.fi
.PP
Note that an XDR \f[C]Marshal\f[] method can use a type switch to
special\-case certain types.
However, this does not work for \f[C]typedefs\f[], which goxdr emits as
type aliases rather than defined types\[em]i.e.
\[lq]\f[C]type\ Alias\ =\ Original\f[]\[rq] rather than
\[lq]\f[C]type\ Alias\ Original\f[]\[rq].
However, the \f[C]XDR_Alias\f[] function for such a typedef checks for a
method called
\f[C]x.Marshal_Alias(x\ XDR,\ name\ string,\ v\ *Alias)\f[] and calls it
instead of \f[C]x.Marshal\f[] if it exists, allowing code to
differentiate type aliases.
.PP
XDR functions panic with type \f[C]XdrError\f[] (a user\-defined string)
if the input is invalid or a value is out of range.
.SS Pre\-defined XDR types
.PP
The predefined types \f[C]XdrOut\f[], \f[C]XdrIn\f[], and
\f[C]XdrPrint\f[] implement the \f[C]XDR\f[] interface and perform
RFC4506 binary marshaling, RFC4506 binary unmarshaling, and
pretty\-printing, respectively.
.IP
.nf
\f[C]
type\ XdrOut\ struct\ {
\ \ \ \ Out\ io.Writer
}
type\ XdrIn\ struct\ {
\ \ \ \ In\ io.Reader
}
type\ XdrPrint\ struct\ {
\ \ \ \ Out\ io.Writer
}
\f[]
.fi
.SH OPTIONS
.PP
goxdr supports the following options:
.TP
.B \f[C]\-help\f[]
Print a brief usage message.
.RS
.RE
.TP
.B \f[C]\-b\f[]
goxdr outputs boilerplate code to assist in marshaling and unmarshaling
values.
Only one copy of this boilerplate should be included in a package.
If you use goxdr to compile all XDR input files to a single go file (the
recommended usage), then you will get only one copy of the boilerplate.
However, if you compile different XDR files into different go files, you
will need to specify \f[C]\-b\f[] with each XDR input file to avoid
including the boilerplate, then run goxdr with no input files
(\f[C]goxdr\ \-o\ goxdr_boilerplate.go\f[]) to get one copy of the
boilerplate.
.RS
.RE
.TP
.B \f[C]\-o\f[] \f[I]output.go\f[]
Write the output to file \f[I]output.go\f[] instead of standard output.
.RS
.RE
.TP
.B \f[C]\-p\f[] \f[I]package\f[]
Specify the package name to use for the generated code.
The default is for the generated code to declare \f[C]package\ main\f[].
.RS
.RE
.SH EXAMPLES
.PP
To serialize a data structure of type \f[C]MyType\f[]:
.IP
.nf
\f[C]
func\ serialize_Mytype(val\ *MyType)\ []byte\ {
\ \ \ \ buf\ :=\ &bytes.Buffer{}
\ \ \ \ XDR_MyType(&XdrOut{\ buf\ },\ "",\ val)
\ \ \ \ return\ buf.Bytes()
}
\f[]
.fi
.PP
To serialize/unserialize an arbitrary instance of \f[C]XdrAggregate\f[]
(any struct or union, but not simpler types such as integers and
strings):
.IP
.nf
\f[C]
func\ serialize(val\ XdrAggregate)\ []byte\ {
\ \ \ \ buf\ :=\ &bytes.Buffer{}
\ \ \ \ val.XdrMarshal(&XdrOut{\ buf\ },\ "")
\ \ \ \ return\ buf.Bytes()
}

func\ deserialize(val\ XdrAggregate,\ in\ []byte)\ (e\ error)\ {
\ \ \ \ defer\ func()\ {
\ \ \ \ \ \ \ \ switch\ i\ :=\ recover().(type)\ {
\ \ \ \ \ \ \ \ case\ nil:
\ \ \ \ \ \ \ \ case\ XdrError:
\ \ \ \ \ \ \ \ \ \ \ \ e\ =\ i
\ \ \ \ \ \ \ \ default:
\ \ \ \ \ \ \ \ \ \ \ \ panic(i)
\ \ \ \ \ \ \ \ }
\ \ \ \ }()
\ \ \ \ val.XdrMarshal(&XdrIn{\ bytes.NewBuffer(in)\ },\ "")
\ \ \ \ return\ nil
}
\f[]
.fi
.PP
To pretty\-print an arbitrary XDR\-defined data structure, but
special\-case any fields of type \f[C]MySpecialStruct\f[] by formatting
them with a function called \f[C]MySpecialString(*MySpecialStruct)\f[],
you can do the following:
.IP
.nf
\f[C]
type\ XdrMyPrint\ struct\ {
\ \ \ \ Out\ io.Writer
}

func\ (xp\ *XdrMyPrint)\ Sprintf(f\ string,\ args\ ...interface{})\ string\ {
\ \ \ \ return\ fmt.Sprintf(f,\ args...)
}

func\ (xp\ *XdrMyPrint)\ Marshal(name\ string,\ i\ XdrType)\ {
\ \ \ \ switch\ v\ :=\ i.(type)\ {
\ \ \ \ case\ *MySpecialStruct:
\ \ \ \ \ \ \ \ fmt.Fprintf(xp.Out,\ "%s:\ %s\\n",\ name,\ MySpecialString(v))
\ \ \ \ case\ fmt.Stringer:
\ \ \ \ \ \ \ \ fmt.Fprintf(xp.Out,\ "%s:\ %s\\n",\ name,\ v.String())
\ \ \ \ case\ XdrPtr:
\ \ \ \ \ \ \ \ fmt.Fprintf(xp.Out,\ "%s._present:\ %v\\n",\ name,\ v.GetPresent())
\ \ \ \ \ \ \ \ v.XdrMarshalValue(xp,\ name)
\ \ \ \ case\ XdrVec:
\ \ \ \ \ \ \ \ fmt.Fprintf(xp.Out,\ "%s.len:\ %d\\n",\ name,\ v.GetVecLen())
\ \ \ \ \ \ \ \ v.XdrMarshalN(xp,\ name,\ v.GetVecLen())
\ \ \ \ case\ XdrAggregate:
\ \ \ \ \ \ \ \ v.XdrMarshal(xp,\ name)
\ \ \ \ default:
\ \ \ \ \ \ \ \ fmt.Fprintf(xp.Out,\ "%s:\ %v\\n",\ name,\ i)
\ \ \ \ }
}

func\ MyXdrToString(t\ XdrAggregate)\ string\ {
\ \ \ \ out\ :=\ &strings.Builder{}
\ \ \ \ t.XdrMarshal(&XdrMyPrint{out},\ "")
\ \ \ \ return\ out.String()
}
\f[]
.fi
.SH SEE ALSO
.PP
rpcgen(1), xdrc(1)
.PP
<https://tools.ietf.org/html/rfc4506>
.SH BUGS
.PP
goxdr ignores program and version declarations, and should instead
compile them to something that can be used to implement RFC5531 RPC
interfaces.
.PP
goxdr is not hygienic.
Because it capitalizes symbols, it could produce a name clash if two
symbols differ only in the capitalization of the first letter.
Moreover, it introduces various helper types and functions that begin
\f[C]XDR_\f[] or \f[C]Xdr\f[], so could produce incorrect code if users
employ such identifiers in XDR files.
Though RFC4506 disallows identifiers that start with underscore, goxdr
accepts them and produces code with inconsistent export semantics (since
underscore cannot be capitalized).
.PP
IEEE 754 floating point allows for many different NaN (not a number)
values.
The marshaling code simply takes whatever binary value go has sitting in
memory, byteswapping on little\-endian machines.
Other languages and XDR implemenations may produce different NaN values
from the same code.
Hence, in the presence of floating point, the marshaled output of
seemingly deterministic code may vary across implementations.
.SH AUTHORS
David Mazieres.
