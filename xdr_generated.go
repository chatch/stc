// Code generated by goxdr -o xdr_generated.go xdr/Stellar-SCP.x xdr/Stellar-ledger-entries.x xdr/Stellar-ledger.x xdr/Stellar-overlay.x xdr/Stellar-transaction.x xdr/Stellar-types.x; DO NOT EDIT.

package main

//
// begin boilerplate
//

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"io"
	"math"
	"strings"
)

// Types passed to the XDR Marshal method are cast into or wrapped by
// helper types that help collapse similar cases (e.g., all 32-bit
// numbers are cast to a pointer implementing XdrNum32).  However, the
// XdrValue and XdrPointer methods give you access to a value or
// pointer to the original underlying type.
//
// There are two exceptions:
//
//   - opaque[] (fixed-length arrays of bytes) are returned as
//     XdrArrayOpaque (by XdrValue()) or nil (by XdrPointer()).  This
//     is because XdrArrayOpaque wraps a byte slice rather than an
//     actual array.  One generally doesn't want to pass arrays
//     around; moreover, getting a pointer to the actual array
//     provides less information, because one can't test for arrays in
//     a type switch without knowing the exact length of the array,
//     while one can always dynamically test the length of a slice.
//
//   - Pointer types, in their XdrMarshal methods, marshal a special
//     XdrNum32 type of 0 or 1 to record whether the pointer is nil or
//     the value is present.  Since this bool does not exist,
//     XdrPointer() returns nil (while XdrValue returns a bool).
//
// Note that arrays of types other than opaque are never passed to the
// Marshal method.  Rather, the XDR_Type function loops over the array
// and calls Marshal for each element of the array.
type XdrType interface {
	XdrValue() interface{}
	XdrPointer() interface{}
}

// The interface through which values are serialized, printed, etc.
// Note that in addition to the Marshal method, if you have a method
// Marshal_Type(string, *Type) and Type is a typedef (and only a
// typedef), then Marshal_Type will get called instead of Marshal for
// fields of type Type.  (For non-typedefs, you don't need this
// feature because the Marshal function can do a type switch on the
// interface it receives.)
type XDR interface {
	// A function that gets called for each value to be marshalled.
	// The val XdrType argument will be one of the following:
	//
	// * A pointer type implementing XdrNum32 for bool, int, unsigned
	//   int, float, the size of variable-length arrays except string
	//   and opaque, and enums.  In the case of enums, that instance
	//   will just be a pointer to the enum.  In the case of the other
	//   types, it will be a pointer to a defined type that implements
	//   the XdrNum32 interface (since plain go types cannot implement
	//   methods)--e.g., *XdrUint32 for unsigned int.  Variable array
	//   sizes are passed as *XdrSize, which enforces the bound.
	//
	// * A pointer type implementing XdrNum64 for hyper, unsigned
	//   hyper, and double.  These are user-defined versions of int64,
	//   uint64, and float64, called XdrInt64, XdrUint64, and
	//   XdrFloat64, respectively.
	//
	// * An instance of XdrBytes for strings and opaque.
	//   Specifically, strings are passed as XdrString, and
	//   variable-length opaque<> vectors are passed as XdrVecOpaque,
	//   both of which implement XdrVarBytes.
	//
	// * An XdrArrayOpaque containing a slice referencing a byte array
	//   for fixed-length opaque[].  XdrArrayOpaque implements
	//   XdrBytes, but not XdrVarBytes.
	//
	// * An instance of XdrAggregate for structs, unions, and
	//   pointers.  Note that structs and unions are just passed as
	//   pointers to the underlying structures (which all implement
	//   XdrAggregate).  Pointers are passed as an XdrPtr interface
	//   implemented by a defined pointer type (since plain pointers
	//   cannot have methods).
	//
	// Note that the Marshal method is responsible for recursing into
	// XdrAggregate instance by calling the XdrMarshal method.
	// Requiring the Marshal method to recurse manually allows it to
	// refrain from recursing in cases where it needs to special-case
	// the handling of specific types.
	Marshal(name string, val XdrType)

	// This method should just be fmt.Sprintf for XDRs that use name.
	// Those that don't use name can use a trivial method returning ""
	Sprintf(string, ...interface{}) string
}

// The error thrown by marshaling functions when data has bad value.
type XdrError string
func (v XdrError) Error() string { return string(v) }
func xdrPanic(s string, args ...interface{}) {
	panic(XdrError(fmt.Sprintf(s, args...)))
}

// RFC4506 defines bool as equivalent to an enum with values all-caps
// TRUE and FALSE.  For convenience, we represent and XDR bool as a Go
// bool instead, and so define these constants in case they show up in
// union cases.
const (
	TRUE = true
	FALSE = false
)


//
// User-defined types used to place methods on basic types
//

// All quantities that should be serialized as 32-bit numbers
// (including bools, enums, union discriminants, the bit saying
// whether or not a pointer is NULL, floats, and vector lenghts) are
// passed to the XDR.Marshal function as a pointer to a defined type
// implementing the XdrNum32 interface.  The one exception is string<>
// and opaque<>, for which it is the job of XDR.Marshal to serialize
// the 32-bit length.
type XdrNum32 interface {
	XdrType
	GetU32() uint32
	SetU32(uint32)
}

// All 64-bit numbers (hyper, unsigned hyper, and double) are passed
// to XDR.Marshal as a pointer to a defined type implementing
// XdrNum64.
type XdrNum64 interface {
	XdrType
	GetU64() uint64
	SetU64(uint64)
}

// opaque[] are passed to XDR.Marshal as quantities implementing the
// XdrBytes interface.
type XdrBytes interface {
	XdrType
	GetByteSlice() []byte
}

// opaque<> and string<> are passed to XDR.Marshal as quantities
// implementing XdrVarBytes.  Since XdrVarBytes is a superset of
// XdrBytes, Marshal functions that want to distinguish between
// opaque<> and opaque[] should first try a type assertion for
// XdrVarBytes (to check for opaque<>) and then if that fails try
// XdrBytes (to check for opaque[]).
type XdrVarBytes interface {
	XdrBytes
	XdrBound() uint32
	SetByteSlice([]byte)
}

// Any struct, union, pointer, or variable-length array type (except
// opaque<> and string<>) is passed to XDR.Marshal as a pointer
// implementing the XdrAggregate interface.  It is the responsibility
// of the XDR.Marshal function to call the XdrMarshal method so as to
// recurse into the data structure.  Placing reponsibility on
// XDR.Marshal for recursing allows a custom XDR to prune the
// serialization at particular types (e.g., for pretty-printing a
// partucular struct in a non-standard way).
type XdrAggregate interface {
	XdrType
	XdrMarshal(XDR, string)
}

// Any pointer type is passed to XDR.Marshal as a struct implementing
// the XdrPtr interface.  Note XdrPtr is a superset of XdrAggregate.
// When a Marshal function does nothing special for XdrPtr and treats
// the XdrPtr like any other XdrAggregate (calling XdrMarshal), the
// Marshal function will then get called one or two more times, first
// with an XdrNum32 (to marshal the non-NULL bit) and then again with
// the underlying value if the pointer is non-NULL.  An XDR.Marshal
// function that wants to special case pointers can access the present
// bit from the GetPresent and SetPresent methods, then bypass
// marshaling of the bit by calling XdrMarshalValue instead of
// XdrMarshal.
type XdrPtr interface {
	// Marshals first the present/not-present bool, then if true, the
	// underlying value.
	XdrAggregate

	GetPresent() bool
	SetPresent(bool)

	// If the present/not-present bool is false, this function does
	// nothing.  Otherwise, it marshals just the value, not the bit.
	XdrMarshalValue(XDR, string)
}

// Any vector type is passed as a pointer to a user-defined alias
// around a slice that implements the XdrVec interface.  XdrVec is a
// superset of XdrAggregate, so calling XdrMarshal will recurse to
// call XDR.Marshal first on the size (of type XdrSize), then on each
// element of the slice.  An XDR.Marshal function can manually marshal
// the size and then call XdrMarshalN to marshal n vector elements.
// (When deserializing, it is advisable *not* to call SetVecLen before
// calling XdrMarshalN in case the length is huge and would exhaust
// memory; XdrMarshalN gradually grows the slice size as needed so as
// to throw a premature EOF error if N is larger than the actual input
// data.)
type XdrVec interface {
	XdrAggregate
	XdrBound() uint32
	GetVecLen() uint32
	SetVecLen(uint32)
	XdrMarshalN(XDR, string, uint32)
}

func xdrSymChar(r rune) bool {
	return (r|0x20 >= 'a' && r|0x20 <= 'z') ||
		(r >= '0' && r <= '9') || r == '_'
}

type XdrVoid = struct{}

type XdrBool bool
func (v *XdrBool) String() string { return fmt.Sprintf("%v", v.XdrValue()) }
func (v *XdrBool) GetU32() uint32 { if *v { return 1 }; return 0 }
func (v *XdrBool) SetU32(nv uint32) {
	switch nv {
	case 0:
		*v = false
	case 1:
		*v = true
	}
	xdrPanic("bool must be 0 or 1")
}
func (v *XdrBool) XdrPointer() interface{} { return (*bool)(v) }
func (v *XdrBool) XdrValue() interface{} { return bool(*v) }
func XDR_bool(x XDR, name string, v *bool) { x.Marshal(name, (*XdrBool)(v)) }

type XdrInt32 int32
func (v *XdrInt32) String() string { return fmt.Sprintf("%v", v.XdrValue()) }
func (v *XdrInt32) GetU32() uint32 { return uint32(*v) }
func (v *XdrInt32) SetU32(nv uint32) { *v = XdrInt32(nv) }
func (v *XdrInt32) XdrPointer() interface{} { return (*int32)(v) }
func (v *XdrInt32) XdrValue() interface{} { return int32(*v) }
func XDR_int32(x XDR, name string, v *int32) {
	x.Marshal(name, (*XdrInt32)(v))
}

type XdrUint32 uint32
func (v *XdrUint32) String() string { return fmt.Sprintf("%v", v.XdrValue()) }
func (v *XdrUint32) GetU32() uint32 { return uint32(*v) }
func (v *XdrUint32) SetU32(nv uint32) { *v = XdrUint32(nv) }
func (v *XdrUint32) XdrPointer() interface{} { return (*uint32)(v) }
func (v *XdrUint32) XdrValue() interface{} { return uint32(*v) }
func XDR_uint32(x XDR, name string, v *uint32) {
	x.Marshal(name, (*XdrUint32)(v))
}

type XdrFloat32 float32
func (v *XdrFloat32) String() string { return fmt.Sprintf("%v", v.XdrValue()) }
func (v *XdrFloat32) GetU32() uint32 { return math.Float32bits(float32(*v)) }
func (v *XdrFloat32) SetU32(nv uint32) {
	*v = XdrFloat32(math.Float32frombits(nv))
}
func (v *XdrFloat32) XdrPointer() interface{} { return (*float32)(v) }
func (v *XdrFloat32) XdrValue() interface{} { return float32(*v) }
func XDR_float32(x XDR, name string, v *float32) {
	x.Marshal(name, (*XdrFloat32)(v))
}

type XdrSize struct {
	size uint32
	bound uint32
}
func (v *XdrSize) String() string { return fmt.Sprintf("%v", v.size) }
func (v *XdrSize) GetU32() uint32 { return v.size }
func (v *XdrSize) SetU32(nv uint32) {
	if nv > v.bound {
		xdrPanic("size %d greater than bound %d", nv, v.bound)
	} else if int(nv) < 0 {
		xdrPanic("size %d greater than max slice len", nv)
	}
	v.size = nv
}
func (v *XdrSize) XdrPointer() interface{} { return &v.size }
func (v *XdrSize) XdrValue() interface{} { return v.size }
func (v *XdrSize) XdrBound() uint32 { return v.bound }

type XdrInt64 int64
func (v *XdrInt64) String() string { return fmt.Sprintf("%v", v.XdrValue()) }
func (v *XdrInt64) GetU64() uint64 { return uint64(*v) }
func (v *XdrInt64) SetU64(nv uint64) { *v = XdrInt64(nv) }
func (v *XdrInt64) XdrPointer() interface{} { return (*int64)(v) }
func (v *XdrInt64) XdrValue() interface{} { return int64(*v) }
func XDR_int64(x XDR, name string, v *int64) { x.Marshal(name, (*XdrInt64)(v)) }

type XdrUint64 uint64
func (v *XdrUint64) String() string { return fmt.Sprintf("%v", v.XdrValue()) }
func (v *XdrUint64) GetU64() uint64 { return uint64(*v) }
func (v *XdrUint64) SetU64(nv uint64) { *v = XdrUint64(nv) }
func (v *XdrUint64) XdrPointer() interface{} { return (*uint64)(v) }
func (v *XdrUint64) XdrValue() interface{} { return uint64(*v) }
func XDR_uint64(x XDR, name string, v *uint64) {
	x.Marshal(name, (*XdrUint64)(v))
}

type XdrFloat64 float64
func (v *XdrFloat64) String() string { return fmt.Sprintf("%v", v.XdrValue()) }
func (v *XdrFloat64) GetU64() uint64 { return math.Float64bits(float64(*v)) }
func (v *XdrFloat64) SetU64(nv uint64) {
	*v = XdrFloat64(math.Float64frombits(nv))
}
func (v *XdrFloat64) XdrPointer() interface{} { return (*float64)(v) }
func (v *XdrFloat64) XdrValue() interface{} { return float64(*v) }
func XDR_float64(x XDR, name string, v *float64) {
	x.Marshal(name, (*XdrFloat64)(v))
}

type XdrString struct {
	Str *string
	Bound uint32
}
func (v XdrString) String() string { return fmt.Sprintf("%q", *v.Str) }
func (v XdrString) Scan(ss fmt.ScanState, _ rune) error {
	var s string
	if _, err := fmt.Fscanf(ss, "%q", &s); err != nil {
		return err
	} else if int64(len(s)) > int64(v.Bound) {
		return XdrError(fmt.Sprintf("Cannot store %d bytes in string<%d>",
			len(s), v.Bound))
	}
	*v.Str = s
	return nil
}
func (v XdrString) XdrBound() uint32 { return v.Bound }
func (v XdrString) GetString() string { return *v.Str }
func (v XdrString) SetString(s string) {
	if uint(len(s)) > uint(v.Bound) {
		xdrPanic("Cannot store %d bytes in string<%d>", len(s), v.Bound)
	}
	*v.Str = s
}
func (v XdrString) GetByteSlice() []byte { return ([]byte)(*v.Str) }
func (v XdrString) SetByteSlice(bs []byte) {
	if uint(len(bs)) > uint(v.Bound) {
		xdrPanic("Cannot store %d bytes in string<%d>", len(bs), v.Bound)
	}
	*v.Str = string(bs)
}
func (v XdrString) XdrPointer() interface{} { return v.Str }
func (v XdrString) XdrValue() interface{} { return *v.Str }

type XdrVecOpaque struct {
	Bytes *[]byte
	Bound uint32
}
func (v XdrVecOpaque) String() string {
	return fmt.Sprintf("%x", []byte(*v.Bytes))
}
func (v XdrVecOpaque) Scan(ss fmt.ScanState, _ rune) error {
	var bs []byte
	_, err := fmt.Fscanf(ss, "%x", &bs)
	if err == nil {
		v.SetByteSlice(bs)
	}
	return err
}
func (v XdrVecOpaque) GetByteSlice() []byte { return *v.Bytes }
func (v XdrVecOpaque) XdrBound() uint32 { return v.Bound }
func (v XdrVecOpaque) SetByteSlice(bs []byte) {
	if uint(len(bs)) > uint(v.Bound) {
		xdrPanic("Cannot store %d bytes in string<%d>", len(bs), v.Bound)
	}
	*v.Bytes = bs
}
func (v XdrVecOpaque) XdrPointer() interface{} { return v.Bytes }
func (v XdrVecOpaque) XdrValue() interface{} { return *v.Bytes }

type XdrArrayOpaque []byte
func (v XdrArrayOpaque) GetByteSlice() []byte { return ([]byte)(v) }
func (v XdrArrayOpaque) XdrValue() interface{} { return v }
func (v XdrArrayOpaque) XdrPointer() interface{} { return nil }
func (v XdrArrayOpaque) String() string { return fmt.Sprintf("%x", []byte(v)) }
func (v XdrArrayOpaque) Scan(ss fmt.ScanState, _ rune) error {
	var bs []byte
	_, err := fmt.Fscanf(ss, "%x", &bs)
	if err != nil {
		return err
	} else if len(bs) != len (v) {
		return XdrError("Wrong number of bytes when scanning opaque[]")
	}
	copy(([]byte)(v), bs)
	return nil
}

var _, _, _ fmt.Scanner = XdrString{}, XdrVecOpaque{}, XdrArrayOpaque{}


//
// Basic implementations of XDR interface
//

// Back end that renders an XDR data structure as simple text.
// Example:
//
//    XDR_MyType(&XdrPrint{os.Stdout}, "", &myVal)
//
type XdrPrint struct {
	Out io.Writer
}

// Generic function that converts any XDR struct or union to a string
func XdrToString(t XdrAggregate) string {
	out := &strings.Builder{}
	t.XdrMarshal(&XdrPrint{out}, "")
	return out.String()
}

func (xp *XdrPrint) Sprintf(f string, args ...interface{}) string {
	return fmt.Sprintf(f, args...)
}

func (xp *XdrPrint) Marshal(name string, i XdrType) {
	switch v := i.(type) {
	case fmt.Stringer:
		fmt.Fprintf(xp.Out, "%s: %s\n", name, v.String())
	case XdrPtr:
		fmt.Fprintf(xp.Out, "%s.present: %v\n", name, v.GetPresent())
		v.XdrMarshalValue(xp, fmt.Sprintf("(*%s)", name))
	case XdrVec:
		fmt.Fprintf(xp.Out, "%s.len: %d\n", name, v.GetVecLen())
		v.XdrMarshalN(xp, name, v.GetVecLen())
	case XdrAggregate:
		v.XdrMarshal(xp, name)
	default:
		fmt.Fprintf(xp.Out, "%s: %v\n", name, i)
	}
}

var xdrZerofill [4][]byte = [...][]byte{
	{}, {0,0,0}, {0,0}, {0},
}

func xdrPutBytes(out io.Writer, val []byte) {
	out.Write(val)
	out.Write(xdrZerofill[len(val)&3])
}

func xdrPut32(out io.Writer, val uint32) {
	b := make([]byte, 4)
	binary.BigEndian.PutUint32(b, val)
	out.Write(b)
}

func xdrPut64(out io.Writer, val uint64) {
	b := make([]byte, 8)
	binary.BigEndian.PutUint64(b, val)
	out.Write(b)
}


// XDR that marshals to canonical binary format
type XdrOut struct {
	Out io.Writer
}

func (xp *XdrOut) Sprintf(f string, args ...interface{}) string {
	return ""
}

func (xo *XdrOut) Marshal(name string, i XdrType) {
	switch v := i.(type) {
	case XdrNum32:
		xdrPut32(xo.Out, v.GetU32())
	case XdrNum64:
		xdrPut64(xo.Out, v.GetU64())
	case XdrString:
		s := v.GetString()
		xdrPut32(xo.Out, uint32(len(s)))
		io.WriteString(xo.Out, s)
		xo.Out.Write(xdrZerofill[len(s)&3])
	case XdrVarBytes:
		xdrPut32(xo.Out, uint32(len(v.GetByteSlice())))
		xdrPutBytes(xo.Out, v.GetByteSlice())
	case XdrBytes:
		xdrPutBytes(xo.Out, v.GetByteSlice())
	case XdrAggregate:
		v.XdrMarshal(xo, name)
	default:
		panic(fmt.Sprintf("XdrOut: unhandled type %T", i))
	}
}

func xdrReadN(in io.Reader, n uint32) []byte {
	var b bytes.Buffer
	if _, err := io.CopyN(&b, in, int64(n)); err != nil {
		xdrPanic(err.Error())
	}
	return b.Bytes()
}

func xdrReadPad(in io.Reader, n uint32) {
	if n & 3 != 0 {
		got := xdrReadN(in, 4-(n&3))
		for _, b := range got {
			if b != 0 {
				xdrPanic("padding contained non-zero bytes")
			}
		}
	}
}

func xdrGet32(in io.Reader) uint32 {
	b := xdrReadN(in, 4)
	return binary.BigEndian.Uint32(b)
}

func xdrGet64(in io.Reader) uint64 {
	b := xdrReadN(in, 8)
	return binary.BigEndian.Uint64(b)
}


// XDR that unmarshals from canonical binary format
type XdrIn struct {
	In io.Reader
}

func (xp *XdrIn) Sprintf(f string, args ...interface{}) string {
	return ""
}

func (xi *XdrIn) Marshal(name string, i XdrType) {
	switch v := i.(type) {
	case XdrNum32:
		v.SetU32(xdrGet32(xi.In))
	case XdrNum64:
		v.SetU64(xdrGet64(xi.In))
	case XdrVarBytes:
		n := xdrGet32(xi.In)
		v.SetByteSlice(xdrReadN(xi.In, n))
		xdrReadPad(xi.In, n)
	case XdrBytes:
		if _, err := io.ReadFull(xi.In, v.GetByteSlice()); err != nil {
			panic(err)
		}
		xdrReadPad(xi.In, uint32(len(v.GetByteSlice())))
	case XdrAggregate:
		v.XdrMarshal(xi, name)
	}
}

//
// end boilerplate
//

//
// Data types defined in XDR file
//

type Value = []byte

type SCPBallot struct {
	Counter Uint32
	Value Value
}

type SCPStatementType int32
const (
	SCP_ST_PREPARE = SCPStatementType(0)
	SCP_ST_CONFIRM = SCPStatementType(1)
	SCP_ST_EXTERNALIZE = SCPStatementType(2)
	SCP_ST_NOMINATE = SCPStatementType(3)
)

type SCPNomination struct {
	QuorumSetHash Hash
	Votes []Value
	Accepted []Value
}

type _SCPStatement_Pledges_Prepare struct {
	QuorumSetHash Hash
	Ballot SCPBallot
	Prepared *SCPBallot
	PreparedPrime *SCPBallot
	NC Uint32
	NH Uint32
}
type _SCPStatement_Pledges_Confirm struct {
	Ballot SCPBallot
	NPrepared Uint32
	NCommit Uint32
	NH Uint32
	QuorumSetHash Hash
}
type _SCPStatement_Pledges_Externalize struct {
	Commit SCPBallot
	NH Uint32
	CommitQuorumSetHash Hash
}
type _SCPStatement_Pledges struct {
	Type SCPStatementType
	// SCP_ST_PREPARE:
	//    Prepare() *_SCPStatement_Pledges_Prepare
	// SCP_ST_CONFIRM:
	//    Confirm() *_SCPStatement_Pledges_Confirm
	// SCP_ST_EXTERNALIZE:
	//    Externalize() *_SCPStatement_Pledges_Externalize
	// SCP_ST_NOMINATE:
	//    Nominate() *SCPNomination
	_u interface{}
}
type SCPStatement struct {
	NodeID NodeID
	SlotIndex Uint64
	Pledges _SCPStatement_Pledges
}

type SCPEnvelope struct {
	Statement SCPStatement
	Signature Signature
}

type SCPQuorumSet struct {
	Threshold Uint32
	Validators []PublicKey
	InnerSets []SCPQuorumSet
}

type AccountID = PublicKey

type Thresholds = [4]byte

type String32 = string // bound 32

type String64 = string // bound 64

type SequenceNumber = Int64

type DataValue = []byte // bound 64

type AssetType int32
const (
	ASSET_TYPE_NATIVE = AssetType(0)
	ASSET_TYPE_CREDIT_ALPHANUM4 = AssetType(1)
	ASSET_TYPE_CREDIT_ALPHANUM12 = AssetType(2)
)

type _Asset_AlphaNum4 struct {
	AssetCode [4]byte
	Issuer AccountID
}
type _Asset_AlphaNum12 struct {
	AssetCode [12]byte
	Issuer AccountID
}
type Asset struct {
	Type AssetType
	// ASSET_TYPE_CREDIT_ALPHANUM4:
	//    AlphaNum4() *_Asset_AlphaNum4
	// ASSET_TYPE_CREDIT_ALPHANUM12:
	//    AlphaNum12() *_Asset_AlphaNum12
	_u interface{}
}

type Price struct {
	N Int32
	D Int32
}

type Liabilities struct {
	Buying Int64
	Selling Int64
}

type ThresholdIndexes int32
const (
	THRESHOLD_MASTER_WEIGHT = ThresholdIndexes(0)
	THRESHOLD_LOW = ThresholdIndexes(1)
	THRESHOLD_MED = ThresholdIndexes(2)
	THRESHOLD_HIGH = ThresholdIndexes(3)
)

type LedgerEntryType int32
const (
	ACCOUNT = LedgerEntryType(0)
	TRUSTLINE = LedgerEntryType(1)
	OFFER = LedgerEntryType(2)
	DATA = LedgerEntryType(3)
)

type Signer struct {
	Key SignerKey
	Weight Uint32
}

type AccountFlags int32
const (
	AUTH_REQUIRED_FLAG = AccountFlags(0x1)
	AUTH_REVOCABLE_FLAG = AccountFlags(0x2)
	AUTH_IMMUTABLE_FLAG = AccountFlags(0x4)
)

const MASK_ACCOUNT_FLAGS = 0x7

type _AccountEntry_Ext_V1_Ext struct {
	V int32
	_u interface{}
}
type _AccountEntry_Ext_V1 struct {
	Liabilities Liabilities
	Ext _AccountEntry_Ext_V1_Ext
}
type _AccountEntry_Ext struct {
	V int32
	// 1:
	//    V1() *_AccountEntry_Ext_V1
	_u interface{}
}
type AccountEntry struct {
	AccountID AccountID
	Balance Int64
	SeqNum SequenceNumber
	NumSubEntries Uint32
	InflationDest *AccountID
	Flags Uint32
	HomeDomain String32
	Thresholds Thresholds
	Signers []Signer // bound 20
	Ext _AccountEntry_Ext
}

type TrustLineFlags int32
const (
	AUTHORIZED_FLAG = TrustLineFlags(1)
)

const MASK_TRUSTLINE_FLAGS = 1

type _TrustLineEntry_Ext_V1_Ext struct {
	V int32
	_u interface{}
}
type _TrustLineEntry_Ext_V1 struct {
	Liabilities Liabilities
	Ext _TrustLineEntry_Ext_V1_Ext
}
type _TrustLineEntry_Ext struct {
	V int32
	// 1:
	//    V1() *_TrustLineEntry_Ext_V1
	_u interface{}
}
type TrustLineEntry struct {
	AccountID AccountID
	Asset Asset
	Balance Int64
	Limit Int64
	Flags Uint32
	Ext _TrustLineEntry_Ext
}

type OfferEntryFlags int32
const (
	PASSIVE_FLAG = OfferEntryFlags(1)
)

const MASK_OFFERENTRY_FLAGS = 1

type _OfferEntry_Ext struct {
	V int32
	_u interface{}
}
type OfferEntry struct {
	SellerID AccountID
	OfferID Uint64
	Selling Asset
	Buying Asset
	Amount Int64
	Price Price
	Flags Uint32
	Ext _OfferEntry_Ext
}

type _DataEntry_Ext struct {
	V int32
	_u interface{}
}
type DataEntry struct {
	AccountID AccountID
	DataName String64
	DataValue DataValue
	Ext _DataEntry_Ext
}

type _LedgerEntry_Data struct {
	Type LedgerEntryType
	// ACCOUNT:
	//    Account() *AccountEntry
	// TRUSTLINE:
	//    TrustLine() *TrustLineEntry
	// OFFER:
	//    Offer() *OfferEntry
	// DATA:
	//    Data() *DataEntry
	_u interface{}
}
type _LedgerEntry_Ext struct {
	V int32
	_u interface{}
}
type LedgerEntry struct {
	LastModifiedLedgerSeq Uint32
	Data _LedgerEntry_Data
	Ext _LedgerEntry_Ext
}

type EnvelopeType int32
const (
	ENVELOPE_TYPE_SCP = EnvelopeType(1)
	ENVELOPE_TYPE_TX = EnvelopeType(2)
	ENVELOPE_TYPE_AUTH = EnvelopeType(3)
)

type UpgradeType = []byte // bound 128

type _StellarValue_Ext struct {
	V int32
	_u interface{}
}
type StellarValue struct {
	TxSetHash Hash
	CloseTime Uint64
	Upgrades []UpgradeType // bound 6
	Ext _StellarValue_Ext
}

type _LedgerHeader_Ext struct {
	V int32
	_u interface{}
}
type LedgerHeader struct {
	LedgerVersion Uint32
	PreviousLedgerHash Hash
	ScpValue StellarValue
	TxSetResultHash Hash
	BucketListHash Hash
	LedgerSeq Uint32
	TotalCoins Int64
	FeePool Int64
	InflationSeq Uint32
	IdPool Uint64
	BaseFee Uint32
	BaseReserve Uint32
	MaxTxSetSize Uint32
	SkipList [4]Hash
	Ext _LedgerHeader_Ext
}

type LedgerUpgradeType int32
const (
	LEDGER_UPGRADE_VERSION = LedgerUpgradeType(1)
	LEDGER_UPGRADE_BASE_FEE = LedgerUpgradeType(2)
	LEDGER_UPGRADE_MAX_TX_SET_SIZE = LedgerUpgradeType(3)
	LEDGER_UPGRADE_BASE_RESERVE = LedgerUpgradeType(4)
)

type LedgerUpgrade struct {
	Type LedgerUpgradeType
	// LEDGER_UPGRADE_VERSION:
	//    NewLedgerVersion() *Uint32
	// LEDGER_UPGRADE_BASE_FEE:
	//    NewBaseFee() *Uint32
	// LEDGER_UPGRADE_MAX_TX_SET_SIZE:
	//    NewMaxTxSetSize() *Uint32
	// LEDGER_UPGRADE_BASE_RESERVE:
	//    NewBaseReserve() *Uint32
	_u interface{}
}

type _LedgerKey_Account struct {
	AccountID AccountID
}
type _LedgerKey_TrustLine struct {
	AccountID AccountID
	Asset Asset
}
type _LedgerKey_Offer struct {
	SellerID AccountID
	OfferID Uint64
}
type _LedgerKey_Data struct {
	AccountID AccountID
	DataName String64
}
type LedgerKey struct {
	Type LedgerEntryType
	// ACCOUNT:
	//    Account() *_LedgerKey_Account
	// TRUSTLINE:
	//    TrustLine() *_LedgerKey_TrustLine
	// OFFER:
	//    Offer() *_LedgerKey_Offer
	// DATA:
	//    Data() *_LedgerKey_Data
	_u interface{}
}

type BucketEntryType int32
const (
	LIVEENTRY = BucketEntryType(0)
	DEADENTRY = BucketEntryType(1)
)

type BucketEntry struct {
	Type BucketEntryType
	// LIVEENTRY:
	//    LiveEntry() *LedgerEntry
	// DEADENTRY:
	//    DeadEntry() *LedgerKey
	_u interface{}
}

type TransactionSet struct {
	PreviousLedgerHash Hash
	Txs []TransactionEnvelope
}

type TransactionResultPair struct {
	TransactionHash Hash
	Result TransactionResult
}

type TransactionResultSet struct {
	Results []TransactionResultPair
}

type _TransactionHistoryEntry_Ext struct {
	V int32
	_u interface{}
}
type TransactionHistoryEntry struct {
	LedgerSeq Uint32
	TxSet TransactionSet
	Ext _TransactionHistoryEntry_Ext
}

type _TransactionHistoryResultEntry_Ext struct {
	V int32
	_u interface{}
}
type TransactionHistoryResultEntry struct {
	LedgerSeq Uint32
	TxResultSet TransactionResultSet
	Ext _TransactionHistoryResultEntry_Ext
}

type _LedgerHeaderHistoryEntry_Ext struct {
	V int32
	_u interface{}
}
type LedgerHeaderHistoryEntry struct {
	Hash Hash
	Header LedgerHeader
	Ext _LedgerHeaderHistoryEntry_Ext
}

type LedgerSCPMessages struct {
	LedgerSeq Uint32
	Messages []SCPEnvelope
}

type SCPHistoryEntryV0 struct {
	QuorumSets []SCPQuorumSet
	LedgerMessages LedgerSCPMessages
}

type SCPHistoryEntry struct {
	V int32
	// 0:
	//    V0() *SCPHistoryEntryV0
	_u interface{}
}

type LedgerEntryChangeType int32
const (
	LEDGER_ENTRY_CREATED = LedgerEntryChangeType(0)
	LEDGER_ENTRY_UPDATED = LedgerEntryChangeType(1)
	LEDGER_ENTRY_REMOVED = LedgerEntryChangeType(2)
	LEDGER_ENTRY_STATE = LedgerEntryChangeType(3)
)

type LedgerEntryChange struct {
	Type LedgerEntryChangeType
	// LEDGER_ENTRY_CREATED:
	//    Created() *LedgerEntry
	// LEDGER_ENTRY_UPDATED:
	//    Updated() *LedgerEntry
	// LEDGER_ENTRY_REMOVED:
	//    Removed() *LedgerKey
	// LEDGER_ENTRY_STATE:
	//    State() *LedgerEntry
	_u interface{}
}

type LedgerEntryChanges = []LedgerEntryChange

type OperationMeta struct {
	Changes LedgerEntryChanges
}

type TransactionMetaV1 struct {
	TxChanges LedgerEntryChanges
	Operations []OperationMeta
}

type TransactionMeta struct {
	V int32
	// 0:
	//    Operations() *[]OperationMeta
	// 1:
	//    V1() *TransactionMetaV1
	_u interface{}
}

type ErrorCode int32
const (
	ERR_MISC = ErrorCode(0)
	ERR_DATA = ErrorCode(1)
	ERR_CONF = ErrorCode(2)
	ERR_AUTH = ErrorCode(3)
	ERR_LOAD = ErrorCode(4)
)

type Error struct {
	Code ErrorCode
	Msg string // bound 100
}

type AuthCert struct {
	Pubkey Curve25519Public
	Expiration Uint64
	Sig Signature
}

type Hello struct {
	LedgerVersion Uint32
	OverlayVersion Uint32
	OverlayMinVersion Uint32
	NetworkID Hash
	VersionStr string // bound 100
	ListeningPort int32
	PeerID NodeID
	Cert AuthCert
	Nonce Uint256
}

type Auth struct {
	Unused int32
}

type IPAddrType int32
const (
	IPv4 = IPAddrType(0)
	IPv6 = IPAddrType(1)
)

type _PeerAddress_Ip struct {
	Type IPAddrType
	// IPv4:
	//    Ipv4() *[4]byte
	// IPv6:
	//    Ipv6() *[16]byte
	_u interface{}
}
type PeerAddress struct {
	Ip _PeerAddress_Ip
	Port Uint32
	NumFailures Uint32
}

type MessageType int32
const (
	ERROR_MSG = MessageType(0)
	AUTH = MessageType(2)
	DONT_HAVE = MessageType(3)
	GET_PEERS = MessageType(4)
	PEERS = MessageType(5)
	GET_TX_SET = MessageType(6)
	TX_SET = MessageType(7)
	TRANSACTION = MessageType(8)
	GET_SCP_QUORUMSET = MessageType(9)
	SCP_QUORUMSET = MessageType(10)
	SCP_MESSAGE = MessageType(11)
	GET_SCP_STATE = MessageType(12)
	HELLO = MessageType(13)
)

type DontHave struct {
	Type MessageType
	ReqHash Uint256
}

type StellarMessage struct {
	Type MessageType
	// ERROR_MSG:
	//    Error() *Error
	// HELLO:
	//    Hello() *Hello
	// AUTH:
	//    Auth() *Auth
	// DONT_HAVE:
	//    DontHave() *DontHave
	// PEERS:
	//    Peers() *[]PeerAddress // bound 100
	// GET_TX_SET:
	//    TxSetHash() *Uint256
	// TX_SET:
	//    TxSet() *TransactionSet
	// TRANSACTION:
	//    Transaction() *TransactionEnvelope
	// GET_SCP_QUORUMSET:
	//    QSetHash() *Uint256
	// SCP_QUORUMSET:
	//    QSet() *SCPQuorumSet
	// SCP_MESSAGE:
	//    Envelope() *SCPEnvelope
	// GET_SCP_STATE:
	//    GetSCPLedgerSeq() *Uint32
	_u interface{}
}

type _AuthenticatedMessage_V0 struct {
	Sequence Uint64
	Message StellarMessage
	Mac HmacSha256Mac
}
type AuthenticatedMessage struct {
	V Uint32
	// 0:
	//    V0() *_AuthenticatedMessage_V0
	_u interface{}
}

type DecoratedSignature struct {
	Hint SignatureHint
	Signature Signature
}

type OperationType int32
const (
	CREATE_ACCOUNT = OperationType(0)
	PAYMENT = OperationType(1)
	PATH_PAYMENT = OperationType(2)
	MANAGE_OFFER = OperationType(3)
	CREATE_PASSIVE_OFFER = OperationType(4)
	SET_OPTIONS = OperationType(5)
	CHANGE_TRUST = OperationType(6)
	ALLOW_TRUST = OperationType(7)
	ACCOUNT_MERGE = OperationType(8)
	INFLATION = OperationType(9)
	MANAGE_DATA = OperationType(10)
	BUMP_SEQUENCE = OperationType(11)
)

type CreateAccountOp struct {
	Destination AccountID
	StartingBalance Int64
}

type PaymentOp struct {
	Destination AccountID
	Asset Asset
	Amount Int64
}

type PathPaymentOp struct {
	SendAsset Asset
	SendMax Int64
	Destination AccountID
	DestAsset Asset
	DestAmount Int64
	Path []Asset // bound 5
}

type ManageOfferOp struct {
	Selling Asset
	Buying Asset
	Amount Int64
	Price Price
	OfferID Uint64
}

type CreatePassiveOfferOp struct {
	Selling Asset
	Buying Asset
	Amount Int64
	Price Price
}

type SetOptionsOp struct {
	InflationDest *AccountID
	ClearFlags *Uint32
	SetFlags *Uint32
	MasterWeight *Uint32
	LowThreshold *Uint32
	MedThreshold *Uint32
	HighThreshold *Uint32
	HomeDomain *String32
	Signer *Signer
}

type ChangeTrustOp struct {
	Line Asset
	Limit Int64
}

type _AllowTrustOp_Asset struct {
	Type AssetType
	// ASSET_TYPE_CREDIT_ALPHANUM4:
	//    AssetCode4() *[4]byte
	// ASSET_TYPE_CREDIT_ALPHANUM12:
	//    AssetCode12() *[12]byte
	_u interface{}
}
type AllowTrustOp struct {
	Trustor AccountID
	Asset _AllowTrustOp_Asset
	Authorize bool
}

type ManageDataOp struct {
	DataName String64
	DataValue *DataValue
}

type BumpSequenceOp struct {
	BumpTo SequenceNumber
}

type _Operation_Body struct {
	Type OperationType
	// CREATE_ACCOUNT:
	//    CreateAccountOp() *CreateAccountOp
	// PAYMENT:
	//    PaymentOp() *PaymentOp
	// PATH_PAYMENT:
	//    PathPaymentOp() *PathPaymentOp
	// MANAGE_OFFER:
	//    ManageOfferOp() *ManageOfferOp
	// CREATE_PASSIVE_OFFER:
	//    CreatePassiveOfferOp() *CreatePassiveOfferOp
	// SET_OPTIONS:
	//    SetOptionsOp() *SetOptionsOp
	// CHANGE_TRUST:
	//    ChangeTrustOp() *ChangeTrustOp
	// ALLOW_TRUST:
	//    AllowTrustOp() *AllowTrustOp
	// ACCOUNT_MERGE:
	//    Destination() *AccountID
	// MANAGE_DATA:
	//    ManageDataOp() *ManageDataOp
	// BUMP_SEQUENCE:
	//    BumpSequenceOp() *BumpSequenceOp
	_u interface{}
}
type Operation struct {
	SourceAccount *AccountID
	Body _Operation_Body
}

type MemoType int32
const (
	MEMO_NONE = MemoType(0)
	MEMO_TEXT = MemoType(1)
	MEMO_ID = MemoType(2)
	MEMO_HASH = MemoType(3)
	MEMO_RETURN = MemoType(4)
)

type Memo struct {
	Type MemoType
	// MEMO_TEXT:
	//    Text() *string // bound 28
	// MEMO_ID:
	//    Id() *Uint64
	// MEMO_HASH:
	//    Hash() *Hash
	// MEMO_RETURN:
	//    RetHash() *Hash
	_u interface{}
}

type TimeBounds struct {
	MinTime Uint64
	MaxTime Uint64
}

type _Transaction_Ext struct {
	V int32
	_u interface{}
}
type Transaction struct {
	SourceAccount AccountID
	Fee Uint32
	SeqNum SequenceNumber
	TimeBounds *TimeBounds
	Memo Memo
	Operations []Operation // bound 100
	Ext _Transaction_Ext
}

type _TransactionSignaturePayload_TaggedTransaction struct {
	Type EnvelopeType
	// ENVELOPE_TYPE_TX:
	//    Tx() *Transaction
	_u interface{}
}
type TransactionSignaturePayload struct {
	NetworkId Hash
	TaggedTransaction _TransactionSignaturePayload_TaggedTransaction
}

type TransactionEnvelope struct {
	Tx Transaction
	Signatures []DecoratedSignature // bound 20
}

type ClaimOfferAtom struct {
	SellerID AccountID
	OfferID Uint64
	AssetSold Asset
	AmountSold Int64
	AssetBought Asset
	AmountBought Int64
}

type CreateAccountResultCode int32
const (
	CREATE_ACCOUNT_SUCCESS = CreateAccountResultCode(0)
	CREATE_ACCOUNT_MALFORMED = CreateAccountResultCode(-1)
	CREATE_ACCOUNT_UNDERFUNDED = CreateAccountResultCode(-2)
	CREATE_ACCOUNT_LOW_RESERVE = CreateAccountResultCode(-3)
	CREATE_ACCOUNT_ALREADY_EXIST = CreateAccountResultCode(-4)
)

type CreateAccountResult struct {
	Code CreateAccountResultCode
	_u interface{}
}

type PaymentResultCode int32
const (
	PAYMENT_SUCCESS = PaymentResultCode(0)
	PAYMENT_MALFORMED = PaymentResultCode(-1)
	PAYMENT_UNDERFUNDED = PaymentResultCode(-2)
	PAYMENT_SRC_NO_TRUST = PaymentResultCode(-3)
	PAYMENT_SRC_NOT_AUTHORIZED = PaymentResultCode(-4)
	PAYMENT_NO_DESTINATION = PaymentResultCode(-5)
	PAYMENT_NO_TRUST = PaymentResultCode(-6)
	PAYMENT_NOT_AUTHORIZED = PaymentResultCode(-7)
	PAYMENT_LINE_FULL = PaymentResultCode(-8)
	PAYMENT_NO_ISSUER = PaymentResultCode(-9)
)

type PaymentResult struct {
	Code PaymentResultCode
	_u interface{}
}

type PathPaymentResultCode int32
const (
	PATH_PAYMENT_SUCCESS = PathPaymentResultCode(0)
	PATH_PAYMENT_MALFORMED = PathPaymentResultCode(-1)
	PATH_PAYMENT_UNDERFUNDED = PathPaymentResultCode(-2)
	PATH_PAYMENT_SRC_NO_TRUST = PathPaymentResultCode(-3)
	PATH_PAYMENT_SRC_NOT_AUTHORIZED = PathPaymentResultCode(-4)
	PATH_PAYMENT_NO_DESTINATION = PathPaymentResultCode(-5)
	PATH_PAYMENT_NO_TRUST = PathPaymentResultCode(-6)
	PATH_PAYMENT_NOT_AUTHORIZED = PathPaymentResultCode(-7)
	PATH_PAYMENT_LINE_FULL = PathPaymentResultCode(-8)
	PATH_PAYMENT_NO_ISSUER = PathPaymentResultCode(-9)
	PATH_PAYMENT_TOO_FEW_OFFERS = PathPaymentResultCode(-10)
	PATH_PAYMENT_OFFER_CROSS_SELF = PathPaymentResultCode(-11)
	PATH_PAYMENT_OVER_SENDMAX = PathPaymentResultCode(-12)
)

type SimplePaymentResult struct {
	Destination AccountID
	Asset Asset
	Amount Int64
}

type _PathPaymentResult_Success struct {
	Offers []ClaimOfferAtom
	Last SimplePaymentResult
}
type PathPaymentResult struct {
	Code PathPaymentResultCode
	// PATH_PAYMENT_SUCCESS:
	//    Success() *_PathPaymentResult_Success
	// PATH_PAYMENT_NO_ISSUER:
	//    NoIssuer() *Asset
	_u interface{}
}

type ManageOfferResultCode int32
const (
	MANAGE_OFFER_SUCCESS = ManageOfferResultCode(0)
	MANAGE_OFFER_MALFORMED = ManageOfferResultCode(-1)
	MANAGE_OFFER_SELL_NO_TRUST = ManageOfferResultCode(-2)
	MANAGE_OFFER_BUY_NO_TRUST = ManageOfferResultCode(-3)
	MANAGE_OFFER_SELL_NOT_AUTHORIZED = ManageOfferResultCode(-4)
	MANAGE_OFFER_BUY_NOT_AUTHORIZED = ManageOfferResultCode(-5)
	MANAGE_OFFER_LINE_FULL = ManageOfferResultCode(-6)
	MANAGE_OFFER_UNDERFUNDED = ManageOfferResultCode(-7)
	MANAGE_OFFER_CROSS_SELF = ManageOfferResultCode(-8)
	MANAGE_OFFER_SELL_NO_ISSUER = ManageOfferResultCode(-9)
	MANAGE_OFFER_BUY_NO_ISSUER = ManageOfferResultCode(-10)
	MANAGE_OFFER_NOT_FOUND = ManageOfferResultCode(-11)
	MANAGE_OFFER_LOW_RESERVE = ManageOfferResultCode(-12)
)

type ManageOfferEffect int32
const (
	MANAGE_OFFER_CREATED = ManageOfferEffect(0)
	MANAGE_OFFER_UPDATED = ManageOfferEffect(1)
	MANAGE_OFFER_DELETED = ManageOfferEffect(2)
)

type _ManageOfferSuccessResult_Offer struct {
	Effect ManageOfferEffect
	// MANAGE_OFFER_CREATED, MANAGE_OFFER_UPDATED:
	//    Offer() *OfferEntry
	_u interface{}
}
type ManageOfferSuccessResult struct {
	OffersClaimed []ClaimOfferAtom
	Offer _ManageOfferSuccessResult_Offer
}

type ManageOfferResult struct {
	Code ManageOfferResultCode
	// MANAGE_OFFER_SUCCESS:
	//    Success() *ManageOfferSuccessResult
	_u interface{}
}

type SetOptionsResultCode int32
const (
	SET_OPTIONS_SUCCESS = SetOptionsResultCode(0)
	SET_OPTIONS_LOW_RESERVE = SetOptionsResultCode(-1)
	SET_OPTIONS_TOO_MANY_SIGNERS = SetOptionsResultCode(-2)
	SET_OPTIONS_BAD_FLAGS = SetOptionsResultCode(-3)
	SET_OPTIONS_INVALID_INFLATION = SetOptionsResultCode(-4)
	SET_OPTIONS_CANT_CHANGE = SetOptionsResultCode(-5)
	SET_OPTIONS_UNKNOWN_FLAG = SetOptionsResultCode(-6)
	SET_OPTIONS_THRESHOLD_OUT_OF_RANGE = SetOptionsResultCode(-7)
	SET_OPTIONS_BAD_SIGNER = SetOptionsResultCode(-8)
	SET_OPTIONS_INVALID_HOME_DOMAIN = SetOptionsResultCode(-9)
)

type SetOptionsResult struct {
	Code SetOptionsResultCode
	_u interface{}
}

type ChangeTrustResultCode int32
const (
	CHANGE_TRUST_SUCCESS = ChangeTrustResultCode(0)
	CHANGE_TRUST_MALFORMED = ChangeTrustResultCode(-1)
	CHANGE_TRUST_NO_ISSUER = ChangeTrustResultCode(-2)
	CHANGE_TRUST_INVALID_LIMIT = ChangeTrustResultCode(-3)
	CHANGE_TRUST_LOW_RESERVE = ChangeTrustResultCode(-4)
	CHANGE_TRUST_SELF_NOT_ALLOWED = ChangeTrustResultCode(-5)
)

type ChangeTrustResult struct {
	Code ChangeTrustResultCode
	_u interface{}
}

type AllowTrustResultCode int32
const (
	ALLOW_TRUST_SUCCESS = AllowTrustResultCode(0)
	ALLOW_TRUST_MALFORMED = AllowTrustResultCode(-1)
	ALLOW_TRUST_NO_TRUST_LINE = AllowTrustResultCode(-2)
	ALLOW_TRUST_TRUST_NOT_REQUIRED = AllowTrustResultCode(-3)
	ALLOW_TRUST_CANT_REVOKE = AllowTrustResultCode(-4)
	ALLOW_TRUST_SELF_NOT_ALLOWED = AllowTrustResultCode(-5)
)

type AllowTrustResult struct {
	Code AllowTrustResultCode
	_u interface{}
}

type AccountMergeResultCode int32
const (
	ACCOUNT_MERGE_SUCCESS = AccountMergeResultCode(0)
	ACCOUNT_MERGE_MALFORMED = AccountMergeResultCode(-1)
	ACCOUNT_MERGE_NO_ACCOUNT = AccountMergeResultCode(-2)
	ACCOUNT_MERGE_IMMUTABLE_SET = AccountMergeResultCode(-3)
	ACCOUNT_MERGE_HAS_SUB_ENTRIES = AccountMergeResultCode(-4)
	ACCOUNT_MERGE_SEQNUM_TOO_FAR = AccountMergeResultCode(-5)
	ACCOUNT_MERGE_DEST_FULL = AccountMergeResultCode(-6)
)

type AccountMergeResult struct {
	Code AccountMergeResultCode
	// ACCOUNT_MERGE_SUCCESS:
	//    SourceAccountBalance() *Int64
	_u interface{}
}

type InflationResultCode int32
const (
	INFLATION_SUCCESS = InflationResultCode(0)
	INFLATION_NOT_TIME = InflationResultCode(-1)
)

type InflationPayout struct {
	Destination AccountID
	Amount Int64
}

type InflationResult struct {
	Code InflationResultCode
	// INFLATION_SUCCESS:
	//    Payouts() *[]InflationPayout
	_u interface{}
}

type ManageDataResultCode int32
const (
	MANAGE_DATA_SUCCESS = ManageDataResultCode(0)
	MANAGE_DATA_NOT_SUPPORTED_YET = ManageDataResultCode(-1)
	MANAGE_DATA_NAME_NOT_FOUND = ManageDataResultCode(-2)
	MANAGE_DATA_LOW_RESERVE = ManageDataResultCode(-3)
	MANAGE_DATA_INVALID_NAME = ManageDataResultCode(-4)
)

type ManageDataResult struct {
	Code ManageDataResultCode
	_u interface{}
}

type BumpSequenceResultCode int32
const (
	BUMP_SEQUENCE_SUCCESS = BumpSequenceResultCode(0)
	BUMP_SEQUENCE_BAD_SEQ = BumpSequenceResultCode(-1)
)

type BumpSequenceResult struct {
	Code BumpSequenceResultCode
	_u interface{}
}

type OperationResultCode int32
const (
	OpINNER = OperationResultCode(0)
	OpBAD_AUTH = OperationResultCode(-1)
	OpNO_ACCOUNT = OperationResultCode(-2)
	OpNOT_SUPPORTED = OperationResultCode(-3)
)

type _OperationResult_Tr struct {
	Type OperationType
	// CREATE_ACCOUNT:
	//    CreateAccountResult() *CreateAccountResult
	// PAYMENT:
	//    PaymentResult() *PaymentResult
	// PATH_PAYMENT:
	//    PathPaymentResult() *PathPaymentResult
	// MANAGE_OFFER:
	//    ManageOfferResult() *ManageOfferResult
	// CREATE_PASSIVE_OFFER:
	//    CreatePassiveOfferResult() *ManageOfferResult
	// SET_OPTIONS:
	//    SetOptionsResult() *SetOptionsResult
	// CHANGE_TRUST:
	//    ChangeTrustResult() *ChangeTrustResult
	// ALLOW_TRUST:
	//    AllowTrustResult() *AllowTrustResult
	// ACCOUNT_MERGE:
	//    AccountMergeResult() *AccountMergeResult
	// INFLATION:
	//    InflationResult() *InflationResult
	// MANAGE_DATA:
	//    ManageDataResult() *ManageDataResult
	// BUMP_SEQUENCE:
	//    BumpSeqResult() *BumpSequenceResult
	_u interface{}
}
type OperationResult struct {
	Code OperationResultCode
	// OpINNER:
	//    Tr() *_OperationResult_Tr
	_u interface{}
}

type TransactionResultCode int32
const (
	TxSUCCESS = TransactionResultCode(0)
	TxFAILED = TransactionResultCode(-1)
	TxTOO_EARLY = TransactionResultCode(-2)
	TxTOO_LATE = TransactionResultCode(-3)
	TxMISSING_OPERATION = TransactionResultCode(-4)
	TxBAD_SEQ = TransactionResultCode(-5)
	TxBAD_AUTH = TransactionResultCode(-6)
	TxINSUFFICIENT_BALANCE = TransactionResultCode(-7)
	TxNO_ACCOUNT = TransactionResultCode(-8)
	TxINSUFFICIENT_FEE = TransactionResultCode(-9)
	TxBAD_AUTH_EXTRA = TransactionResultCode(-10)
	TxINTERNAL_ERROR = TransactionResultCode(-11)
)

type _TransactionResult_Result struct {
	Code TransactionResultCode
	// TxSUCCESS, TxFAILED:
	//    Results() *[]OperationResult
	_u interface{}
}
type _TransactionResult_Ext struct {
	V int32
	_u interface{}
}
type TransactionResult struct {
	FeeCharged Int64
	Result _TransactionResult_Result
	Ext _TransactionResult_Ext
}

type Hash = [32]byte

type Uint256 = [32]byte

type Uint32 = uint32

type Int32 = int32

type Uint64 = uint64

type Int64 = int64

type CryptoKeyType int32
const (
	KEY_TYPE_ED25519 = CryptoKeyType(0)
	KEY_TYPE_PRE_AUTH_TX = CryptoKeyType(1)
	KEY_TYPE_HASH_X = CryptoKeyType(2)
)

type PublicKeyType int32
const (
	PUBLIC_KEY_TYPE_ED25519 = PublicKeyType(KEY_TYPE_ED25519)
)

type SignerKeyType int32
const (
	SIGNER_KEY_TYPE_ED25519 = SignerKeyType(KEY_TYPE_ED25519)
	SIGNER_KEY_TYPE_PRE_AUTH_TX = SignerKeyType(KEY_TYPE_PRE_AUTH_TX)
	SIGNER_KEY_TYPE_HASH_X = SignerKeyType(KEY_TYPE_HASH_X)
)

type PublicKey struct {
	Type PublicKeyType
	// PUBLIC_KEY_TYPE_ED25519:
	//    Ed25519() *Uint256
	_u interface{}
}

type SignerKey struct {
	Type SignerKeyType
	// SIGNER_KEY_TYPE_ED25519:
	//    Ed25519() *Uint256
	// SIGNER_KEY_TYPE_PRE_AUTH_TX:
	//    PreAuthTx() *Uint256
	// SIGNER_KEY_TYPE_HASH_X:
	//    HashX() *Uint256
	_u interface{}
}

type Signature = []byte // bound 64

type SignatureHint = [4]byte

type NodeID = PublicKey

type Curve25519Secret struct {
	Key [32]byte
}

type Curve25519Public struct {
	Key [32]byte
}

type HmacSha256Key struct {
	Key [32]byte
}

type HmacSha256Mac struct {
	Mac [32]byte
}

//
// Helper types and generated marshaling functions
//

func XDR_Value(x XDR, name string, v *Value) {
	if xs, ok := x.(interface{
		Marshal_Value(string, *Value)
	}); ok {
		xs.Marshal_Value(name, v)
	} else {
		x.Marshal(name, XdrVecOpaque{v, 0xffffffff})
	}
}
func (v *SCPBallot) XdrPointer() interface{} {
	return v
}
func (v *SCPBallot) XdrValue() interface{} {
	return *v
}
func (v *SCPBallot) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Uint32(x, x.Sprintf("%scounter", name), &v.Counter)
	XDR_Value(x, x.Sprintf("%svalue", name), &v.Value)
}
func XDR_SCPBallot(x XDR, name string, v *SCPBallot) {
	x.Marshal(name, v)
}
func XDR_SCPStatementType(x XDR, name string, v *SCPStatementType) {
	x.Marshal(name, v)
}
var _XdrNames_SCPStatementType = map[int32]string{
	int32(SCP_ST_PREPARE): "SCP_ST_PREPARE",
	int32(SCP_ST_CONFIRM): "SCP_ST_CONFIRM",
	int32(SCP_ST_EXTERNALIZE): "SCP_ST_EXTERNALIZE",
	int32(SCP_ST_NOMINATE): "SCP_ST_NOMINATE",
}
var _XdrValues_SCPStatementType = map[string]int32{
	"SCP_ST_PREPARE": int32(SCP_ST_PREPARE),
	"SCP_ST_CONFIRM": int32(SCP_ST_CONFIRM),
	"SCP_ST_EXTERNALIZE": int32(SCP_ST_EXTERNALIZE),
	"SCP_ST_NOMINATE": int32(SCP_ST_NOMINATE),
}
func (*SCPStatementType) XdrEnumNames() map[int32]string {
	return _XdrNames_SCPStatementType
}
func (v *SCPStatementType) String() string {
	if s, ok := _XdrNames_SCPStatementType[int32(*v)]; ok {
		return s
	}
	return fmt.Sprintf("SCPStatementType#%d", *v)
}
func (v *SCPStatementType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, xdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_SCPStatementType[stok]; ok {
			*v = SCPStatementType(val)
			return nil
		}
		return XdrError(fmt.Sprintf("%s is not a valid SCPStatementType.", stok))
	}
}
func (v *SCPStatementType) GetU32() uint32 {
	return uint32(*v)
}
func (v *SCPStatementType) SetU32(n uint32) {
	*v = SCPStatementType(n)
}
func (v *SCPStatementType) XdrPointer() interface{} {
	return v
}
func (v *SCPStatementType) XdrValue() interface{} {
	return *v
}
type XdrVec_unbounded_Value []Value
func (v *XdrVec_unbounded_Value) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (*XdrVec_unbounded_Value) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		xdrPanic("XdrVec_unbounded_Value length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		xdrPanic("XdrVec_unbounded_Value length %d exceeds max int", length)
	}
}
func (v *XdrVec_unbounded_Value) GetVecLen() uint32 { return uint32(len(*v)) }
func (v *XdrVec_unbounded_Value) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2*cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]Value, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *XdrVec_unbounded_Value) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if (i >= len(*v)) {
			v.SetVecLen(uint32(i+1))
		}
		XDR_Value(x, x.Sprintf("%s[%d]", name, i), &(*v)[i])
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *XdrVec_unbounded_Value) XdrMarshal(x XDR, name string) {
	size := XdrSize{ size: uint32(len(*v)), bound: 4294967295 }
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.size)
}
func (v *XdrVec_unbounded_Value) XdrPointer() interface{} { return (*[]Value)(v) }
func (v *XdrVec_unbounded_Value) XdrValue() interface{} { return ([]Value)(*v) }
func (v *SCPNomination) XdrPointer() interface{} {
	return v
}
func (v *SCPNomination) XdrValue() interface{} {
	return *v
}
func (v *SCPNomination) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Hash(x, x.Sprintf("%squorumSetHash", name), &v.QuorumSetHash)
	x.Marshal(x.Sprintf("%svotes", name), (*XdrVec_unbounded_Value)(&v.Votes))
	x.Marshal(x.Sprintf("%saccepted", name), (*XdrVec_unbounded_Value)(&v.Accepted))
}
func XDR_SCPNomination(x XDR, name string, v *SCPNomination) {
	x.Marshal(name, v)
}
type XdrPtr_SCPBallot struct {
	p **SCPBallot
}
type _ptrflag_SCPBallot XdrPtr_SCPBallot
func (v _ptrflag_SCPBallot) String() string {
	if *v.p == nil {
		return "nil"
	}
	return "non-nil"
}
func (v _ptrflag_SCPBallot) GetU32() uint32 {
	if *v.p == nil {
		return 0
	}
	return 1
}
func (v _ptrflag_SCPBallot) SetU32(nv uint32) {
	switch nv {
	case 0:
		*v.p = nil
	case 1:
		if *v.p == nil {
			*v.p = new(SCPBallot)
		}
	default:
		xdrPanic("*SCPBallot present flag value %d should be 0 or 1", nv)
	}
}
func (v _ptrflag_SCPBallot) XdrPointer() interface{} { return nil }
func (v _ptrflag_SCPBallot) XdrValue() interface{} { return v.GetU32() != 0 }
func (v _ptrflag_SCPBallot) XdrBound() uint32 { return 1 }
func (v XdrPtr_SCPBallot) GetPresent() bool { return *v.p != nil }
func (v XdrPtr_SCPBallot) SetPresent(present bool) {
	if !present {
		*v.p = nil
	} else if *v.p == nil {
		*v.p = new(SCPBallot)
	}
}
func (v XdrPtr_SCPBallot) XdrMarshalValue(x XDR, name string) {
	if *v.p != nil {
		XDR_SCPBallot(x, name, *v.p)
	}
}
func (v XdrPtr_SCPBallot) XdrMarshal(x XDR, name string) {
	x.Marshal(name, _ptrflag_SCPBallot(v))
	v.XdrMarshalValue(x, name)
}
func (v XdrPtr_SCPBallot) XdrPointer() interface{} { return v.p }
func (v XdrPtr_SCPBallot) XdrValue() interface{} { return *v.p }
func (v *_SCPStatement_Pledges_Prepare) XdrPointer() interface{} {
	return v
}
func (v *_SCPStatement_Pledges_Prepare) XdrValue() interface{} {
	return *v
}
func (v *_SCPStatement_Pledges_Prepare) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Hash(x, x.Sprintf("%squorumSetHash", name), &v.QuorumSetHash)
	XDR_SCPBallot(x, x.Sprintf("%sballot", name), &v.Ballot)
	x.Marshal(x.Sprintf("%sprepared", name), XdrPtr_SCPBallot{&v.Prepared})
	x.Marshal(x.Sprintf("%spreparedPrime", name), XdrPtr_SCPBallot{&v.PreparedPrime})
	XDR_Uint32(x, x.Sprintf("%snC", name), &v.NC)
	XDR_Uint32(x, x.Sprintf("%snH", name), &v.NH)
}
func XDR__SCPStatement_Pledges_Prepare(x XDR, name string, v *_SCPStatement_Pledges_Prepare) {
	x.Marshal(name, v)
}
func (v *_SCPStatement_Pledges_Confirm) XdrPointer() interface{} {
	return v
}
func (v *_SCPStatement_Pledges_Confirm) XdrValue() interface{} {
	return *v
}
func (v *_SCPStatement_Pledges_Confirm) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_SCPBallot(x, x.Sprintf("%sballot", name), &v.Ballot)
	XDR_Uint32(x, x.Sprintf("%snPrepared", name), &v.NPrepared)
	XDR_Uint32(x, x.Sprintf("%snCommit", name), &v.NCommit)
	XDR_Uint32(x, x.Sprintf("%snH", name), &v.NH)
	XDR_Hash(x, x.Sprintf("%squorumSetHash", name), &v.QuorumSetHash)
}
func XDR__SCPStatement_Pledges_Confirm(x XDR, name string, v *_SCPStatement_Pledges_Confirm) {
	x.Marshal(name, v)
}
func (v *_SCPStatement_Pledges_Externalize) XdrPointer() interface{} {
	return v
}
func (v *_SCPStatement_Pledges_Externalize) XdrValue() interface{} {
	return *v
}
func (v *_SCPStatement_Pledges_Externalize) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_SCPBallot(x, x.Sprintf("%scommit", name), &v.Commit)
	XDR_Uint32(x, x.Sprintf("%snH", name), &v.NH)
	XDR_Hash(x, x.Sprintf("%scommitQuorumSetHash", name), &v.CommitQuorumSetHash)
}
func XDR__SCPStatement_Pledges_Externalize(x XDR, name string, v *_SCPStatement_Pledges_Externalize) {
	x.Marshal(name, v)
}
func (u *_SCPStatement_Pledges) Prepare() *_SCPStatement_Pledges_Prepare {
	switch u.Type {
	case SCP_ST_PREPARE:
		if v, ok := u._u.(*_SCPStatement_Pledges_Prepare); ok {
			return v
		} else {
			var zero _SCPStatement_Pledges_Prepare
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("_SCPStatement_Pledges.Prepare accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *_SCPStatement_Pledges) Confirm() *_SCPStatement_Pledges_Confirm {
	switch u.Type {
	case SCP_ST_CONFIRM:
		if v, ok := u._u.(*_SCPStatement_Pledges_Confirm); ok {
			return v
		} else {
			var zero _SCPStatement_Pledges_Confirm
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("_SCPStatement_Pledges.Confirm accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *_SCPStatement_Pledges) Externalize() *_SCPStatement_Pledges_Externalize {
	switch u.Type {
	case SCP_ST_EXTERNALIZE:
		if v, ok := u._u.(*_SCPStatement_Pledges_Externalize); ok {
			return v
		} else {
			var zero _SCPStatement_Pledges_Externalize
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("_SCPStatement_Pledges.Externalize accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *_SCPStatement_Pledges) Nominate() *SCPNomination {
	switch u.Type {
	case SCP_ST_NOMINATE:
		if v, ok := u._u.(*SCPNomination); ok {
			return v
		} else {
			var zero SCPNomination
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("_SCPStatement_Pledges.Nominate accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *_SCPStatement_Pledges) XdrValid() bool {
	switch u.Type {
	case SCP_ST_PREPARE,SCP_ST_CONFIRM,SCP_ST_EXTERNALIZE,SCP_ST_NOMINATE:
		return true
	}
	return false
}
func (u *_SCPStatement_Pledges) XdrUnionTag() interface{} {
	return &u.Type
}
func (u *_SCPStatement_Pledges) XdrUnionTagName() string {
	return "Type"
}
func (u *_SCPStatement_Pledges) XdrUnionBody() interface{} {
	switch u.Type {
	case SCP_ST_PREPARE:
		return u.Prepare()
	case SCP_ST_CONFIRM:
		return u.Confirm()
	case SCP_ST_EXTERNALIZE:
		return u.Externalize()
	case SCP_ST_NOMINATE:
		return u.Nominate()
	}
	return nil
}
func (u *_SCPStatement_Pledges) XdrUnionBodyName() string {
	switch u.Type {
	case SCP_ST_PREPARE:
		return "Prepare"
	case SCP_ST_CONFIRM:
		return "Confirm"
	case SCP_ST_EXTERNALIZE:
		return "Externalize"
	case SCP_ST_NOMINATE:
		return "Nominate"
	}
	return ""
}
func (v *_SCPStatement_Pledges) XdrPointer() interface{} {
	return v
}
func (v *_SCPStatement_Pledges) XdrValue() interface{} {
	return *v
}
func (v *_SCPStatement_Pledges) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_SCPStatementType(x, x.Sprintf("%stype", name), &v.Type)
	switch v.Type {
	case SCP_ST_PREPARE:
	XDR__SCPStatement_Pledges_Prepare(x, x.Sprintf("%sprepare", name), v.Prepare())
		return
	case SCP_ST_CONFIRM:
	XDR__SCPStatement_Pledges_Confirm(x, x.Sprintf("%sconfirm", name), v.Confirm())
		return
	case SCP_ST_EXTERNALIZE:
	XDR__SCPStatement_Pledges_Externalize(x, x.Sprintf("%sexternalize", name), v.Externalize())
		return
	case SCP_ST_NOMINATE:
	XDR_SCPNomination(x, x.Sprintf("%snominate", name), v.Nominate())
		return
	}
	xdrPanic(fmt.Sprintf("invalid Type (%v) in _SCPStatement_Pledges", v.Type))
}
func XDR__SCPStatement_Pledges(x XDR, name string, v *_SCPStatement_Pledges) {
	x.Marshal(name, v)
}
func (v *SCPStatement) XdrPointer() interface{} {
	return v
}
func (v *SCPStatement) XdrValue() interface{} {
	return *v
}
func (v *SCPStatement) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_NodeID(x, x.Sprintf("%snodeID", name), &v.NodeID)
	XDR_Uint64(x, x.Sprintf("%sslotIndex", name), &v.SlotIndex)
	XDR__SCPStatement_Pledges(x, x.Sprintf("%spledges", name), &v.Pledges)
}
func XDR_SCPStatement(x XDR, name string, v *SCPStatement) {
	x.Marshal(name, v)
}
func (v *SCPEnvelope) XdrPointer() interface{} {
	return v
}
func (v *SCPEnvelope) XdrValue() interface{} {
	return *v
}
func (v *SCPEnvelope) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_SCPStatement(x, x.Sprintf("%sstatement", name), &v.Statement)
	XDR_Signature(x, x.Sprintf("%ssignature", name), &v.Signature)
}
func XDR_SCPEnvelope(x XDR, name string, v *SCPEnvelope) {
	x.Marshal(name, v)
}
type XdrVec_unbounded_PublicKey []PublicKey
func (v *XdrVec_unbounded_PublicKey) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (*XdrVec_unbounded_PublicKey) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		xdrPanic("XdrVec_unbounded_PublicKey length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		xdrPanic("XdrVec_unbounded_PublicKey length %d exceeds max int", length)
	}
}
func (v *XdrVec_unbounded_PublicKey) GetVecLen() uint32 { return uint32(len(*v)) }
func (v *XdrVec_unbounded_PublicKey) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2*cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]PublicKey, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *XdrVec_unbounded_PublicKey) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if (i >= len(*v)) {
			v.SetVecLen(uint32(i+1))
		}
		XDR_PublicKey(x, x.Sprintf("%s[%d]", name, i), &(*v)[i])
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *XdrVec_unbounded_PublicKey) XdrMarshal(x XDR, name string) {
	size := XdrSize{ size: uint32(len(*v)), bound: 4294967295 }
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.size)
}
func (v *XdrVec_unbounded_PublicKey) XdrPointer() interface{} { return (*[]PublicKey)(v) }
func (v *XdrVec_unbounded_PublicKey) XdrValue() interface{} { return ([]PublicKey)(*v) }
type XdrVec_unbounded_SCPQuorumSet []SCPQuorumSet
func (v *XdrVec_unbounded_SCPQuorumSet) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (*XdrVec_unbounded_SCPQuorumSet) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		xdrPanic("XdrVec_unbounded_SCPQuorumSet length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		xdrPanic("XdrVec_unbounded_SCPQuorumSet length %d exceeds max int", length)
	}
}
func (v *XdrVec_unbounded_SCPQuorumSet) GetVecLen() uint32 { return uint32(len(*v)) }
func (v *XdrVec_unbounded_SCPQuorumSet) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2*cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]SCPQuorumSet, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *XdrVec_unbounded_SCPQuorumSet) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if (i >= len(*v)) {
			v.SetVecLen(uint32(i+1))
		}
		XDR_SCPQuorumSet(x, x.Sprintf("%s[%d]", name, i), &(*v)[i])
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *XdrVec_unbounded_SCPQuorumSet) XdrMarshal(x XDR, name string) {
	size := XdrSize{ size: uint32(len(*v)), bound: 4294967295 }
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.size)
}
func (v *XdrVec_unbounded_SCPQuorumSet) XdrPointer() interface{} { return (*[]SCPQuorumSet)(v) }
func (v *XdrVec_unbounded_SCPQuorumSet) XdrValue() interface{} { return ([]SCPQuorumSet)(*v) }
func (v *SCPQuorumSet) XdrPointer() interface{} {
	return v
}
func (v *SCPQuorumSet) XdrValue() interface{} {
	return *v
}
func (v *SCPQuorumSet) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Uint32(x, x.Sprintf("%sthreshold", name), &v.Threshold)
	x.Marshal(x.Sprintf("%svalidators", name), (*XdrVec_unbounded_PublicKey)(&v.Validators))
	x.Marshal(x.Sprintf("%sinnerSets", name), (*XdrVec_unbounded_SCPQuorumSet)(&v.InnerSets))
}
func XDR_SCPQuorumSet(x XDR, name string, v *SCPQuorumSet) {
	x.Marshal(name, v)
}
func XDR_AccountID(x XDR, name string, v *AccountID) {
	if xs, ok := x.(interface{
		Marshal_AccountID(string, *AccountID)
	}); ok {
		xs.Marshal_AccountID(name, v)
	} else {
		XDR_PublicKey(x, name, v)
	}
}
func XDR_Thresholds(x XDR, name string, v *Thresholds) {
	if xs, ok := x.(interface{
		Marshal_Thresholds(string, *Thresholds)
	}); ok {
		xs.Marshal_Thresholds(name, v)
	} else {
		x.Marshal(name, XdrArrayOpaque((*v)[:]))
	}
}
func XDR_String32(x XDR, name string, v *String32) {
	if xs, ok := x.(interface{
		Marshal_String32(string, *String32)
	}); ok {
		xs.Marshal_String32(name, v)
	} else {
		x.Marshal(name, XdrString{v, 32})
	}
}
func XDR_String64(x XDR, name string, v *String64) {
	if xs, ok := x.(interface{
		Marshal_String64(string, *String64)
	}); ok {
		xs.Marshal_String64(name, v)
	} else {
		x.Marshal(name, XdrString{v, 64})
	}
}
func XDR_SequenceNumber(x XDR, name string, v *SequenceNumber) {
	if xs, ok := x.(interface{
		Marshal_SequenceNumber(string, *SequenceNumber)
	}); ok {
		xs.Marshal_SequenceNumber(name, v)
	} else {
		XDR_Int64(x, name, v)
	}
}
func XDR_DataValue(x XDR, name string, v *DataValue) {
	if xs, ok := x.(interface{
		Marshal_DataValue(string, *DataValue)
	}); ok {
		xs.Marshal_DataValue(name, v)
	} else {
		x.Marshal(name, XdrVecOpaque{v, 64})
	}
}
func XDR_AssetType(x XDR, name string, v *AssetType) {
	x.Marshal(name, v)
}
var _XdrNames_AssetType = map[int32]string{
	int32(ASSET_TYPE_NATIVE): "ASSET_TYPE_NATIVE",
	int32(ASSET_TYPE_CREDIT_ALPHANUM4): "ASSET_TYPE_CREDIT_ALPHANUM4",
	int32(ASSET_TYPE_CREDIT_ALPHANUM12): "ASSET_TYPE_CREDIT_ALPHANUM12",
}
var _XdrValues_AssetType = map[string]int32{
	"ASSET_TYPE_NATIVE": int32(ASSET_TYPE_NATIVE),
	"ASSET_TYPE_CREDIT_ALPHANUM4": int32(ASSET_TYPE_CREDIT_ALPHANUM4),
	"ASSET_TYPE_CREDIT_ALPHANUM12": int32(ASSET_TYPE_CREDIT_ALPHANUM12),
}
func (*AssetType) XdrEnumNames() map[int32]string {
	return _XdrNames_AssetType
}
func (v *AssetType) String() string {
	if s, ok := _XdrNames_AssetType[int32(*v)]; ok {
		return s
	}
	return fmt.Sprintf("AssetType#%d", *v)
}
func (v *AssetType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, xdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_AssetType[stok]; ok {
			*v = AssetType(val)
			return nil
		}
		return XdrError(fmt.Sprintf("%s is not a valid AssetType.", stok))
	}
}
func (v *AssetType) GetU32() uint32 {
	return uint32(*v)
}
func (v *AssetType) SetU32(n uint32) {
	*v = AssetType(n)
}
func (v *AssetType) XdrPointer() interface{} {
	return v
}
func (v *AssetType) XdrValue() interface{} {
	return *v
}
func (v *_Asset_AlphaNum4) XdrPointer() interface{} {
	return v
}
func (v *_Asset_AlphaNum4) XdrValue() interface{} {
	return *v
}
func (v *_Asset_AlphaNum4) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sassetCode", name), XdrArrayOpaque((v.AssetCode)[:]))
	XDR_AccountID(x, x.Sprintf("%sissuer", name), &v.Issuer)
}
func XDR__Asset_AlphaNum4(x XDR, name string, v *_Asset_AlphaNum4) {
	x.Marshal(name, v)
}
func (v *_Asset_AlphaNum12) XdrPointer() interface{} {
	return v
}
func (v *_Asset_AlphaNum12) XdrValue() interface{} {
	return *v
}
func (v *_Asset_AlphaNum12) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sassetCode", name), XdrArrayOpaque((v.AssetCode)[:]))
	XDR_AccountID(x, x.Sprintf("%sissuer", name), &v.Issuer)
}
func XDR__Asset_AlphaNum12(x XDR, name string, v *_Asset_AlphaNum12) {
	x.Marshal(name, v)
}
func (u *Asset) AlphaNum4() *_Asset_AlphaNum4 {
	switch u.Type {
	case ASSET_TYPE_CREDIT_ALPHANUM4:
		if v, ok := u._u.(*_Asset_AlphaNum4); ok {
			return v
		} else {
			var zero _Asset_AlphaNum4
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("Asset.AlphaNum4 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *Asset) AlphaNum12() *_Asset_AlphaNum12 {
	switch u.Type {
	case ASSET_TYPE_CREDIT_ALPHANUM12:
		if v, ok := u._u.(*_Asset_AlphaNum12); ok {
			return v
		} else {
			var zero _Asset_AlphaNum12
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("Asset.AlphaNum12 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *Asset) XdrValid() bool {
	switch u.Type {
	case ASSET_TYPE_NATIVE,ASSET_TYPE_CREDIT_ALPHANUM4,ASSET_TYPE_CREDIT_ALPHANUM12:
		return true
	}
	return false
}
func (u *Asset) XdrUnionTag() interface{} {
	return &u.Type
}
func (u *Asset) XdrUnionTagName() string {
	return "Type"
}
func (u *Asset) XdrUnionBody() interface{} {
	switch u.Type {
	case ASSET_TYPE_NATIVE:
		return nil
	case ASSET_TYPE_CREDIT_ALPHANUM4:
		return u.AlphaNum4()
	case ASSET_TYPE_CREDIT_ALPHANUM12:
		return u.AlphaNum12()
	}
	return nil
}
func (u *Asset) XdrUnionBodyName() string {
	switch u.Type {
	case ASSET_TYPE_NATIVE:
		return ""
	case ASSET_TYPE_CREDIT_ALPHANUM4:
		return "AlphaNum4"
	case ASSET_TYPE_CREDIT_ALPHANUM12:
		return "AlphaNum12"
	}
	return ""
}
func (v *Asset) XdrPointer() interface{} {
	return v
}
func (v *Asset) XdrValue() interface{} {
	return *v
}
func (v *Asset) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_AssetType(x, x.Sprintf("%stype", name), &v.Type)
	switch v.Type {
	case ASSET_TYPE_NATIVE:
		return
	case ASSET_TYPE_CREDIT_ALPHANUM4:
	XDR__Asset_AlphaNum4(x, x.Sprintf("%salphaNum4", name), v.AlphaNum4())
		return
	case ASSET_TYPE_CREDIT_ALPHANUM12:
	XDR__Asset_AlphaNum12(x, x.Sprintf("%salphaNum12", name), v.AlphaNum12())
		return
	}
	xdrPanic(fmt.Sprintf("invalid Type (%v) in Asset", v.Type))
}
func XDR_Asset(x XDR, name string, v *Asset) {
	x.Marshal(name, v)
}
func (v *Price) XdrPointer() interface{} {
	return v
}
func (v *Price) XdrValue() interface{} {
	return *v
}
func (v *Price) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Int32(x, x.Sprintf("%sn", name), &v.N)
	XDR_Int32(x, x.Sprintf("%sd", name), &v.D)
}
func XDR_Price(x XDR, name string, v *Price) {
	x.Marshal(name, v)
}
func (v *Liabilities) XdrPointer() interface{} {
	return v
}
func (v *Liabilities) XdrValue() interface{} {
	return *v
}
func (v *Liabilities) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Int64(x, x.Sprintf("%sbuying", name), &v.Buying)
	XDR_Int64(x, x.Sprintf("%sselling", name), &v.Selling)
}
func XDR_Liabilities(x XDR, name string, v *Liabilities) {
	x.Marshal(name, v)
}
func XDR_ThresholdIndexes(x XDR, name string, v *ThresholdIndexes) {
	x.Marshal(name, v)
}
var _XdrNames_ThresholdIndexes = map[int32]string{
	int32(THRESHOLD_MASTER_WEIGHT): "THRESHOLD_MASTER_WEIGHT",
	int32(THRESHOLD_LOW): "THRESHOLD_LOW",
	int32(THRESHOLD_MED): "THRESHOLD_MED",
	int32(THRESHOLD_HIGH): "THRESHOLD_HIGH",
}
var _XdrValues_ThresholdIndexes = map[string]int32{
	"THRESHOLD_MASTER_WEIGHT": int32(THRESHOLD_MASTER_WEIGHT),
	"THRESHOLD_LOW": int32(THRESHOLD_LOW),
	"THRESHOLD_MED": int32(THRESHOLD_MED),
	"THRESHOLD_HIGH": int32(THRESHOLD_HIGH),
}
func (*ThresholdIndexes) XdrEnumNames() map[int32]string {
	return _XdrNames_ThresholdIndexes
}
func (v *ThresholdIndexes) String() string {
	if s, ok := _XdrNames_ThresholdIndexes[int32(*v)]; ok {
		return s
	}
	return fmt.Sprintf("ThresholdIndexes#%d", *v)
}
func (v *ThresholdIndexes) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, xdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_ThresholdIndexes[stok]; ok {
			*v = ThresholdIndexes(val)
			return nil
		}
		return XdrError(fmt.Sprintf("%s is not a valid ThresholdIndexes.", stok))
	}
}
func (v *ThresholdIndexes) GetU32() uint32 {
	return uint32(*v)
}
func (v *ThresholdIndexes) SetU32(n uint32) {
	*v = ThresholdIndexes(n)
}
func (v *ThresholdIndexes) XdrPointer() interface{} {
	return v
}
func (v *ThresholdIndexes) XdrValue() interface{} {
	return *v
}
func XDR_LedgerEntryType(x XDR, name string, v *LedgerEntryType) {
	x.Marshal(name, v)
}
var _XdrNames_LedgerEntryType = map[int32]string{
	int32(ACCOUNT): "ACCOUNT",
	int32(TRUSTLINE): "TRUSTLINE",
	int32(OFFER): "OFFER",
	int32(DATA): "DATA",
}
var _XdrValues_LedgerEntryType = map[string]int32{
	"ACCOUNT": int32(ACCOUNT),
	"TRUSTLINE": int32(TRUSTLINE),
	"OFFER": int32(OFFER),
	"DATA": int32(DATA),
}
func (*LedgerEntryType) XdrEnumNames() map[int32]string {
	return _XdrNames_LedgerEntryType
}
func (v *LedgerEntryType) String() string {
	if s, ok := _XdrNames_LedgerEntryType[int32(*v)]; ok {
		return s
	}
	return fmt.Sprintf("LedgerEntryType#%d", *v)
}
func (v *LedgerEntryType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, xdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_LedgerEntryType[stok]; ok {
			*v = LedgerEntryType(val)
			return nil
		}
		return XdrError(fmt.Sprintf("%s is not a valid LedgerEntryType.", stok))
	}
}
func (v *LedgerEntryType) GetU32() uint32 {
	return uint32(*v)
}
func (v *LedgerEntryType) SetU32(n uint32) {
	*v = LedgerEntryType(n)
}
func (v *LedgerEntryType) XdrPointer() interface{} {
	return v
}
func (v *LedgerEntryType) XdrValue() interface{} {
	return *v
}
func (v *Signer) XdrPointer() interface{} {
	return v
}
func (v *Signer) XdrValue() interface{} {
	return *v
}
func (v *Signer) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_SignerKey(x, x.Sprintf("%skey", name), &v.Key)
	XDR_Uint32(x, x.Sprintf("%sweight", name), &v.Weight)
}
func XDR_Signer(x XDR, name string, v *Signer) {
	x.Marshal(name, v)
}
func XDR_AccountFlags(x XDR, name string, v *AccountFlags) {
	x.Marshal(name, v)
}
var _XdrNames_AccountFlags = map[int32]string{
	int32(AUTH_REQUIRED_FLAG): "AUTH_REQUIRED_FLAG",
	int32(AUTH_REVOCABLE_FLAG): "AUTH_REVOCABLE_FLAG",
	int32(AUTH_IMMUTABLE_FLAG): "AUTH_IMMUTABLE_FLAG",
}
var _XdrValues_AccountFlags = map[string]int32{
	"AUTH_REQUIRED_FLAG": int32(AUTH_REQUIRED_FLAG),
	"AUTH_REVOCABLE_FLAG": int32(AUTH_REVOCABLE_FLAG),
	"AUTH_IMMUTABLE_FLAG": int32(AUTH_IMMUTABLE_FLAG),
}
func (*AccountFlags) XdrEnumNames() map[int32]string {
	return _XdrNames_AccountFlags
}
func (v *AccountFlags) String() string {
	if s, ok := _XdrNames_AccountFlags[int32(*v)]; ok {
		return s
	}
	return fmt.Sprintf("AccountFlags#%d", *v)
}
func (v *AccountFlags) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, xdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_AccountFlags[stok]; ok {
			*v = AccountFlags(val)
			return nil
		}
		return XdrError(fmt.Sprintf("%s is not a valid AccountFlags.", stok))
	}
}
func (v *AccountFlags) GetU32() uint32 {
	return uint32(*v)
}
func (v *AccountFlags) SetU32(n uint32) {
	*v = AccountFlags(n)
}
func (v *AccountFlags) XdrPointer() interface{} {
	return v
}
func (v *AccountFlags) XdrValue() interface{} {
	return *v
}
func (u *_AccountEntry_Ext_V1_Ext) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *_AccountEntry_Ext_V1_Ext) XdrUnionTag() interface{} {
	return &u.V
}
func (u *_AccountEntry_Ext_V1_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *_AccountEntry_Ext_V1_Ext) XdrUnionBody() interface{} {
	switch u.V {
	case 0:
		return nil
	}
	return nil
}
func (u *_AccountEntry_Ext_V1_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	}
	return ""
}
func (v *_AccountEntry_Ext_V1_Ext) XdrPointer() interface{} {
	return v
}
func (v *_AccountEntry_Ext_V1_Ext) XdrValue() interface{} {
	return *v
}
func (v *_AccountEntry_Ext_V1_Ext) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(x, x.Sprintf("%sv", name), &v.V)
	switch v.V {
	case 0:
		return
	}
	xdrPanic(fmt.Sprintf("invalid V (%v) in _AccountEntry_Ext_V1_Ext", v.V))
}
func XDR__AccountEntry_Ext_V1_Ext(x XDR, name string, v *_AccountEntry_Ext_V1_Ext) {
	x.Marshal(name, v)
}
func (v *_AccountEntry_Ext_V1) XdrPointer() interface{} {
	return v
}
func (v *_AccountEntry_Ext_V1) XdrValue() interface{} {
	return *v
}
func (v *_AccountEntry_Ext_V1) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Liabilities(x, x.Sprintf("%sliabilities", name), &v.Liabilities)
	XDR__AccountEntry_Ext_V1_Ext(x, x.Sprintf("%sext", name), &v.Ext)
}
func XDR__AccountEntry_Ext_V1(x XDR, name string, v *_AccountEntry_Ext_V1) {
	x.Marshal(name, v)
}
func (u *_AccountEntry_Ext) V1() *_AccountEntry_Ext_V1 {
	switch u.V {
	case 1:
		if v, ok := u._u.(*_AccountEntry_Ext_V1); ok {
			return v
		} else {
			var zero _AccountEntry_Ext_V1
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("_AccountEntry_Ext.V1 accessed when V == %v", u.V)
		return nil
	}
}
func (u *_AccountEntry_Ext) XdrValid() bool {
	switch u.V {
	case 0,1:
		return true
	}
	return false
}
func (u *_AccountEntry_Ext) XdrUnionTag() interface{} {
	return &u.V
}
func (u *_AccountEntry_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *_AccountEntry_Ext) XdrUnionBody() interface{} {
	switch u.V {
	case 0:
		return nil
	case 1:
		return u.V1()
	}
	return nil
}
func (u *_AccountEntry_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	case 1:
		return "V1"
	}
	return ""
}
func (v *_AccountEntry_Ext) XdrPointer() interface{} {
	return v
}
func (v *_AccountEntry_Ext) XdrValue() interface{} {
	return *v
}
func (v *_AccountEntry_Ext) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(x, x.Sprintf("%sv", name), &v.V)
	switch v.V {
	case 0:
		return
	case 1:
	XDR__AccountEntry_Ext_V1(x, x.Sprintf("%sv1", name), v.V1())
		return
	}
	xdrPanic(fmt.Sprintf("invalid V (%v) in _AccountEntry_Ext", v.V))
}
func XDR__AccountEntry_Ext(x XDR, name string, v *_AccountEntry_Ext) {
	x.Marshal(name, v)
}
type XdrPtr_AccountID struct {
	p **AccountID
}
type _ptrflag_AccountID XdrPtr_AccountID
func (v _ptrflag_AccountID) String() string {
	if *v.p == nil {
		return "nil"
	}
	return "non-nil"
}
func (v _ptrflag_AccountID) GetU32() uint32 {
	if *v.p == nil {
		return 0
	}
	return 1
}
func (v _ptrflag_AccountID) SetU32(nv uint32) {
	switch nv {
	case 0:
		*v.p = nil
	case 1:
		if *v.p == nil {
			*v.p = new(AccountID)
		}
	default:
		xdrPanic("*AccountID present flag value %d should be 0 or 1", nv)
	}
}
func (v _ptrflag_AccountID) XdrPointer() interface{} { return nil }
func (v _ptrflag_AccountID) XdrValue() interface{} { return v.GetU32() != 0 }
func (v _ptrflag_AccountID) XdrBound() uint32 { return 1 }
func (v XdrPtr_AccountID) GetPresent() bool { return *v.p != nil }
func (v XdrPtr_AccountID) SetPresent(present bool) {
	if !present {
		*v.p = nil
	} else if *v.p == nil {
		*v.p = new(AccountID)
	}
}
func (v XdrPtr_AccountID) XdrMarshalValue(x XDR, name string) {
	if *v.p != nil {
		XDR_AccountID(x, name, *v.p)
	}
}
func (v XdrPtr_AccountID) XdrMarshal(x XDR, name string) {
	x.Marshal(name, _ptrflag_AccountID(v))
	v.XdrMarshalValue(x, name)
}
func (v XdrPtr_AccountID) XdrPointer() interface{} { return v.p }
func (v XdrPtr_AccountID) XdrValue() interface{} { return *v.p }
type XdrVec_20_Signer []Signer
func (v *XdrVec_20_Signer) XdrBound() uint32 {
	const bound uint32 = 20 // Force error if not const or doesn't fit
	return bound
}
func (*XdrVec_20_Signer) XdrCheckLen(length uint32) {
	if length > uint32(20) {
		xdrPanic("XdrVec_20_Signer length %d exceeds bound 20", length)
	} else if int(length) < 0 {
		xdrPanic("XdrVec_20_Signer length %d exceeds max int", length)
	}
}
func (v *XdrVec_20_Signer) GetVecLen() uint32 { return uint32(len(*v)) }
func (v *XdrVec_20_Signer) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2*cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(20); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]Signer, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *XdrVec_20_Signer) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if (i >= len(*v)) {
			v.SetVecLen(uint32(i+1))
		}
		XDR_Signer(x, x.Sprintf("%s[%d]", name, i), &(*v)[i])
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *XdrVec_20_Signer) XdrMarshal(x XDR, name string) {
	size := XdrSize{ size: uint32(len(*v)), bound: 20 }
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.size)
}
func (v *XdrVec_20_Signer) XdrPointer() interface{} { return (*[]Signer)(v) }
func (v *XdrVec_20_Signer) XdrValue() interface{} { return ([]Signer)(*v) }
func (v *AccountEntry) XdrPointer() interface{} {
	return v
}
func (v *AccountEntry) XdrValue() interface{} {
	return *v
}
func (v *AccountEntry) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_AccountID(x, x.Sprintf("%saccountID", name), &v.AccountID)
	XDR_Int64(x, x.Sprintf("%sbalance", name), &v.Balance)
	XDR_SequenceNumber(x, x.Sprintf("%sseqNum", name), &v.SeqNum)
	XDR_Uint32(x, x.Sprintf("%snumSubEntries", name), &v.NumSubEntries)
	x.Marshal(x.Sprintf("%sinflationDest", name), XdrPtr_AccountID{&v.InflationDest})
	XDR_Uint32(x, x.Sprintf("%sflags", name), &v.Flags)
	XDR_String32(x, x.Sprintf("%shomeDomain", name), &v.HomeDomain)
	XDR_Thresholds(x, x.Sprintf("%sthresholds", name), &v.Thresholds)
	x.Marshal(x.Sprintf("%ssigners", name), (*XdrVec_20_Signer)(&v.Signers))
	XDR__AccountEntry_Ext(x, x.Sprintf("%sext", name), &v.Ext)
}
func XDR_AccountEntry(x XDR, name string, v *AccountEntry) {
	x.Marshal(name, v)
}
func XDR_TrustLineFlags(x XDR, name string, v *TrustLineFlags) {
	x.Marshal(name, v)
}
var _XdrNames_TrustLineFlags = map[int32]string{
	int32(AUTHORIZED_FLAG): "AUTHORIZED_FLAG",
}
var _XdrValues_TrustLineFlags = map[string]int32{
	"AUTHORIZED_FLAG": int32(AUTHORIZED_FLAG),
}
func (*TrustLineFlags) XdrEnumNames() map[int32]string {
	return _XdrNames_TrustLineFlags
}
func (v *TrustLineFlags) String() string {
	if s, ok := _XdrNames_TrustLineFlags[int32(*v)]; ok {
		return s
	}
	return fmt.Sprintf("TrustLineFlags#%d", *v)
}
func (v *TrustLineFlags) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, xdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_TrustLineFlags[stok]; ok {
			*v = TrustLineFlags(val)
			return nil
		}
		return XdrError(fmt.Sprintf("%s is not a valid TrustLineFlags.", stok))
	}
}
func (v *TrustLineFlags) GetU32() uint32 {
	return uint32(*v)
}
func (v *TrustLineFlags) SetU32(n uint32) {
	*v = TrustLineFlags(n)
}
func (v *TrustLineFlags) XdrPointer() interface{} {
	return v
}
func (v *TrustLineFlags) XdrValue() interface{} {
	return *v
}
func (u *_TrustLineEntry_Ext_V1_Ext) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *_TrustLineEntry_Ext_V1_Ext) XdrUnionTag() interface{} {
	return &u.V
}
func (u *_TrustLineEntry_Ext_V1_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *_TrustLineEntry_Ext_V1_Ext) XdrUnionBody() interface{} {
	switch u.V {
	case 0:
		return nil
	}
	return nil
}
func (u *_TrustLineEntry_Ext_V1_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	}
	return ""
}
func (v *_TrustLineEntry_Ext_V1_Ext) XdrPointer() interface{} {
	return v
}
func (v *_TrustLineEntry_Ext_V1_Ext) XdrValue() interface{} {
	return *v
}
func (v *_TrustLineEntry_Ext_V1_Ext) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(x, x.Sprintf("%sv", name), &v.V)
	switch v.V {
	case 0:
		return
	}
	xdrPanic(fmt.Sprintf("invalid V (%v) in _TrustLineEntry_Ext_V1_Ext", v.V))
}
func XDR__TrustLineEntry_Ext_V1_Ext(x XDR, name string, v *_TrustLineEntry_Ext_V1_Ext) {
	x.Marshal(name, v)
}
func (v *_TrustLineEntry_Ext_V1) XdrPointer() interface{} {
	return v
}
func (v *_TrustLineEntry_Ext_V1) XdrValue() interface{} {
	return *v
}
func (v *_TrustLineEntry_Ext_V1) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Liabilities(x, x.Sprintf("%sliabilities", name), &v.Liabilities)
	XDR__TrustLineEntry_Ext_V1_Ext(x, x.Sprintf("%sext", name), &v.Ext)
}
func XDR__TrustLineEntry_Ext_V1(x XDR, name string, v *_TrustLineEntry_Ext_V1) {
	x.Marshal(name, v)
}
func (u *_TrustLineEntry_Ext) V1() *_TrustLineEntry_Ext_V1 {
	switch u.V {
	case 1:
		if v, ok := u._u.(*_TrustLineEntry_Ext_V1); ok {
			return v
		} else {
			var zero _TrustLineEntry_Ext_V1
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("_TrustLineEntry_Ext.V1 accessed when V == %v", u.V)
		return nil
	}
}
func (u *_TrustLineEntry_Ext) XdrValid() bool {
	switch u.V {
	case 0,1:
		return true
	}
	return false
}
func (u *_TrustLineEntry_Ext) XdrUnionTag() interface{} {
	return &u.V
}
func (u *_TrustLineEntry_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *_TrustLineEntry_Ext) XdrUnionBody() interface{} {
	switch u.V {
	case 0:
		return nil
	case 1:
		return u.V1()
	}
	return nil
}
func (u *_TrustLineEntry_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	case 1:
		return "V1"
	}
	return ""
}
func (v *_TrustLineEntry_Ext) XdrPointer() interface{} {
	return v
}
func (v *_TrustLineEntry_Ext) XdrValue() interface{} {
	return *v
}
func (v *_TrustLineEntry_Ext) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(x, x.Sprintf("%sv", name), &v.V)
	switch v.V {
	case 0:
		return
	case 1:
	XDR__TrustLineEntry_Ext_V1(x, x.Sprintf("%sv1", name), v.V1())
		return
	}
	xdrPanic(fmt.Sprintf("invalid V (%v) in _TrustLineEntry_Ext", v.V))
}
func XDR__TrustLineEntry_Ext(x XDR, name string, v *_TrustLineEntry_Ext) {
	x.Marshal(name, v)
}
func (v *TrustLineEntry) XdrPointer() interface{} {
	return v
}
func (v *TrustLineEntry) XdrValue() interface{} {
	return *v
}
func (v *TrustLineEntry) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_AccountID(x, x.Sprintf("%saccountID", name), &v.AccountID)
	XDR_Asset(x, x.Sprintf("%sasset", name), &v.Asset)
	XDR_Int64(x, x.Sprintf("%sbalance", name), &v.Balance)
	XDR_Int64(x, x.Sprintf("%slimit", name), &v.Limit)
	XDR_Uint32(x, x.Sprintf("%sflags", name), &v.Flags)
	XDR__TrustLineEntry_Ext(x, x.Sprintf("%sext", name), &v.Ext)
}
func XDR_TrustLineEntry(x XDR, name string, v *TrustLineEntry) {
	x.Marshal(name, v)
}
func XDR_OfferEntryFlags(x XDR, name string, v *OfferEntryFlags) {
	x.Marshal(name, v)
}
var _XdrNames_OfferEntryFlags = map[int32]string{
	int32(PASSIVE_FLAG): "PASSIVE_FLAG",
}
var _XdrValues_OfferEntryFlags = map[string]int32{
	"PASSIVE_FLAG": int32(PASSIVE_FLAG),
}
func (*OfferEntryFlags) XdrEnumNames() map[int32]string {
	return _XdrNames_OfferEntryFlags
}
func (v *OfferEntryFlags) String() string {
	if s, ok := _XdrNames_OfferEntryFlags[int32(*v)]; ok {
		return s
	}
	return fmt.Sprintf("OfferEntryFlags#%d", *v)
}
func (v *OfferEntryFlags) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, xdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_OfferEntryFlags[stok]; ok {
			*v = OfferEntryFlags(val)
			return nil
		}
		return XdrError(fmt.Sprintf("%s is not a valid OfferEntryFlags.", stok))
	}
}
func (v *OfferEntryFlags) GetU32() uint32 {
	return uint32(*v)
}
func (v *OfferEntryFlags) SetU32(n uint32) {
	*v = OfferEntryFlags(n)
}
func (v *OfferEntryFlags) XdrPointer() interface{} {
	return v
}
func (v *OfferEntryFlags) XdrValue() interface{} {
	return *v
}
func (u *_OfferEntry_Ext) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *_OfferEntry_Ext) XdrUnionTag() interface{} {
	return &u.V
}
func (u *_OfferEntry_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *_OfferEntry_Ext) XdrUnionBody() interface{} {
	switch u.V {
	case 0:
		return nil
	}
	return nil
}
func (u *_OfferEntry_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	}
	return ""
}
func (v *_OfferEntry_Ext) XdrPointer() interface{} {
	return v
}
func (v *_OfferEntry_Ext) XdrValue() interface{} {
	return *v
}
func (v *_OfferEntry_Ext) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(x, x.Sprintf("%sv", name), &v.V)
	switch v.V {
	case 0:
		return
	}
	xdrPanic(fmt.Sprintf("invalid V (%v) in _OfferEntry_Ext", v.V))
}
func XDR__OfferEntry_Ext(x XDR, name string, v *_OfferEntry_Ext) {
	x.Marshal(name, v)
}
func (v *OfferEntry) XdrPointer() interface{} {
	return v
}
func (v *OfferEntry) XdrValue() interface{} {
	return *v
}
func (v *OfferEntry) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_AccountID(x, x.Sprintf("%ssellerID", name), &v.SellerID)
	XDR_Uint64(x, x.Sprintf("%sofferID", name), &v.OfferID)
	XDR_Asset(x, x.Sprintf("%sselling", name), &v.Selling)
	XDR_Asset(x, x.Sprintf("%sbuying", name), &v.Buying)
	XDR_Int64(x, x.Sprintf("%samount", name), &v.Amount)
	XDR_Price(x, x.Sprintf("%sprice", name), &v.Price)
	XDR_Uint32(x, x.Sprintf("%sflags", name), &v.Flags)
	XDR__OfferEntry_Ext(x, x.Sprintf("%sext", name), &v.Ext)
}
func XDR_OfferEntry(x XDR, name string, v *OfferEntry) {
	x.Marshal(name, v)
}
func (u *_DataEntry_Ext) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *_DataEntry_Ext) XdrUnionTag() interface{} {
	return &u.V
}
func (u *_DataEntry_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *_DataEntry_Ext) XdrUnionBody() interface{} {
	switch u.V {
	case 0:
		return nil
	}
	return nil
}
func (u *_DataEntry_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	}
	return ""
}
func (v *_DataEntry_Ext) XdrPointer() interface{} {
	return v
}
func (v *_DataEntry_Ext) XdrValue() interface{} {
	return *v
}
func (v *_DataEntry_Ext) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(x, x.Sprintf("%sv", name), &v.V)
	switch v.V {
	case 0:
		return
	}
	xdrPanic(fmt.Sprintf("invalid V (%v) in _DataEntry_Ext", v.V))
}
func XDR__DataEntry_Ext(x XDR, name string, v *_DataEntry_Ext) {
	x.Marshal(name, v)
}
func (v *DataEntry) XdrPointer() interface{} {
	return v
}
func (v *DataEntry) XdrValue() interface{} {
	return *v
}
func (v *DataEntry) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_AccountID(x, x.Sprintf("%saccountID", name), &v.AccountID)
	XDR_String64(x, x.Sprintf("%sdataName", name), &v.DataName)
	XDR_DataValue(x, x.Sprintf("%sdataValue", name), &v.DataValue)
	XDR__DataEntry_Ext(x, x.Sprintf("%sext", name), &v.Ext)
}
func XDR_DataEntry(x XDR, name string, v *DataEntry) {
	x.Marshal(name, v)
}
func (u *_LedgerEntry_Data) Account() *AccountEntry {
	switch u.Type {
	case ACCOUNT:
		if v, ok := u._u.(*AccountEntry); ok {
			return v
		} else {
			var zero AccountEntry
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("_LedgerEntry_Data.Account accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *_LedgerEntry_Data) TrustLine() *TrustLineEntry {
	switch u.Type {
	case TRUSTLINE:
		if v, ok := u._u.(*TrustLineEntry); ok {
			return v
		} else {
			var zero TrustLineEntry
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("_LedgerEntry_Data.TrustLine accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *_LedgerEntry_Data) Offer() *OfferEntry {
	switch u.Type {
	case OFFER:
		if v, ok := u._u.(*OfferEntry); ok {
			return v
		} else {
			var zero OfferEntry
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("_LedgerEntry_Data.Offer accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *_LedgerEntry_Data) Data() *DataEntry {
	switch u.Type {
	case DATA:
		if v, ok := u._u.(*DataEntry); ok {
			return v
		} else {
			var zero DataEntry
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("_LedgerEntry_Data.Data accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *_LedgerEntry_Data) XdrValid() bool {
	switch u.Type {
	case ACCOUNT,TRUSTLINE,OFFER,DATA:
		return true
	}
	return false
}
func (u *_LedgerEntry_Data) XdrUnionTag() interface{} {
	return &u.Type
}
func (u *_LedgerEntry_Data) XdrUnionTagName() string {
	return "Type"
}
func (u *_LedgerEntry_Data) XdrUnionBody() interface{} {
	switch u.Type {
	case ACCOUNT:
		return u.Account()
	case TRUSTLINE:
		return u.TrustLine()
	case OFFER:
		return u.Offer()
	case DATA:
		return u.Data()
	}
	return nil
}
func (u *_LedgerEntry_Data) XdrUnionBodyName() string {
	switch u.Type {
	case ACCOUNT:
		return "Account"
	case TRUSTLINE:
		return "TrustLine"
	case OFFER:
		return "Offer"
	case DATA:
		return "Data"
	}
	return ""
}
func (v *_LedgerEntry_Data) XdrPointer() interface{} {
	return v
}
func (v *_LedgerEntry_Data) XdrValue() interface{} {
	return *v
}
func (v *_LedgerEntry_Data) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_LedgerEntryType(x, x.Sprintf("%stype", name), &v.Type)
	switch v.Type {
	case ACCOUNT:
	XDR_AccountEntry(x, x.Sprintf("%saccount", name), v.Account())
		return
	case TRUSTLINE:
	XDR_TrustLineEntry(x, x.Sprintf("%strustLine", name), v.TrustLine())
		return
	case OFFER:
	XDR_OfferEntry(x, x.Sprintf("%soffer", name), v.Offer())
		return
	case DATA:
	XDR_DataEntry(x, x.Sprintf("%sdata", name), v.Data())
		return
	}
	xdrPanic(fmt.Sprintf("invalid Type (%v) in _LedgerEntry_Data", v.Type))
}
func XDR__LedgerEntry_Data(x XDR, name string, v *_LedgerEntry_Data) {
	x.Marshal(name, v)
}
func (u *_LedgerEntry_Ext) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *_LedgerEntry_Ext) XdrUnionTag() interface{} {
	return &u.V
}
func (u *_LedgerEntry_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *_LedgerEntry_Ext) XdrUnionBody() interface{} {
	switch u.V {
	case 0:
		return nil
	}
	return nil
}
func (u *_LedgerEntry_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	}
	return ""
}
func (v *_LedgerEntry_Ext) XdrPointer() interface{} {
	return v
}
func (v *_LedgerEntry_Ext) XdrValue() interface{} {
	return *v
}
func (v *_LedgerEntry_Ext) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(x, x.Sprintf("%sv", name), &v.V)
	switch v.V {
	case 0:
		return
	}
	xdrPanic(fmt.Sprintf("invalid V (%v) in _LedgerEntry_Ext", v.V))
}
func XDR__LedgerEntry_Ext(x XDR, name string, v *_LedgerEntry_Ext) {
	x.Marshal(name, v)
}
func (v *LedgerEntry) XdrPointer() interface{} {
	return v
}
func (v *LedgerEntry) XdrValue() interface{} {
	return *v
}
func (v *LedgerEntry) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Uint32(x, x.Sprintf("%slastModifiedLedgerSeq", name), &v.LastModifiedLedgerSeq)
	XDR__LedgerEntry_Data(x, x.Sprintf("%sdata", name), &v.Data)
	XDR__LedgerEntry_Ext(x, x.Sprintf("%sext", name), &v.Ext)
}
func XDR_LedgerEntry(x XDR, name string, v *LedgerEntry) {
	x.Marshal(name, v)
}
func XDR_EnvelopeType(x XDR, name string, v *EnvelopeType) {
	x.Marshal(name, v)
}
var _XdrNames_EnvelopeType = map[int32]string{
	int32(ENVELOPE_TYPE_SCP): "ENVELOPE_TYPE_SCP",
	int32(ENVELOPE_TYPE_TX): "ENVELOPE_TYPE_TX",
	int32(ENVELOPE_TYPE_AUTH): "ENVELOPE_TYPE_AUTH",
}
var _XdrValues_EnvelopeType = map[string]int32{
	"ENVELOPE_TYPE_SCP": int32(ENVELOPE_TYPE_SCP),
	"ENVELOPE_TYPE_TX": int32(ENVELOPE_TYPE_TX),
	"ENVELOPE_TYPE_AUTH": int32(ENVELOPE_TYPE_AUTH),
}
func (*EnvelopeType) XdrEnumNames() map[int32]string {
	return _XdrNames_EnvelopeType
}
func (v *EnvelopeType) String() string {
	if s, ok := _XdrNames_EnvelopeType[int32(*v)]; ok {
		return s
	}
	return fmt.Sprintf("EnvelopeType#%d", *v)
}
func (v *EnvelopeType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, xdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_EnvelopeType[stok]; ok {
			*v = EnvelopeType(val)
			return nil
		}
		return XdrError(fmt.Sprintf("%s is not a valid EnvelopeType.", stok))
	}
}
func (v *EnvelopeType) GetU32() uint32 {
	return uint32(*v)
}
func (v *EnvelopeType) SetU32(n uint32) {
	*v = EnvelopeType(n)
}
func (v *EnvelopeType) XdrPointer() interface{} {
	return v
}
func (v *EnvelopeType) XdrValue() interface{} {
	return *v
}
func XDR_UpgradeType(x XDR, name string, v *UpgradeType) {
	if xs, ok := x.(interface{
		Marshal_UpgradeType(string, *UpgradeType)
	}); ok {
		xs.Marshal_UpgradeType(name, v)
	} else {
		x.Marshal(name, XdrVecOpaque{v, 128})
	}
}
func (u *_StellarValue_Ext) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *_StellarValue_Ext) XdrUnionTag() interface{} {
	return &u.V
}
func (u *_StellarValue_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *_StellarValue_Ext) XdrUnionBody() interface{} {
	switch u.V {
	case 0:
		return nil
	}
	return nil
}
func (u *_StellarValue_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	}
	return ""
}
func (v *_StellarValue_Ext) XdrPointer() interface{} {
	return v
}
func (v *_StellarValue_Ext) XdrValue() interface{} {
	return *v
}
func (v *_StellarValue_Ext) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(x, x.Sprintf("%sv", name), &v.V)
	switch v.V {
	case 0:
		return
	}
	xdrPanic(fmt.Sprintf("invalid V (%v) in _StellarValue_Ext", v.V))
}
func XDR__StellarValue_Ext(x XDR, name string, v *_StellarValue_Ext) {
	x.Marshal(name, v)
}
type XdrVec_6_UpgradeType []UpgradeType
func (v *XdrVec_6_UpgradeType) XdrBound() uint32 {
	const bound uint32 = 6 // Force error if not const or doesn't fit
	return bound
}
func (*XdrVec_6_UpgradeType) XdrCheckLen(length uint32) {
	if length > uint32(6) {
		xdrPanic("XdrVec_6_UpgradeType length %d exceeds bound 6", length)
	} else if int(length) < 0 {
		xdrPanic("XdrVec_6_UpgradeType length %d exceeds max int", length)
	}
}
func (v *XdrVec_6_UpgradeType) GetVecLen() uint32 { return uint32(len(*v)) }
func (v *XdrVec_6_UpgradeType) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2*cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(6); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]UpgradeType, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *XdrVec_6_UpgradeType) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if (i >= len(*v)) {
			v.SetVecLen(uint32(i+1))
		}
		XDR_UpgradeType(x, x.Sprintf("%s[%d]", name, i), &(*v)[i])
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *XdrVec_6_UpgradeType) XdrMarshal(x XDR, name string) {
	size := XdrSize{ size: uint32(len(*v)), bound: 6 }
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.size)
}
func (v *XdrVec_6_UpgradeType) XdrPointer() interface{} { return (*[]UpgradeType)(v) }
func (v *XdrVec_6_UpgradeType) XdrValue() interface{} { return ([]UpgradeType)(*v) }
func (v *StellarValue) XdrPointer() interface{} {
	return v
}
func (v *StellarValue) XdrValue() interface{} {
	return *v
}
func (v *StellarValue) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Hash(x, x.Sprintf("%stxSetHash", name), &v.TxSetHash)
	XDR_Uint64(x, x.Sprintf("%scloseTime", name), &v.CloseTime)
	x.Marshal(x.Sprintf("%supgrades", name), (*XdrVec_6_UpgradeType)(&v.Upgrades))
	XDR__StellarValue_Ext(x, x.Sprintf("%sext", name), &v.Ext)
}
func XDR_StellarValue(x XDR, name string, v *StellarValue) {
	x.Marshal(name, v)
}
func (u *_LedgerHeader_Ext) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *_LedgerHeader_Ext) XdrUnionTag() interface{} {
	return &u.V
}
func (u *_LedgerHeader_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *_LedgerHeader_Ext) XdrUnionBody() interface{} {
	switch u.V {
	case 0:
		return nil
	}
	return nil
}
func (u *_LedgerHeader_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	}
	return ""
}
func (v *_LedgerHeader_Ext) XdrPointer() interface{} {
	return v
}
func (v *_LedgerHeader_Ext) XdrValue() interface{} {
	return *v
}
func (v *_LedgerHeader_Ext) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(x, x.Sprintf("%sv", name), &v.V)
	switch v.V {
	case 0:
		return
	}
	xdrPanic(fmt.Sprintf("invalid V (%v) in _LedgerHeader_Ext", v.V))
}
func XDR__LedgerHeader_Ext(x XDR, name string, v *_LedgerHeader_Ext) {
	x.Marshal(name, v)
}
func (v *LedgerHeader) XdrPointer() interface{} {
	return v
}
func (v *LedgerHeader) XdrValue() interface{} {
	return *v
}
func (v *LedgerHeader) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Uint32(x, x.Sprintf("%sledgerVersion", name), &v.LedgerVersion)
	XDR_Hash(x, x.Sprintf("%spreviousLedgerHash", name), &v.PreviousLedgerHash)
	XDR_StellarValue(x, x.Sprintf("%sscpValue", name), &v.ScpValue)
	XDR_Hash(x, x.Sprintf("%stxSetResultHash", name), &v.TxSetResultHash)
	XDR_Hash(x, x.Sprintf("%sbucketListHash", name), &v.BucketListHash)
	XDR_Uint32(x, x.Sprintf("%sledgerSeq", name), &v.LedgerSeq)
	XDR_Int64(x, x.Sprintf("%stotalCoins", name), &v.TotalCoins)
	XDR_Int64(x, x.Sprintf("%sfeePool", name), &v.FeePool)
	XDR_Uint32(x, x.Sprintf("%sinflationSeq", name), &v.InflationSeq)
	XDR_Uint64(x, x.Sprintf("%sidPool", name), &v.IdPool)
	XDR_Uint32(x, x.Sprintf("%sbaseFee", name), &v.BaseFee)
	XDR_Uint32(x, x.Sprintf("%sbaseReserve", name), &v.BaseReserve)
	XDR_Uint32(x, x.Sprintf("%smaxTxSetSize", name), &v.MaxTxSetSize)
	for i := 0; i < len(v.SkipList); i++ {
			XDR_Hash(x, x.Sprintf("%s[%d]", x.Sprintf("%sskipList", name), i), &(v.SkipList)[i])
		}
	XDR__LedgerHeader_Ext(x, x.Sprintf("%sext", name), &v.Ext)
}
func XDR_LedgerHeader(x XDR, name string, v *LedgerHeader) {
	x.Marshal(name, v)
}
func XDR_LedgerUpgradeType(x XDR, name string, v *LedgerUpgradeType) {
	x.Marshal(name, v)
}
var _XdrNames_LedgerUpgradeType = map[int32]string{
	int32(LEDGER_UPGRADE_VERSION): "LEDGER_UPGRADE_VERSION",
	int32(LEDGER_UPGRADE_BASE_FEE): "LEDGER_UPGRADE_BASE_FEE",
	int32(LEDGER_UPGRADE_MAX_TX_SET_SIZE): "LEDGER_UPGRADE_MAX_TX_SET_SIZE",
	int32(LEDGER_UPGRADE_BASE_RESERVE): "LEDGER_UPGRADE_BASE_RESERVE",
}
var _XdrValues_LedgerUpgradeType = map[string]int32{
	"LEDGER_UPGRADE_VERSION": int32(LEDGER_UPGRADE_VERSION),
	"LEDGER_UPGRADE_BASE_FEE": int32(LEDGER_UPGRADE_BASE_FEE),
	"LEDGER_UPGRADE_MAX_TX_SET_SIZE": int32(LEDGER_UPGRADE_MAX_TX_SET_SIZE),
	"LEDGER_UPGRADE_BASE_RESERVE": int32(LEDGER_UPGRADE_BASE_RESERVE),
}
func (*LedgerUpgradeType) XdrEnumNames() map[int32]string {
	return _XdrNames_LedgerUpgradeType
}
func (v *LedgerUpgradeType) String() string {
	if s, ok := _XdrNames_LedgerUpgradeType[int32(*v)]; ok {
		return s
	}
	return fmt.Sprintf("LedgerUpgradeType#%d", *v)
}
func (v *LedgerUpgradeType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, xdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_LedgerUpgradeType[stok]; ok {
			*v = LedgerUpgradeType(val)
			return nil
		}
		return XdrError(fmt.Sprintf("%s is not a valid LedgerUpgradeType.", stok))
	}
}
func (v *LedgerUpgradeType) GetU32() uint32 {
	return uint32(*v)
}
func (v *LedgerUpgradeType) SetU32(n uint32) {
	*v = LedgerUpgradeType(n)
}
func (v *LedgerUpgradeType) XdrPointer() interface{} {
	return v
}
func (v *LedgerUpgradeType) XdrValue() interface{} {
	return *v
}
func (u *LedgerUpgrade) NewLedgerVersion() *Uint32 {
	switch u.Type {
	case LEDGER_UPGRADE_VERSION:
		if v, ok := u._u.(*Uint32); ok {
			return v
		} else {
			var zero Uint32
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("LedgerUpgrade.NewLedgerVersion accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *LedgerUpgrade) NewBaseFee() *Uint32 {
	switch u.Type {
	case LEDGER_UPGRADE_BASE_FEE:
		if v, ok := u._u.(*Uint32); ok {
			return v
		} else {
			var zero Uint32
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("LedgerUpgrade.NewBaseFee accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *LedgerUpgrade) NewMaxTxSetSize() *Uint32 {
	switch u.Type {
	case LEDGER_UPGRADE_MAX_TX_SET_SIZE:
		if v, ok := u._u.(*Uint32); ok {
			return v
		} else {
			var zero Uint32
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("LedgerUpgrade.NewMaxTxSetSize accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *LedgerUpgrade) NewBaseReserve() *Uint32 {
	switch u.Type {
	case LEDGER_UPGRADE_BASE_RESERVE:
		if v, ok := u._u.(*Uint32); ok {
			return v
		} else {
			var zero Uint32
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("LedgerUpgrade.NewBaseReserve accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *LedgerUpgrade) XdrValid() bool {
	switch u.Type {
	case LEDGER_UPGRADE_VERSION,LEDGER_UPGRADE_BASE_FEE,LEDGER_UPGRADE_MAX_TX_SET_SIZE,LEDGER_UPGRADE_BASE_RESERVE:
		return true
	}
	return false
}
func (u *LedgerUpgrade) XdrUnionTag() interface{} {
	return &u.Type
}
func (u *LedgerUpgrade) XdrUnionTagName() string {
	return "Type"
}
func (u *LedgerUpgrade) XdrUnionBody() interface{} {
	switch u.Type {
	case LEDGER_UPGRADE_VERSION:
		return u.NewLedgerVersion()
	case LEDGER_UPGRADE_BASE_FEE:
		return u.NewBaseFee()
	case LEDGER_UPGRADE_MAX_TX_SET_SIZE:
		return u.NewMaxTxSetSize()
	case LEDGER_UPGRADE_BASE_RESERVE:
		return u.NewBaseReserve()
	}
	return nil
}
func (u *LedgerUpgrade) XdrUnionBodyName() string {
	switch u.Type {
	case LEDGER_UPGRADE_VERSION:
		return "NewLedgerVersion"
	case LEDGER_UPGRADE_BASE_FEE:
		return "NewBaseFee"
	case LEDGER_UPGRADE_MAX_TX_SET_SIZE:
		return "NewMaxTxSetSize"
	case LEDGER_UPGRADE_BASE_RESERVE:
		return "NewBaseReserve"
	}
	return ""
}
func (v *LedgerUpgrade) XdrPointer() interface{} {
	return v
}
func (v *LedgerUpgrade) XdrValue() interface{} {
	return *v
}
func (v *LedgerUpgrade) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_LedgerUpgradeType(x, x.Sprintf("%stype", name), &v.Type)
	switch v.Type {
	case LEDGER_UPGRADE_VERSION:
	XDR_Uint32(x, x.Sprintf("%snewLedgerVersion", name), v.NewLedgerVersion())
		return
	case LEDGER_UPGRADE_BASE_FEE:
	XDR_Uint32(x, x.Sprintf("%snewBaseFee", name), v.NewBaseFee())
		return
	case LEDGER_UPGRADE_MAX_TX_SET_SIZE:
	XDR_Uint32(x, x.Sprintf("%snewMaxTxSetSize", name), v.NewMaxTxSetSize())
		return
	case LEDGER_UPGRADE_BASE_RESERVE:
	XDR_Uint32(x, x.Sprintf("%snewBaseReserve", name), v.NewBaseReserve())
		return
	}
	xdrPanic(fmt.Sprintf("invalid Type (%v) in LedgerUpgrade", v.Type))
}
func XDR_LedgerUpgrade(x XDR, name string, v *LedgerUpgrade) {
	x.Marshal(name, v)
}
func (v *_LedgerKey_Account) XdrPointer() interface{} {
	return v
}
func (v *_LedgerKey_Account) XdrValue() interface{} {
	return *v
}
func (v *_LedgerKey_Account) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_AccountID(x, x.Sprintf("%saccountID", name), &v.AccountID)
}
func XDR__LedgerKey_Account(x XDR, name string, v *_LedgerKey_Account) {
	x.Marshal(name, v)
}
func (v *_LedgerKey_TrustLine) XdrPointer() interface{} {
	return v
}
func (v *_LedgerKey_TrustLine) XdrValue() interface{} {
	return *v
}
func (v *_LedgerKey_TrustLine) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_AccountID(x, x.Sprintf("%saccountID", name), &v.AccountID)
	XDR_Asset(x, x.Sprintf("%sasset", name), &v.Asset)
}
func XDR__LedgerKey_TrustLine(x XDR, name string, v *_LedgerKey_TrustLine) {
	x.Marshal(name, v)
}
func (v *_LedgerKey_Offer) XdrPointer() interface{} {
	return v
}
func (v *_LedgerKey_Offer) XdrValue() interface{} {
	return *v
}
func (v *_LedgerKey_Offer) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_AccountID(x, x.Sprintf("%ssellerID", name), &v.SellerID)
	XDR_Uint64(x, x.Sprintf("%sofferID", name), &v.OfferID)
}
func XDR__LedgerKey_Offer(x XDR, name string, v *_LedgerKey_Offer) {
	x.Marshal(name, v)
}
func (v *_LedgerKey_Data) XdrPointer() interface{} {
	return v
}
func (v *_LedgerKey_Data) XdrValue() interface{} {
	return *v
}
func (v *_LedgerKey_Data) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_AccountID(x, x.Sprintf("%saccountID", name), &v.AccountID)
	XDR_String64(x, x.Sprintf("%sdataName", name), &v.DataName)
}
func XDR__LedgerKey_Data(x XDR, name string, v *_LedgerKey_Data) {
	x.Marshal(name, v)
}
func (u *LedgerKey) Account() *_LedgerKey_Account {
	switch u.Type {
	case ACCOUNT:
		if v, ok := u._u.(*_LedgerKey_Account); ok {
			return v
		} else {
			var zero _LedgerKey_Account
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("LedgerKey.Account accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *LedgerKey) TrustLine() *_LedgerKey_TrustLine {
	switch u.Type {
	case TRUSTLINE:
		if v, ok := u._u.(*_LedgerKey_TrustLine); ok {
			return v
		} else {
			var zero _LedgerKey_TrustLine
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("LedgerKey.TrustLine accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *LedgerKey) Offer() *_LedgerKey_Offer {
	switch u.Type {
	case OFFER:
		if v, ok := u._u.(*_LedgerKey_Offer); ok {
			return v
		} else {
			var zero _LedgerKey_Offer
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("LedgerKey.Offer accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *LedgerKey) Data() *_LedgerKey_Data {
	switch u.Type {
	case DATA:
		if v, ok := u._u.(*_LedgerKey_Data); ok {
			return v
		} else {
			var zero _LedgerKey_Data
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("LedgerKey.Data accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *LedgerKey) XdrValid() bool {
	switch u.Type {
	case ACCOUNT,TRUSTLINE,OFFER,DATA:
		return true
	}
	return false
}
func (u *LedgerKey) XdrUnionTag() interface{} {
	return &u.Type
}
func (u *LedgerKey) XdrUnionTagName() string {
	return "Type"
}
func (u *LedgerKey) XdrUnionBody() interface{} {
	switch u.Type {
	case ACCOUNT:
		return u.Account()
	case TRUSTLINE:
		return u.TrustLine()
	case OFFER:
		return u.Offer()
	case DATA:
		return u.Data()
	}
	return nil
}
func (u *LedgerKey) XdrUnionBodyName() string {
	switch u.Type {
	case ACCOUNT:
		return "Account"
	case TRUSTLINE:
		return "TrustLine"
	case OFFER:
		return "Offer"
	case DATA:
		return "Data"
	}
	return ""
}
func (v *LedgerKey) XdrPointer() interface{} {
	return v
}
func (v *LedgerKey) XdrValue() interface{} {
	return *v
}
func (v *LedgerKey) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_LedgerEntryType(x, x.Sprintf("%stype", name), &v.Type)
	switch v.Type {
	case ACCOUNT:
	XDR__LedgerKey_Account(x, x.Sprintf("%saccount", name), v.Account())
		return
	case TRUSTLINE:
	XDR__LedgerKey_TrustLine(x, x.Sprintf("%strustLine", name), v.TrustLine())
		return
	case OFFER:
	XDR__LedgerKey_Offer(x, x.Sprintf("%soffer", name), v.Offer())
		return
	case DATA:
	XDR__LedgerKey_Data(x, x.Sprintf("%sdata", name), v.Data())
		return
	}
	xdrPanic(fmt.Sprintf("invalid Type (%v) in LedgerKey", v.Type))
}
func XDR_LedgerKey(x XDR, name string, v *LedgerKey) {
	x.Marshal(name, v)
}
func XDR_BucketEntryType(x XDR, name string, v *BucketEntryType) {
	x.Marshal(name, v)
}
var _XdrNames_BucketEntryType = map[int32]string{
	int32(LIVEENTRY): "LIVEENTRY",
	int32(DEADENTRY): "DEADENTRY",
}
var _XdrValues_BucketEntryType = map[string]int32{
	"LIVEENTRY": int32(LIVEENTRY),
	"DEADENTRY": int32(DEADENTRY),
}
func (*BucketEntryType) XdrEnumNames() map[int32]string {
	return _XdrNames_BucketEntryType
}
func (v *BucketEntryType) String() string {
	if s, ok := _XdrNames_BucketEntryType[int32(*v)]; ok {
		return s
	}
	return fmt.Sprintf("BucketEntryType#%d", *v)
}
func (v *BucketEntryType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, xdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_BucketEntryType[stok]; ok {
			*v = BucketEntryType(val)
			return nil
		}
		return XdrError(fmt.Sprintf("%s is not a valid BucketEntryType.", stok))
	}
}
func (v *BucketEntryType) GetU32() uint32 {
	return uint32(*v)
}
func (v *BucketEntryType) SetU32(n uint32) {
	*v = BucketEntryType(n)
}
func (v *BucketEntryType) XdrPointer() interface{} {
	return v
}
func (v *BucketEntryType) XdrValue() interface{} {
	return *v
}
func (u *BucketEntry) LiveEntry() *LedgerEntry {
	switch u.Type {
	case LIVEENTRY:
		if v, ok := u._u.(*LedgerEntry); ok {
			return v
		} else {
			var zero LedgerEntry
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("BucketEntry.LiveEntry accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *BucketEntry) DeadEntry() *LedgerKey {
	switch u.Type {
	case DEADENTRY:
		if v, ok := u._u.(*LedgerKey); ok {
			return v
		} else {
			var zero LedgerKey
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("BucketEntry.DeadEntry accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *BucketEntry) XdrValid() bool {
	switch u.Type {
	case LIVEENTRY,DEADENTRY:
		return true
	}
	return false
}
func (u *BucketEntry) XdrUnionTag() interface{} {
	return &u.Type
}
func (u *BucketEntry) XdrUnionTagName() string {
	return "Type"
}
func (u *BucketEntry) XdrUnionBody() interface{} {
	switch u.Type {
	case LIVEENTRY:
		return u.LiveEntry()
	case DEADENTRY:
		return u.DeadEntry()
	}
	return nil
}
func (u *BucketEntry) XdrUnionBodyName() string {
	switch u.Type {
	case LIVEENTRY:
		return "LiveEntry"
	case DEADENTRY:
		return "DeadEntry"
	}
	return ""
}
func (v *BucketEntry) XdrPointer() interface{} {
	return v
}
func (v *BucketEntry) XdrValue() interface{} {
	return *v
}
func (v *BucketEntry) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_BucketEntryType(x, x.Sprintf("%stype", name), &v.Type)
	switch v.Type {
	case LIVEENTRY:
	XDR_LedgerEntry(x, x.Sprintf("%sliveEntry", name), v.LiveEntry())
		return
	case DEADENTRY:
	XDR_LedgerKey(x, x.Sprintf("%sdeadEntry", name), v.DeadEntry())
		return
	}
	xdrPanic(fmt.Sprintf("invalid Type (%v) in BucketEntry", v.Type))
}
func XDR_BucketEntry(x XDR, name string, v *BucketEntry) {
	x.Marshal(name, v)
}
type XdrVec_unbounded_TransactionEnvelope []TransactionEnvelope
func (v *XdrVec_unbounded_TransactionEnvelope) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (*XdrVec_unbounded_TransactionEnvelope) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		xdrPanic("XdrVec_unbounded_TransactionEnvelope length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		xdrPanic("XdrVec_unbounded_TransactionEnvelope length %d exceeds max int", length)
	}
}
func (v *XdrVec_unbounded_TransactionEnvelope) GetVecLen() uint32 { return uint32(len(*v)) }
func (v *XdrVec_unbounded_TransactionEnvelope) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2*cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]TransactionEnvelope, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *XdrVec_unbounded_TransactionEnvelope) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if (i >= len(*v)) {
			v.SetVecLen(uint32(i+1))
		}
		XDR_TransactionEnvelope(x, x.Sprintf("%s[%d]", name, i), &(*v)[i])
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *XdrVec_unbounded_TransactionEnvelope) XdrMarshal(x XDR, name string) {
	size := XdrSize{ size: uint32(len(*v)), bound: 4294967295 }
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.size)
}
func (v *XdrVec_unbounded_TransactionEnvelope) XdrPointer() interface{} { return (*[]TransactionEnvelope)(v) }
func (v *XdrVec_unbounded_TransactionEnvelope) XdrValue() interface{} { return ([]TransactionEnvelope)(*v) }
func (v *TransactionSet) XdrPointer() interface{} {
	return v
}
func (v *TransactionSet) XdrValue() interface{} {
	return *v
}
func (v *TransactionSet) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Hash(x, x.Sprintf("%spreviousLedgerHash", name), &v.PreviousLedgerHash)
	x.Marshal(x.Sprintf("%stxs", name), (*XdrVec_unbounded_TransactionEnvelope)(&v.Txs))
}
func XDR_TransactionSet(x XDR, name string, v *TransactionSet) {
	x.Marshal(name, v)
}
func (v *TransactionResultPair) XdrPointer() interface{} {
	return v
}
func (v *TransactionResultPair) XdrValue() interface{} {
	return *v
}
func (v *TransactionResultPair) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Hash(x, x.Sprintf("%stransactionHash", name), &v.TransactionHash)
	XDR_TransactionResult(x, x.Sprintf("%sresult", name), &v.Result)
}
func XDR_TransactionResultPair(x XDR, name string, v *TransactionResultPair) {
	x.Marshal(name, v)
}
type XdrVec_unbounded_TransactionResultPair []TransactionResultPair
func (v *XdrVec_unbounded_TransactionResultPair) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (*XdrVec_unbounded_TransactionResultPair) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		xdrPanic("XdrVec_unbounded_TransactionResultPair length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		xdrPanic("XdrVec_unbounded_TransactionResultPair length %d exceeds max int", length)
	}
}
func (v *XdrVec_unbounded_TransactionResultPair) GetVecLen() uint32 { return uint32(len(*v)) }
func (v *XdrVec_unbounded_TransactionResultPair) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2*cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]TransactionResultPair, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *XdrVec_unbounded_TransactionResultPair) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if (i >= len(*v)) {
			v.SetVecLen(uint32(i+1))
		}
		XDR_TransactionResultPair(x, x.Sprintf("%s[%d]", name, i), &(*v)[i])
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *XdrVec_unbounded_TransactionResultPair) XdrMarshal(x XDR, name string) {
	size := XdrSize{ size: uint32(len(*v)), bound: 4294967295 }
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.size)
}
func (v *XdrVec_unbounded_TransactionResultPair) XdrPointer() interface{} { return (*[]TransactionResultPair)(v) }
func (v *XdrVec_unbounded_TransactionResultPair) XdrValue() interface{} { return ([]TransactionResultPair)(*v) }
func (v *TransactionResultSet) XdrPointer() interface{} {
	return v
}
func (v *TransactionResultSet) XdrValue() interface{} {
	return *v
}
func (v *TransactionResultSet) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sresults", name), (*XdrVec_unbounded_TransactionResultPair)(&v.Results))
}
func XDR_TransactionResultSet(x XDR, name string, v *TransactionResultSet) {
	x.Marshal(name, v)
}
func (u *_TransactionHistoryEntry_Ext) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *_TransactionHistoryEntry_Ext) XdrUnionTag() interface{} {
	return &u.V
}
func (u *_TransactionHistoryEntry_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *_TransactionHistoryEntry_Ext) XdrUnionBody() interface{} {
	switch u.V {
	case 0:
		return nil
	}
	return nil
}
func (u *_TransactionHistoryEntry_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	}
	return ""
}
func (v *_TransactionHistoryEntry_Ext) XdrPointer() interface{} {
	return v
}
func (v *_TransactionHistoryEntry_Ext) XdrValue() interface{} {
	return *v
}
func (v *_TransactionHistoryEntry_Ext) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(x, x.Sprintf("%sv", name), &v.V)
	switch v.V {
	case 0:
		return
	}
	xdrPanic(fmt.Sprintf("invalid V (%v) in _TransactionHistoryEntry_Ext", v.V))
}
func XDR__TransactionHistoryEntry_Ext(x XDR, name string, v *_TransactionHistoryEntry_Ext) {
	x.Marshal(name, v)
}
func (v *TransactionHistoryEntry) XdrPointer() interface{} {
	return v
}
func (v *TransactionHistoryEntry) XdrValue() interface{} {
	return *v
}
func (v *TransactionHistoryEntry) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Uint32(x, x.Sprintf("%sledgerSeq", name), &v.LedgerSeq)
	XDR_TransactionSet(x, x.Sprintf("%stxSet", name), &v.TxSet)
	XDR__TransactionHistoryEntry_Ext(x, x.Sprintf("%sext", name), &v.Ext)
}
func XDR_TransactionHistoryEntry(x XDR, name string, v *TransactionHistoryEntry) {
	x.Marshal(name, v)
}
func (u *_TransactionHistoryResultEntry_Ext) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *_TransactionHistoryResultEntry_Ext) XdrUnionTag() interface{} {
	return &u.V
}
func (u *_TransactionHistoryResultEntry_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *_TransactionHistoryResultEntry_Ext) XdrUnionBody() interface{} {
	switch u.V {
	case 0:
		return nil
	}
	return nil
}
func (u *_TransactionHistoryResultEntry_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	}
	return ""
}
func (v *_TransactionHistoryResultEntry_Ext) XdrPointer() interface{} {
	return v
}
func (v *_TransactionHistoryResultEntry_Ext) XdrValue() interface{} {
	return *v
}
func (v *_TransactionHistoryResultEntry_Ext) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(x, x.Sprintf("%sv", name), &v.V)
	switch v.V {
	case 0:
		return
	}
	xdrPanic(fmt.Sprintf("invalid V (%v) in _TransactionHistoryResultEntry_Ext", v.V))
}
func XDR__TransactionHistoryResultEntry_Ext(x XDR, name string, v *_TransactionHistoryResultEntry_Ext) {
	x.Marshal(name, v)
}
func (v *TransactionHistoryResultEntry) XdrPointer() interface{} {
	return v
}
func (v *TransactionHistoryResultEntry) XdrValue() interface{} {
	return *v
}
func (v *TransactionHistoryResultEntry) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Uint32(x, x.Sprintf("%sledgerSeq", name), &v.LedgerSeq)
	XDR_TransactionResultSet(x, x.Sprintf("%stxResultSet", name), &v.TxResultSet)
	XDR__TransactionHistoryResultEntry_Ext(x, x.Sprintf("%sext", name), &v.Ext)
}
func XDR_TransactionHistoryResultEntry(x XDR, name string, v *TransactionHistoryResultEntry) {
	x.Marshal(name, v)
}
func (u *_LedgerHeaderHistoryEntry_Ext) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *_LedgerHeaderHistoryEntry_Ext) XdrUnionTag() interface{} {
	return &u.V
}
func (u *_LedgerHeaderHistoryEntry_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *_LedgerHeaderHistoryEntry_Ext) XdrUnionBody() interface{} {
	switch u.V {
	case 0:
		return nil
	}
	return nil
}
func (u *_LedgerHeaderHistoryEntry_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	}
	return ""
}
func (v *_LedgerHeaderHistoryEntry_Ext) XdrPointer() interface{} {
	return v
}
func (v *_LedgerHeaderHistoryEntry_Ext) XdrValue() interface{} {
	return *v
}
func (v *_LedgerHeaderHistoryEntry_Ext) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(x, x.Sprintf("%sv", name), &v.V)
	switch v.V {
	case 0:
		return
	}
	xdrPanic(fmt.Sprintf("invalid V (%v) in _LedgerHeaderHistoryEntry_Ext", v.V))
}
func XDR__LedgerHeaderHistoryEntry_Ext(x XDR, name string, v *_LedgerHeaderHistoryEntry_Ext) {
	x.Marshal(name, v)
}
func (v *LedgerHeaderHistoryEntry) XdrPointer() interface{} {
	return v
}
func (v *LedgerHeaderHistoryEntry) XdrValue() interface{} {
	return *v
}
func (v *LedgerHeaderHistoryEntry) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Hash(x, x.Sprintf("%shash", name), &v.Hash)
	XDR_LedgerHeader(x, x.Sprintf("%sheader", name), &v.Header)
	XDR__LedgerHeaderHistoryEntry_Ext(x, x.Sprintf("%sext", name), &v.Ext)
}
func XDR_LedgerHeaderHistoryEntry(x XDR, name string, v *LedgerHeaderHistoryEntry) {
	x.Marshal(name, v)
}
type XdrVec_unbounded_SCPEnvelope []SCPEnvelope
func (v *XdrVec_unbounded_SCPEnvelope) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (*XdrVec_unbounded_SCPEnvelope) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		xdrPanic("XdrVec_unbounded_SCPEnvelope length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		xdrPanic("XdrVec_unbounded_SCPEnvelope length %d exceeds max int", length)
	}
}
func (v *XdrVec_unbounded_SCPEnvelope) GetVecLen() uint32 { return uint32(len(*v)) }
func (v *XdrVec_unbounded_SCPEnvelope) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2*cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]SCPEnvelope, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *XdrVec_unbounded_SCPEnvelope) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if (i >= len(*v)) {
			v.SetVecLen(uint32(i+1))
		}
		XDR_SCPEnvelope(x, x.Sprintf("%s[%d]", name, i), &(*v)[i])
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *XdrVec_unbounded_SCPEnvelope) XdrMarshal(x XDR, name string) {
	size := XdrSize{ size: uint32(len(*v)), bound: 4294967295 }
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.size)
}
func (v *XdrVec_unbounded_SCPEnvelope) XdrPointer() interface{} { return (*[]SCPEnvelope)(v) }
func (v *XdrVec_unbounded_SCPEnvelope) XdrValue() interface{} { return ([]SCPEnvelope)(*v) }
func (v *LedgerSCPMessages) XdrPointer() interface{} {
	return v
}
func (v *LedgerSCPMessages) XdrValue() interface{} {
	return *v
}
func (v *LedgerSCPMessages) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Uint32(x, x.Sprintf("%sledgerSeq", name), &v.LedgerSeq)
	x.Marshal(x.Sprintf("%smessages", name), (*XdrVec_unbounded_SCPEnvelope)(&v.Messages))
}
func XDR_LedgerSCPMessages(x XDR, name string, v *LedgerSCPMessages) {
	x.Marshal(name, v)
}
func (v *SCPHistoryEntryV0) XdrPointer() interface{} {
	return v
}
func (v *SCPHistoryEntryV0) XdrValue() interface{} {
	return *v
}
func (v *SCPHistoryEntryV0) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%squorumSets", name), (*XdrVec_unbounded_SCPQuorumSet)(&v.QuorumSets))
	XDR_LedgerSCPMessages(x, x.Sprintf("%sledgerMessages", name), &v.LedgerMessages)
}
func XDR_SCPHistoryEntryV0(x XDR, name string, v *SCPHistoryEntryV0) {
	x.Marshal(name, v)
}
func (u *SCPHistoryEntry) V0() *SCPHistoryEntryV0 {
	switch u.V {
	case 0:
		if v, ok := u._u.(*SCPHistoryEntryV0); ok {
			return v
		} else {
			var zero SCPHistoryEntryV0
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("SCPHistoryEntry.V0 accessed when V == %v", u.V)
		return nil
	}
}
func (u *SCPHistoryEntry) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *SCPHistoryEntry) XdrUnionTag() interface{} {
	return &u.V
}
func (u *SCPHistoryEntry) XdrUnionTagName() string {
	return "V"
}
func (u *SCPHistoryEntry) XdrUnionBody() interface{} {
	switch u.V {
	case 0:
		return u.V0()
	}
	return nil
}
func (u *SCPHistoryEntry) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return "V0"
	}
	return ""
}
func (v *SCPHistoryEntry) XdrPointer() interface{} {
	return v
}
func (v *SCPHistoryEntry) XdrValue() interface{} {
	return *v
}
func (v *SCPHistoryEntry) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(x, x.Sprintf("%sv", name), &v.V)
	switch v.V {
	case 0:
	XDR_SCPHistoryEntryV0(x, x.Sprintf("%sv0", name), v.V0())
		return
	}
	xdrPanic(fmt.Sprintf("invalid V (%v) in SCPHistoryEntry", v.V))
}
func XDR_SCPHistoryEntry(x XDR, name string, v *SCPHistoryEntry) {
	x.Marshal(name, v)
}
func XDR_LedgerEntryChangeType(x XDR, name string, v *LedgerEntryChangeType) {
	x.Marshal(name, v)
}
var _XdrNames_LedgerEntryChangeType = map[int32]string{
	int32(LEDGER_ENTRY_CREATED): "LEDGER_ENTRY_CREATED",
	int32(LEDGER_ENTRY_UPDATED): "LEDGER_ENTRY_UPDATED",
	int32(LEDGER_ENTRY_REMOVED): "LEDGER_ENTRY_REMOVED",
	int32(LEDGER_ENTRY_STATE): "LEDGER_ENTRY_STATE",
}
var _XdrValues_LedgerEntryChangeType = map[string]int32{
	"LEDGER_ENTRY_CREATED": int32(LEDGER_ENTRY_CREATED),
	"LEDGER_ENTRY_UPDATED": int32(LEDGER_ENTRY_UPDATED),
	"LEDGER_ENTRY_REMOVED": int32(LEDGER_ENTRY_REMOVED),
	"LEDGER_ENTRY_STATE": int32(LEDGER_ENTRY_STATE),
}
func (*LedgerEntryChangeType) XdrEnumNames() map[int32]string {
	return _XdrNames_LedgerEntryChangeType
}
func (v *LedgerEntryChangeType) String() string {
	if s, ok := _XdrNames_LedgerEntryChangeType[int32(*v)]; ok {
		return s
	}
	return fmt.Sprintf("LedgerEntryChangeType#%d", *v)
}
func (v *LedgerEntryChangeType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, xdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_LedgerEntryChangeType[stok]; ok {
			*v = LedgerEntryChangeType(val)
			return nil
		}
		return XdrError(fmt.Sprintf("%s is not a valid LedgerEntryChangeType.", stok))
	}
}
func (v *LedgerEntryChangeType) GetU32() uint32 {
	return uint32(*v)
}
func (v *LedgerEntryChangeType) SetU32(n uint32) {
	*v = LedgerEntryChangeType(n)
}
func (v *LedgerEntryChangeType) XdrPointer() interface{} {
	return v
}
func (v *LedgerEntryChangeType) XdrValue() interface{} {
	return *v
}
func (u *LedgerEntryChange) Created() *LedgerEntry {
	switch u.Type {
	case LEDGER_ENTRY_CREATED:
		if v, ok := u._u.(*LedgerEntry); ok {
			return v
		} else {
			var zero LedgerEntry
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("LedgerEntryChange.Created accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *LedgerEntryChange) Updated() *LedgerEntry {
	switch u.Type {
	case LEDGER_ENTRY_UPDATED:
		if v, ok := u._u.(*LedgerEntry); ok {
			return v
		} else {
			var zero LedgerEntry
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("LedgerEntryChange.Updated accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *LedgerEntryChange) Removed() *LedgerKey {
	switch u.Type {
	case LEDGER_ENTRY_REMOVED:
		if v, ok := u._u.(*LedgerKey); ok {
			return v
		} else {
			var zero LedgerKey
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("LedgerEntryChange.Removed accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *LedgerEntryChange) State() *LedgerEntry {
	switch u.Type {
	case LEDGER_ENTRY_STATE:
		if v, ok := u._u.(*LedgerEntry); ok {
			return v
		} else {
			var zero LedgerEntry
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("LedgerEntryChange.State accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *LedgerEntryChange) XdrValid() bool {
	switch u.Type {
	case LEDGER_ENTRY_CREATED,LEDGER_ENTRY_UPDATED,LEDGER_ENTRY_REMOVED,LEDGER_ENTRY_STATE:
		return true
	}
	return false
}
func (u *LedgerEntryChange) XdrUnionTag() interface{} {
	return &u.Type
}
func (u *LedgerEntryChange) XdrUnionTagName() string {
	return "Type"
}
func (u *LedgerEntryChange) XdrUnionBody() interface{} {
	switch u.Type {
	case LEDGER_ENTRY_CREATED:
		return u.Created()
	case LEDGER_ENTRY_UPDATED:
		return u.Updated()
	case LEDGER_ENTRY_REMOVED:
		return u.Removed()
	case LEDGER_ENTRY_STATE:
		return u.State()
	}
	return nil
}
func (u *LedgerEntryChange) XdrUnionBodyName() string {
	switch u.Type {
	case LEDGER_ENTRY_CREATED:
		return "Created"
	case LEDGER_ENTRY_UPDATED:
		return "Updated"
	case LEDGER_ENTRY_REMOVED:
		return "Removed"
	case LEDGER_ENTRY_STATE:
		return "State"
	}
	return ""
}
func (v *LedgerEntryChange) XdrPointer() interface{} {
	return v
}
func (v *LedgerEntryChange) XdrValue() interface{} {
	return *v
}
func (v *LedgerEntryChange) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_LedgerEntryChangeType(x, x.Sprintf("%stype", name), &v.Type)
	switch v.Type {
	case LEDGER_ENTRY_CREATED:
	XDR_LedgerEntry(x, x.Sprintf("%screated", name), v.Created())
		return
	case LEDGER_ENTRY_UPDATED:
	XDR_LedgerEntry(x, x.Sprintf("%supdated", name), v.Updated())
		return
	case LEDGER_ENTRY_REMOVED:
	XDR_LedgerKey(x, x.Sprintf("%sremoved", name), v.Removed())
		return
	case LEDGER_ENTRY_STATE:
	XDR_LedgerEntry(x, x.Sprintf("%sstate", name), v.State())
		return
	}
	xdrPanic(fmt.Sprintf("invalid Type (%v) in LedgerEntryChange", v.Type))
}
func XDR_LedgerEntryChange(x XDR, name string, v *LedgerEntryChange) {
	x.Marshal(name, v)
}
type XdrVec_unbounded_LedgerEntryChange []LedgerEntryChange
func (v *XdrVec_unbounded_LedgerEntryChange) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (*XdrVec_unbounded_LedgerEntryChange) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		xdrPanic("XdrVec_unbounded_LedgerEntryChange length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		xdrPanic("XdrVec_unbounded_LedgerEntryChange length %d exceeds max int", length)
	}
}
func (v *XdrVec_unbounded_LedgerEntryChange) GetVecLen() uint32 { return uint32(len(*v)) }
func (v *XdrVec_unbounded_LedgerEntryChange) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2*cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]LedgerEntryChange, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *XdrVec_unbounded_LedgerEntryChange) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if (i >= len(*v)) {
			v.SetVecLen(uint32(i+1))
		}
		XDR_LedgerEntryChange(x, x.Sprintf("%s[%d]", name, i), &(*v)[i])
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *XdrVec_unbounded_LedgerEntryChange) XdrMarshal(x XDR, name string) {
	size := XdrSize{ size: uint32(len(*v)), bound: 4294967295 }
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.size)
}
func (v *XdrVec_unbounded_LedgerEntryChange) XdrPointer() interface{} { return (*[]LedgerEntryChange)(v) }
func (v *XdrVec_unbounded_LedgerEntryChange) XdrValue() interface{} { return ([]LedgerEntryChange)(*v) }
func XDR_LedgerEntryChanges(x XDR, name string, v *LedgerEntryChanges) {
	if xs, ok := x.(interface{
		Marshal_LedgerEntryChanges(string, *LedgerEntryChanges)
	}); ok {
		xs.Marshal_LedgerEntryChanges(name, v)
	} else {
		x.Marshal(name, (*XdrVec_unbounded_LedgerEntryChange)(v))
	}
}
func (v *OperationMeta) XdrPointer() interface{} {
	return v
}
func (v *OperationMeta) XdrValue() interface{} {
	return *v
}
func (v *OperationMeta) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_LedgerEntryChanges(x, x.Sprintf("%schanges", name), &v.Changes)
}
func XDR_OperationMeta(x XDR, name string, v *OperationMeta) {
	x.Marshal(name, v)
}
type XdrVec_unbounded_OperationMeta []OperationMeta
func (v *XdrVec_unbounded_OperationMeta) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (*XdrVec_unbounded_OperationMeta) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		xdrPanic("XdrVec_unbounded_OperationMeta length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		xdrPanic("XdrVec_unbounded_OperationMeta length %d exceeds max int", length)
	}
}
func (v *XdrVec_unbounded_OperationMeta) GetVecLen() uint32 { return uint32(len(*v)) }
func (v *XdrVec_unbounded_OperationMeta) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2*cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]OperationMeta, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *XdrVec_unbounded_OperationMeta) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if (i >= len(*v)) {
			v.SetVecLen(uint32(i+1))
		}
		XDR_OperationMeta(x, x.Sprintf("%s[%d]", name, i), &(*v)[i])
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *XdrVec_unbounded_OperationMeta) XdrMarshal(x XDR, name string) {
	size := XdrSize{ size: uint32(len(*v)), bound: 4294967295 }
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.size)
}
func (v *XdrVec_unbounded_OperationMeta) XdrPointer() interface{} { return (*[]OperationMeta)(v) }
func (v *XdrVec_unbounded_OperationMeta) XdrValue() interface{} { return ([]OperationMeta)(*v) }
func (v *TransactionMetaV1) XdrPointer() interface{} {
	return v
}
func (v *TransactionMetaV1) XdrValue() interface{} {
	return *v
}
func (v *TransactionMetaV1) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_LedgerEntryChanges(x, x.Sprintf("%stxChanges", name), &v.TxChanges)
	x.Marshal(x.Sprintf("%soperations", name), (*XdrVec_unbounded_OperationMeta)(&v.Operations))
}
func XDR_TransactionMetaV1(x XDR, name string, v *TransactionMetaV1) {
	x.Marshal(name, v)
}
func (u *TransactionMeta) Operations() *[]OperationMeta {
	switch u.V {
	case 0:
		if v, ok := u._u.(*[]OperationMeta); ok {
			return v
		} else {
			var zero []OperationMeta
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("TransactionMeta.Operations accessed when V == %v", u.V)
		return nil
	}
}
func (u *TransactionMeta) V1() *TransactionMetaV1 {
	switch u.V {
	case 1:
		if v, ok := u._u.(*TransactionMetaV1); ok {
			return v
		} else {
			var zero TransactionMetaV1
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("TransactionMeta.V1 accessed when V == %v", u.V)
		return nil
	}
}
func (u *TransactionMeta) XdrValid() bool {
	switch u.V {
	case 0,1:
		return true
	}
	return false
}
func (u *TransactionMeta) XdrUnionTag() interface{} {
	return &u.V
}
func (u *TransactionMeta) XdrUnionTagName() string {
	return "V"
}
func (u *TransactionMeta) XdrUnionBody() interface{} {
	switch u.V {
	case 0:
		return u.Operations()
	case 1:
		return u.V1()
	}
	return nil
}
func (u *TransactionMeta) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return "Operations"
	case 1:
		return "V1"
	}
	return ""
}
func (v *TransactionMeta) XdrPointer() interface{} {
	return v
}
func (v *TransactionMeta) XdrValue() interface{} {
	return *v
}
func (v *TransactionMeta) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(x, x.Sprintf("%sv", name), &v.V)
	switch v.V {
	case 0:
	x.Marshal(x.Sprintf("%soperations", name), (*XdrVec_unbounded_OperationMeta)(v.Operations()))
		return
	case 1:
	XDR_TransactionMetaV1(x, x.Sprintf("%sv1", name), v.V1())
		return
	}
	xdrPanic(fmt.Sprintf("invalid V (%v) in TransactionMeta", v.V))
}
func XDR_TransactionMeta(x XDR, name string, v *TransactionMeta) {
	x.Marshal(name, v)
}
func XDR_ErrorCode(x XDR, name string, v *ErrorCode) {
	x.Marshal(name, v)
}
var _XdrNames_ErrorCode = map[int32]string{
	int32(ERR_MISC): "ERR_MISC",
	int32(ERR_DATA): "ERR_DATA",
	int32(ERR_CONF): "ERR_CONF",
	int32(ERR_AUTH): "ERR_AUTH",
	int32(ERR_LOAD): "ERR_LOAD",
}
var _XdrValues_ErrorCode = map[string]int32{
	"ERR_MISC": int32(ERR_MISC),
	"ERR_DATA": int32(ERR_DATA),
	"ERR_CONF": int32(ERR_CONF),
	"ERR_AUTH": int32(ERR_AUTH),
	"ERR_LOAD": int32(ERR_LOAD),
}
func (*ErrorCode) XdrEnumNames() map[int32]string {
	return _XdrNames_ErrorCode
}
func (v *ErrorCode) String() string {
	if s, ok := _XdrNames_ErrorCode[int32(*v)]; ok {
		return s
	}
	return fmt.Sprintf("ErrorCode#%d", *v)
}
func (v *ErrorCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, xdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_ErrorCode[stok]; ok {
			*v = ErrorCode(val)
			return nil
		}
		return XdrError(fmt.Sprintf("%s is not a valid ErrorCode.", stok))
	}
}
func (v *ErrorCode) GetU32() uint32 {
	return uint32(*v)
}
func (v *ErrorCode) SetU32(n uint32) {
	*v = ErrorCode(n)
}
func (v *ErrorCode) XdrPointer() interface{} {
	return v
}
func (v *ErrorCode) XdrValue() interface{} {
	return *v
}
func (v *Error) XdrPointer() interface{} {
	return v
}
func (v *Error) XdrValue() interface{} {
	return *v
}
func (v *Error) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_ErrorCode(x, x.Sprintf("%scode", name), &v.Code)
	x.Marshal(x.Sprintf("%smsg", name), XdrString{&v.Msg, 100})
}
func XDR_Error(x XDR, name string, v *Error) {
	x.Marshal(name, v)
}
func (v *AuthCert) XdrPointer() interface{} {
	return v
}
func (v *AuthCert) XdrValue() interface{} {
	return *v
}
func (v *AuthCert) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Curve25519Public(x, x.Sprintf("%spubkey", name), &v.Pubkey)
	XDR_Uint64(x, x.Sprintf("%sexpiration", name), &v.Expiration)
	XDR_Signature(x, x.Sprintf("%ssig", name), &v.Sig)
}
func XDR_AuthCert(x XDR, name string, v *AuthCert) {
	x.Marshal(name, v)
}
func (v *Hello) XdrPointer() interface{} {
	return v
}
func (v *Hello) XdrValue() interface{} {
	return *v
}
func (v *Hello) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Uint32(x, x.Sprintf("%sledgerVersion", name), &v.LedgerVersion)
	XDR_Uint32(x, x.Sprintf("%soverlayVersion", name), &v.OverlayVersion)
	XDR_Uint32(x, x.Sprintf("%soverlayMinVersion", name), &v.OverlayMinVersion)
	XDR_Hash(x, x.Sprintf("%snetworkID", name), &v.NetworkID)
	x.Marshal(x.Sprintf("%sversionStr", name), XdrString{&v.VersionStr, 100})
	XDR_int32(x, x.Sprintf("%slisteningPort", name), &v.ListeningPort)
	XDR_NodeID(x, x.Sprintf("%speerID", name), &v.PeerID)
	XDR_AuthCert(x, x.Sprintf("%scert", name), &v.Cert)
	XDR_Uint256(x, x.Sprintf("%snonce", name), &v.Nonce)
}
func XDR_Hello(x XDR, name string, v *Hello) {
	x.Marshal(name, v)
}
func (v *Auth) XdrPointer() interface{} {
	return v
}
func (v *Auth) XdrValue() interface{} {
	return *v
}
func (v *Auth) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(x, x.Sprintf("%sunused", name), &v.Unused)
}
func XDR_Auth(x XDR, name string, v *Auth) {
	x.Marshal(name, v)
}
func XDR_IPAddrType(x XDR, name string, v *IPAddrType) {
	x.Marshal(name, v)
}
var _XdrNames_IPAddrType = map[int32]string{
	int32(IPv4): "IPv4",
	int32(IPv6): "IPv6",
}
var _XdrValues_IPAddrType = map[string]int32{
	"IPv4": int32(IPv4),
	"IPv6": int32(IPv6),
}
func (*IPAddrType) XdrEnumNames() map[int32]string {
	return _XdrNames_IPAddrType
}
func (v *IPAddrType) String() string {
	if s, ok := _XdrNames_IPAddrType[int32(*v)]; ok {
		return s
	}
	return fmt.Sprintf("IPAddrType#%d", *v)
}
func (v *IPAddrType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, xdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_IPAddrType[stok]; ok {
			*v = IPAddrType(val)
			return nil
		}
		return XdrError(fmt.Sprintf("%s is not a valid IPAddrType.", stok))
	}
}
func (v *IPAddrType) GetU32() uint32 {
	return uint32(*v)
}
func (v *IPAddrType) SetU32(n uint32) {
	*v = IPAddrType(n)
}
func (v *IPAddrType) XdrPointer() interface{} {
	return v
}
func (v *IPAddrType) XdrValue() interface{} {
	return *v
}
func (u *_PeerAddress_Ip) Ipv4() *[4]byte {
	switch u.Type {
	case IPv4:
		if v, ok := u._u.(*[4]byte); ok {
			return v
		} else {
			var zero [4]byte
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("_PeerAddress_Ip.Ipv4 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *_PeerAddress_Ip) Ipv6() *[16]byte {
	switch u.Type {
	case IPv6:
		if v, ok := u._u.(*[16]byte); ok {
			return v
		} else {
			var zero [16]byte
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("_PeerAddress_Ip.Ipv6 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *_PeerAddress_Ip) XdrValid() bool {
	switch u.Type {
	case IPv4,IPv6:
		return true
	}
	return false
}
func (u *_PeerAddress_Ip) XdrUnionTag() interface{} {
	return &u.Type
}
func (u *_PeerAddress_Ip) XdrUnionTagName() string {
	return "Type"
}
func (u *_PeerAddress_Ip) XdrUnionBody() interface{} {
	switch u.Type {
	case IPv4:
		return u.Ipv4()
	case IPv6:
		return u.Ipv6()
	}
	return nil
}
func (u *_PeerAddress_Ip) XdrUnionBodyName() string {
	switch u.Type {
	case IPv4:
		return "Ipv4"
	case IPv6:
		return "Ipv6"
	}
	return ""
}
func (v *_PeerAddress_Ip) XdrPointer() interface{} {
	return v
}
func (v *_PeerAddress_Ip) XdrValue() interface{} {
	return *v
}
func (v *_PeerAddress_Ip) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_IPAddrType(x, x.Sprintf("%stype", name), &v.Type)
	switch v.Type {
	case IPv4:
	x.Marshal(x.Sprintf("%sipv4", name), XdrArrayOpaque((*v.Ipv4())[:]))
		return
	case IPv6:
	x.Marshal(x.Sprintf("%sipv6", name), XdrArrayOpaque((*v.Ipv6())[:]))
		return
	}
	xdrPanic(fmt.Sprintf("invalid Type (%v) in _PeerAddress_Ip", v.Type))
}
func XDR__PeerAddress_Ip(x XDR, name string, v *_PeerAddress_Ip) {
	x.Marshal(name, v)
}
func (v *PeerAddress) XdrPointer() interface{} {
	return v
}
func (v *PeerAddress) XdrValue() interface{} {
	return *v
}
func (v *PeerAddress) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR__PeerAddress_Ip(x, x.Sprintf("%sip", name), &v.Ip)
	XDR_Uint32(x, x.Sprintf("%sport", name), &v.Port)
	XDR_Uint32(x, x.Sprintf("%snumFailures", name), &v.NumFailures)
}
func XDR_PeerAddress(x XDR, name string, v *PeerAddress) {
	x.Marshal(name, v)
}
func XDR_MessageType(x XDR, name string, v *MessageType) {
	x.Marshal(name, v)
}
var _XdrNames_MessageType = map[int32]string{
	int32(ERROR_MSG): "ERROR_MSG",
	int32(AUTH): "AUTH",
	int32(DONT_HAVE): "DONT_HAVE",
	int32(GET_PEERS): "GET_PEERS",
	int32(PEERS): "PEERS",
	int32(GET_TX_SET): "GET_TX_SET",
	int32(TX_SET): "TX_SET",
	int32(TRANSACTION): "TRANSACTION",
	int32(GET_SCP_QUORUMSET): "GET_SCP_QUORUMSET",
	int32(SCP_QUORUMSET): "SCP_QUORUMSET",
	int32(SCP_MESSAGE): "SCP_MESSAGE",
	int32(GET_SCP_STATE): "GET_SCP_STATE",
	int32(HELLO): "HELLO",
}
var _XdrValues_MessageType = map[string]int32{
	"ERROR_MSG": int32(ERROR_MSG),
	"AUTH": int32(AUTH),
	"DONT_HAVE": int32(DONT_HAVE),
	"GET_PEERS": int32(GET_PEERS),
	"PEERS": int32(PEERS),
	"GET_TX_SET": int32(GET_TX_SET),
	"TX_SET": int32(TX_SET),
	"TRANSACTION": int32(TRANSACTION),
	"GET_SCP_QUORUMSET": int32(GET_SCP_QUORUMSET),
	"SCP_QUORUMSET": int32(SCP_QUORUMSET),
	"SCP_MESSAGE": int32(SCP_MESSAGE),
	"GET_SCP_STATE": int32(GET_SCP_STATE),
	"HELLO": int32(HELLO),
}
func (*MessageType) XdrEnumNames() map[int32]string {
	return _XdrNames_MessageType
}
func (v *MessageType) String() string {
	if s, ok := _XdrNames_MessageType[int32(*v)]; ok {
		return s
	}
	return fmt.Sprintf("MessageType#%d", *v)
}
func (v *MessageType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, xdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_MessageType[stok]; ok {
			*v = MessageType(val)
			return nil
		}
		return XdrError(fmt.Sprintf("%s is not a valid MessageType.", stok))
	}
}
func (v *MessageType) GetU32() uint32 {
	return uint32(*v)
}
func (v *MessageType) SetU32(n uint32) {
	*v = MessageType(n)
}
func (v *MessageType) XdrPointer() interface{} {
	return v
}
func (v *MessageType) XdrValue() interface{} {
	return *v
}
func (v *DontHave) XdrPointer() interface{} {
	return v
}
func (v *DontHave) XdrValue() interface{} {
	return *v
}
func (v *DontHave) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_MessageType(x, x.Sprintf("%stype", name), &v.Type)
	XDR_Uint256(x, x.Sprintf("%sreqHash", name), &v.ReqHash)
}
func XDR_DontHave(x XDR, name string, v *DontHave) {
	x.Marshal(name, v)
}
type XdrVec_100_PeerAddress []PeerAddress
func (v *XdrVec_100_PeerAddress) XdrBound() uint32 {
	const bound uint32 = 100 // Force error if not const or doesn't fit
	return bound
}
func (*XdrVec_100_PeerAddress) XdrCheckLen(length uint32) {
	if length > uint32(100) {
		xdrPanic("XdrVec_100_PeerAddress length %d exceeds bound 100", length)
	} else if int(length) < 0 {
		xdrPanic("XdrVec_100_PeerAddress length %d exceeds max int", length)
	}
}
func (v *XdrVec_100_PeerAddress) GetVecLen() uint32 { return uint32(len(*v)) }
func (v *XdrVec_100_PeerAddress) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2*cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(100); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]PeerAddress, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *XdrVec_100_PeerAddress) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if (i >= len(*v)) {
			v.SetVecLen(uint32(i+1))
		}
		XDR_PeerAddress(x, x.Sprintf("%s[%d]", name, i), &(*v)[i])
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *XdrVec_100_PeerAddress) XdrMarshal(x XDR, name string) {
	size := XdrSize{ size: uint32(len(*v)), bound: 100 }
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.size)
}
func (v *XdrVec_100_PeerAddress) XdrPointer() interface{} { return (*[]PeerAddress)(v) }
func (v *XdrVec_100_PeerAddress) XdrValue() interface{} { return ([]PeerAddress)(*v) }
func (u *StellarMessage) Error() *Error {
	switch u.Type {
	case ERROR_MSG:
		if v, ok := u._u.(*Error); ok {
			return v
		} else {
			var zero Error
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("StellarMessage.Error accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *StellarMessage) Hello() *Hello {
	switch u.Type {
	case HELLO:
		if v, ok := u._u.(*Hello); ok {
			return v
		} else {
			var zero Hello
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("StellarMessage.Hello accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *StellarMessage) Auth() *Auth {
	switch u.Type {
	case AUTH:
		if v, ok := u._u.(*Auth); ok {
			return v
		} else {
			var zero Auth
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("StellarMessage.Auth accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *StellarMessage) DontHave() *DontHave {
	switch u.Type {
	case DONT_HAVE:
		if v, ok := u._u.(*DontHave); ok {
			return v
		} else {
			var zero DontHave
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("StellarMessage.DontHave accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *StellarMessage) Peers() *[]PeerAddress {
	switch u.Type {
	case PEERS:
		if v, ok := u._u.(*[]PeerAddress); ok {
			return v
		} else {
			var zero []PeerAddress
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("StellarMessage.Peers accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *StellarMessage) TxSetHash() *Uint256 {
	switch u.Type {
	case GET_TX_SET:
		if v, ok := u._u.(*Uint256); ok {
			return v
		} else {
			var zero Uint256
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("StellarMessage.TxSetHash accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *StellarMessage) TxSet() *TransactionSet {
	switch u.Type {
	case TX_SET:
		if v, ok := u._u.(*TransactionSet); ok {
			return v
		} else {
			var zero TransactionSet
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("StellarMessage.TxSet accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *StellarMessage) Transaction() *TransactionEnvelope {
	switch u.Type {
	case TRANSACTION:
		if v, ok := u._u.(*TransactionEnvelope); ok {
			return v
		} else {
			var zero TransactionEnvelope
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("StellarMessage.Transaction accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *StellarMessage) QSetHash() *Uint256 {
	switch u.Type {
	case GET_SCP_QUORUMSET:
		if v, ok := u._u.(*Uint256); ok {
			return v
		} else {
			var zero Uint256
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("StellarMessage.QSetHash accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *StellarMessage) QSet() *SCPQuorumSet {
	switch u.Type {
	case SCP_QUORUMSET:
		if v, ok := u._u.(*SCPQuorumSet); ok {
			return v
		} else {
			var zero SCPQuorumSet
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("StellarMessage.QSet accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *StellarMessage) Envelope() *SCPEnvelope {
	switch u.Type {
	case SCP_MESSAGE:
		if v, ok := u._u.(*SCPEnvelope); ok {
			return v
		} else {
			var zero SCPEnvelope
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("StellarMessage.Envelope accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *StellarMessage) GetSCPLedgerSeq() *Uint32 {
	switch u.Type {
	case GET_SCP_STATE:
		if v, ok := u._u.(*Uint32); ok {
			return v
		} else {
			var zero Uint32
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("StellarMessage.GetSCPLedgerSeq accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *StellarMessage) XdrValid() bool {
	switch u.Type {
	case ERROR_MSG,HELLO,AUTH,DONT_HAVE,GET_PEERS,PEERS,GET_TX_SET,TX_SET,TRANSACTION,GET_SCP_QUORUMSET,SCP_QUORUMSET,SCP_MESSAGE,GET_SCP_STATE:
		return true
	}
	return false
}
func (u *StellarMessage) XdrUnionTag() interface{} {
	return &u.Type
}
func (u *StellarMessage) XdrUnionTagName() string {
	return "Type"
}
func (u *StellarMessage) XdrUnionBody() interface{} {
	switch u.Type {
	case ERROR_MSG:
		return u.Error()
	case HELLO:
		return u.Hello()
	case AUTH:
		return u.Auth()
	case DONT_HAVE:
		return u.DontHave()
	case GET_PEERS:
		return nil
	case PEERS:
		return u.Peers()
	case GET_TX_SET:
		return u.TxSetHash()
	case TX_SET:
		return u.TxSet()
	case TRANSACTION:
		return u.Transaction()
	case GET_SCP_QUORUMSET:
		return u.QSetHash()
	case SCP_QUORUMSET:
		return u.QSet()
	case SCP_MESSAGE:
		return u.Envelope()
	case GET_SCP_STATE:
		return u.GetSCPLedgerSeq()
	}
	return nil
}
func (u *StellarMessage) XdrUnionBodyName() string {
	switch u.Type {
	case ERROR_MSG:
		return "Error"
	case HELLO:
		return "Hello"
	case AUTH:
		return "Auth"
	case DONT_HAVE:
		return "DontHave"
	case GET_PEERS:
		return ""
	case PEERS:
		return "Peers"
	case GET_TX_SET:
		return "TxSetHash"
	case TX_SET:
		return "TxSet"
	case TRANSACTION:
		return "Transaction"
	case GET_SCP_QUORUMSET:
		return "QSetHash"
	case SCP_QUORUMSET:
		return "QSet"
	case SCP_MESSAGE:
		return "Envelope"
	case GET_SCP_STATE:
		return "GetSCPLedgerSeq"
	}
	return ""
}
func (v *StellarMessage) XdrPointer() interface{} {
	return v
}
func (v *StellarMessage) XdrValue() interface{} {
	return *v
}
func (v *StellarMessage) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_MessageType(x, x.Sprintf("%stype", name), &v.Type)
	switch v.Type {
	case ERROR_MSG:
	XDR_Error(x, x.Sprintf("%serror", name), v.Error())
		return
	case HELLO:
	XDR_Hello(x, x.Sprintf("%shello", name), v.Hello())
		return
	case AUTH:
	XDR_Auth(x, x.Sprintf("%sauth", name), v.Auth())
		return
	case DONT_HAVE:
	XDR_DontHave(x, x.Sprintf("%sdontHave", name), v.DontHave())
		return
	case GET_PEERS:
		return
	case PEERS:
	x.Marshal(x.Sprintf("%speers", name), (*XdrVec_100_PeerAddress)(v.Peers()))
		return
	case GET_TX_SET:
	XDR_Uint256(x, x.Sprintf("%stxSetHash", name), v.TxSetHash())
		return
	case TX_SET:
	XDR_TransactionSet(x, x.Sprintf("%stxSet", name), v.TxSet())
		return
	case TRANSACTION:
	XDR_TransactionEnvelope(x, x.Sprintf("%stransaction", name), v.Transaction())
		return
	case GET_SCP_QUORUMSET:
	XDR_Uint256(x, x.Sprintf("%sqSetHash", name), v.QSetHash())
		return
	case SCP_QUORUMSET:
	XDR_SCPQuorumSet(x, x.Sprintf("%sqSet", name), v.QSet())
		return
	case SCP_MESSAGE:
	XDR_SCPEnvelope(x, x.Sprintf("%senvelope", name), v.Envelope())
		return
	case GET_SCP_STATE:
	XDR_Uint32(x, x.Sprintf("%sgetSCPLedgerSeq", name), v.GetSCPLedgerSeq())
		return
	}
	xdrPanic(fmt.Sprintf("invalid Type (%v) in StellarMessage", v.Type))
}
func XDR_StellarMessage(x XDR, name string, v *StellarMessage) {
	x.Marshal(name, v)
}
func (v *_AuthenticatedMessage_V0) XdrPointer() interface{} {
	return v
}
func (v *_AuthenticatedMessage_V0) XdrValue() interface{} {
	return *v
}
func (v *_AuthenticatedMessage_V0) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Uint64(x, x.Sprintf("%ssequence", name), &v.Sequence)
	XDR_StellarMessage(x, x.Sprintf("%smessage", name), &v.Message)
	XDR_HmacSha256Mac(x, x.Sprintf("%smac", name), &v.Mac)
}
func XDR__AuthenticatedMessage_V0(x XDR, name string, v *_AuthenticatedMessage_V0) {
	x.Marshal(name, v)
}
func (u *AuthenticatedMessage) V0() *_AuthenticatedMessage_V0 {
	switch u.V {
	case 0:
		if v, ok := u._u.(*_AuthenticatedMessage_V0); ok {
			return v
		} else {
			var zero _AuthenticatedMessage_V0
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("AuthenticatedMessage.V0 accessed when V == %v", u.V)
		return nil
	}
}
func (u *AuthenticatedMessage) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *AuthenticatedMessage) XdrUnionTag() interface{} {
	return &u.V
}
func (u *AuthenticatedMessage) XdrUnionTagName() string {
	return "V"
}
func (u *AuthenticatedMessage) XdrUnionBody() interface{} {
	switch u.V {
	case 0:
		return u.V0()
	}
	return nil
}
func (u *AuthenticatedMessage) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return "V0"
	}
	return ""
}
func (v *AuthenticatedMessage) XdrPointer() interface{} {
	return v
}
func (v *AuthenticatedMessage) XdrValue() interface{} {
	return *v
}
func (v *AuthenticatedMessage) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Uint32(x, x.Sprintf("%sv", name), &v.V)
	switch v.V {
	case 0:
	XDR__AuthenticatedMessage_V0(x, x.Sprintf("%sv0", name), v.V0())
		return
	}
	xdrPanic(fmt.Sprintf("invalid V (%v) in AuthenticatedMessage", v.V))
}
func XDR_AuthenticatedMessage(x XDR, name string, v *AuthenticatedMessage) {
	x.Marshal(name, v)
}
func (v *DecoratedSignature) XdrPointer() interface{} {
	return v
}
func (v *DecoratedSignature) XdrValue() interface{} {
	return *v
}
func (v *DecoratedSignature) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_SignatureHint(x, x.Sprintf("%shint", name), &v.Hint)
	XDR_Signature(x, x.Sprintf("%ssignature", name), &v.Signature)
}
func XDR_DecoratedSignature(x XDR, name string, v *DecoratedSignature) {
	x.Marshal(name, v)
}
func XDR_OperationType(x XDR, name string, v *OperationType) {
	x.Marshal(name, v)
}
var _XdrNames_OperationType = map[int32]string{
	int32(CREATE_ACCOUNT): "CREATE_ACCOUNT",
	int32(PAYMENT): "PAYMENT",
	int32(PATH_PAYMENT): "PATH_PAYMENT",
	int32(MANAGE_OFFER): "MANAGE_OFFER",
	int32(CREATE_PASSIVE_OFFER): "CREATE_PASSIVE_OFFER",
	int32(SET_OPTIONS): "SET_OPTIONS",
	int32(CHANGE_TRUST): "CHANGE_TRUST",
	int32(ALLOW_TRUST): "ALLOW_TRUST",
	int32(ACCOUNT_MERGE): "ACCOUNT_MERGE",
	int32(INFLATION): "INFLATION",
	int32(MANAGE_DATA): "MANAGE_DATA",
	int32(BUMP_SEQUENCE): "BUMP_SEQUENCE",
}
var _XdrValues_OperationType = map[string]int32{
	"CREATE_ACCOUNT": int32(CREATE_ACCOUNT),
	"PAYMENT": int32(PAYMENT),
	"PATH_PAYMENT": int32(PATH_PAYMENT),
	"MANAGE_OFFER": int32(MANAGE_OFFER),
	"CREATE_PASSIVE_OFFER": int32(CREATE_PASSIVE_OFFER),
	"SET_OPTIONS": int32(SET_OPTIONS),
	"CHANGE_TRUST": int32(CHANGE_TRUST),
	"ALLOW_TRUST": int32(ALLOW_TRUST),
	"ACCOUNT_MERGE": int32(ACCOUNT_MERGE),
	"INFLATION": int32(INFLATION),
	"MANAGE_DATA": int32(MANAGE_DATA),
	"BUMP_SEQUENCE": int32(BUMP_SEQUENCE),
}
func (*OperationType) XdrEnumNames() map[int32]string {
	return _XdrNames_OperationType
}
func (v *OperationType) String() string {
	if s, ok := _XdrNames_OperationType[int32(*v)]; ok {
		return s
	}
	return fmt.Sprintf("OperationType#%d", *v)
}
func (v *OperationType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, xdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_OperationType[stok]; ok {
			*v = OperationType(val)
			return nil
		}
		return XdrError(fmt.Sprintf("%s is not a valid OperationType.", stok))
	}
}
func (v *OperationType) GetU32() uint32 {
	return uint32(*v)
}
func (v *OperationType) SetU32(n uint32) {
	*v = OperationType(n)
}
func (v *OperationType) XdrPointer() interface{} {
	return v
}
func (v *OperationType) XdrValue() interface{} {
	return *v
}
func (v *CreateAccountOp) XdrPointer() interface{} {
	return v
}
func (v *CreateAccountOp) XdrValue() interface{} {
	return *v
}
func (v *CreateAccountOp) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_AccountID(x, x.Sprintf("%sdestination", name), &v.Destination)
	XDR_Int64(x, x.Sprintf("%sstartingBalance", name), &v.StartingBalance)
}
func XDR_CreateAccountOp(x XDR, name string, v *CreateAccountOp) {
	x.Marshal(name, v)
}
func (v *PaymentOp) XdrPointer() interface{} {
	return v
}
func (v *PaymentOp) XdrValue() interface{} {
	return *v
}
func (v *PaymentOp) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_AccountID(x, x.Sprintf("%sdestination", name), &v.Destination)
	XDR_Asset(x, x.Sprintf("%sasset", name), &v.Asset)
	XDR_Int64(x, x.Sprintf("%samount", name), &v.Amount)
}
func XDR_PaymentOp(x XDR, name string, v *PaymentOp) {
	x.Marshal(name, v)
}
type XdrVec_5_Asset []Asset
func (v *XdrVec_5_Asset) XdrBound() uint32 {
	const bound uint32 = 5 // Force error if not const or doesn't fit
	return bound
}
func (*XdrVec_5_Asset) XdrCheckLen(length uint32) {
	if length > uint32(5) {
		xdrPanic("XdrVec_5_Asset length %d exceeds bound 5", length)
	} else if int(length) < 0 {
		xdrPanic("XdrVec_5_Asset length %d exceeds max int", length)
	}
}
func (v *XdrVec_5_Asset) GetVecLen() uint32 { return uint32(len(*v)) }
func (v *XdrVec_5_Asset) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2*cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(5); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]Asset, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *XdrVec_5_Asset) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if (i >= len(*v)) {
			v.SetVecLen(uint32(i+1))
		}
		XDR_Asset(x, x.Sprintf("%s[%d]", name, i), &(*v)[i])
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *XdrVec_5_Asset) XdrMarshal(x XDR, name string) {
	size := XdrSize{ size: uint32(len(*v)), bound: 5 }
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.size)
}
func (v *XdrVec_5_Asset) XdrPointer() interface{} { return (*[]Asset)(v) }
func (v *XdrVec_5_Asset) XdrValue() interface{} { return ([]Asset)(*v) }
func (v *PathPaymentOp) XdrPointer() interface{} {
	return v
}
func (v *PathPaymentOp) XdrValue() interface{} {
	return *v
}
func (v *PathPaymentOp) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Asset(x, x.Sprintf("%ssendAsset", name), &v.SendAsset)
	XDR_Int64(x, x.Sprintf("%ssendMax", name), &v.SendMax)
	XDR_AccountID(x, x.Sprintf("%sdestination", name), &v.Destination)
	XDR_Asset(x, x.Sprintf("%sdestAsset", name), &v.DestAsset)
	XDR_Int64(x, x.Sprintf("%sdestAmount", name), &v.DestAmount)
	x.Marshal(x.Sprintf("%spath", name), (*XdrVec_5_Asset)(&v.Path))
}
func XDR_PathPaymentOp(x XDR, name string, v *PathPaymentOp) {
	x.Marshal(name, v)
}
func (v *ManageOfferOp) XdrPointer() interface{} {
	return v
}
func (v *ManageOfferOp) XdrValue() interface{} {
	return *v
}
func (v *ManageOfferOp) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Asset(x, x.Sprintf("%sselling", name), &v.Selling)
	XDR_Asset(x, x.Sprintf("%sbuying", name), &v.Buying)
	XDR_Int64(x, x.Sprintf("%samount", name), &v.Amount)
	XDR_Price(x, x.Sprintf("%sprice", name), &v.Price)
	XDR_Uint64(x, x.Sprintf("%sofferID", name), &v.OfferID)
}
func XDR_ManageOfferOp(x XDR, name string, v *ManageOfferOp) {
	x.Marshal(name, v)
}
func (v *CreatePassiveOfferOp) XdrPointer() interface{} {
	return v
}
func (v *CreatePassiveOfferOp) XdrValue() interface{} {
	return *v
}
func (v *CreatePassiveOfferOp) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Asset(x, x.Sprintf("%sselling", name), &v.Selling)
	XDR_Asset(x, x.Sprintf("%sbuying", name), &v.Buying)
	XDR_Int64(x, x.Sprintf("%samount", name), &v.Amount)
	XDR_Price(x, x.Sprintf("%sprice", name), &v.Price)
}
func XDR_CreatePassiveOfferOp(x XDR, name string, v *CreatePassiveOfferOp) {
	x.Marshal(name, v)
}
type XdrPtr_Uint32 struct {
	p **Uint32
}
type _ptrflag_Uint32 XdrPtr_Uint32
func (v _ptrflag_Uint32) String() string {
	if *v.p == nil {
		return "nil"
	}
	return "non-nil"
}
func (v _ptrflag_Uint32) GetU32() uint32 {
	if *v.p == nil {
		return 0
	}
	return 1
}
func (v _ptrflag_Uint32) SetU32(nv uint32) {
	switch nv {
	case 0:
		*v.p = nil
	case 1:
		if *v.p == nil {
			*v.p = new(Uint32)
		}
	default:
		xdrPanic("*Uint32 present flag value %d should be 0 or 1", nv)
	}
}
func (v _ptrflag_Uint32) XdrPointer() interface{} { return nil }
func (v _ptrflag_Uint32) XdrValue() interface{} { return v.GetU32() != 0 }
func (v _ptrflag_Uint32) XdrBound() uint32 { return 1 }
func (v XdrPtr_Uint32) GetPresent() bool { return *v.p != nil }
func (v XdrPtr_Uint32) SetPresent(present bool) {
	if !present {
		*v.p = nil
	} else if *v.p == nil {
		*v.p = new(Uint32)
	}
}
func (v XdrPtr_Uint32) XdrMarshalValue(x XDR, name string) {
	if *v.p != nil {
		XDR_Uint32(x, name, *v.p)
	}
}
func (v XdrPtr_Uint32) XdrMarshal(x XDR, name string) {
	x.Marshal(name, _ptrflag_Uint32(v))
	v.XdrMarshalValue(x, name)
}
func (v XdrPtr_Uint32) XdrPointer() interface{} { return v.p }
func (v XdrPtr_Uint32) XdrValue() interface{} { return *v.p }
type XdrPtr_String32 struct {
	p **String32
}
type _ptrflag_String32 XdrPtr_String32
func (v _ptrflag_String32) String() string {
	if *v.p == nil {
		return "nil"
	}
	return "non-nil"
}
func (v _ptrflag_String32) GetU32() uint32 {
	if *v.p == nil {
		return 0
	}
	return 1
}
func (v _ptrflag_String32) SetU32(nv uint32) {
	switch nv {
	case 0:
		*v.p = nil
	case 1:
		if *v.p == nil {
			*v.p = new(String32)
		}
	default:
		xdrPanic("*String32 present flag value %d should be 0 or 1", nv)
	}
}
func (v _ptrflag_String32) XdrPointer() interface{} { return nil }
func (v _ptrflag_String32) XdrValue() interface{} { return v.GetU32() != 0 }
func (v _ptrflag_String32) XdrBound() uint32 { return 1 }
func (v XdrPtr_String32) GetPresent() bool { return *v.p != nil }
func (v XdrPtr_String32) SetPresent(present bool) {
	if !present {
		*v.p = nil
	} else if *v.p == nil {
		*v.p = new(String32)
	}
}
func (v XdrPtr_String32) XdrMarshalValue(x XDR, name string) {
	if *v.p != nil {
		XDR_String32(x, name, *v.p)
	}
}
func (v XdrPtr_String32) XdrMarshal(x XDR, name string) {
	x.Marshal(name, _ptrflag_String32(v))
	v.XdrMarshalValue(x, name)
}
func (v XdrPtr_String32) XdrPointer() interface{} { return v.p }
func (v XdrPtr_String32) XdrValue() interface{} { return *v.p }
type XdrPtr_Signer struct {
	p **Signer
}
type _ptrflag_Signer XdrPtr_Signer
func (v _ptrflag_Signer) String() string {
	if *v.p == nil {
		return "nil"
	}
	return "non-nil"
}
func (v _ptrflag_Signer) GetU32() uint32 {
	if *v.p == nil {
		return 0
	}
	return 1
}
func (v _ptrflag_Signer) SetU32(nv uint32) {
	switch nv {
	case 0:
		*v.p = nil
	case 1:
		if *v.p == nil {
			*v.p = new(Signer)
		}
	default:
		xdrPanic("*Signer present flag value %d should be 0 or 1", nv)
	}
}
func (v _ptrflag_Signer) XdrPointer() interface{} { return nil }
func (v _ptrflag_Signer) XdrValue() interface{} { return v.GetU32() != 0 }
func (v _ptrflag_Signer) XdrBound() uint32 { return 1 }
func (v XdrPtr_Signer) GetPresent() bool { return *v.p != nil }
func (v XdrPtr_Signer) SetPresent(present bool) {
	if !present {
		*v.p = nil
	} else if *v.p == nil {
		*v.p = new(Signer)
	}
}
func (v XdrPtr_Signer) XdrMarshalValue(x XDR, name string) {
	if *v.p != nil {
		XDR_Signer(x, name, *v.p)
	}
}
func (v XdrPtr_Signer) XdrMarshal(x XDR, name string) {
	x.Marshal(name, _ptrflag_Signer(v))
	v.XdrMarshalValue(x, name)
}
func (v XdrPtr_Signer) XdrPointer() interface{} { return v.p }
func (v XdrPtr_Signer) XdrValue() interface{} { return *v.p }
func (v *SetOptionsOp) XdrPointer() interface{} {
	return v
}
func (v *SetOptionsOp) XdrValue() interface{} {
	return *v
}
func (v *SetOptionsOp) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sinflationDest", name), XdrPtr_AccountID{&v.InflationDest})
	x.Marshal(x.Sprintf("%sclearFlags", name), XdrPtr_Uint32{&v.ClearFlags})
	x.Marshal(x.Sprintf("%ssetFlags", name), XdrPtr_Uint32{&v.SetFlags})
	x.Marshal(x.Sprintf("%smasterWeight", name), XdrPtr_Uint32{&v.MasterWeight})
	x.Marshal(x.Sprintf("%slowThreshold", name), XdrPtr_Uint32{&v.LowThreshold})
	x.Marshal(x.Sprintf("%smedThreshold", name), XdrPtr_Uint32{&v.MedThreshold})
	x.Marshal(x.Sprintf("%shighThreshold", name), XdrPtr_Uint32{&v.HighThreshold})
	x.Marshal(x.Sprintf("%shomeDomain", name), XdrPtr_String32{&v.HomeDomain})
	x.Marshal(x.Sprintf("%ssigner", name), XdrPtr_Signer{&v.Signer})
}
func XDR_SetOptionsOp(x XDR, name string, v *SetOptionsOp) {
	x.Marshal(name, v)
}
func (v *ChangeTrustOp) XdrPointer() interface{} {
	return v
}
func (v *ChangeTrustOp) XdrValue() interface{} {
	return *v
}
func (v *ChangeTrustOp) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Asset(x, x.Sprintf("%sline", name), &v.Line)
	XDR_Int64(x, x.Sprintf("%slimit", name), &v.Limit)
}
func XDR_ChangeTrustOp(x XDR, name string, v *ChangeTrustOp) {
	x.Marshal(name, v)
}
func (u *_AllowTrustOp_Asset) AssetCode4() *[4]byte {
	switch u.Type {
	case ASSET_TYPE_CREDIT_ALPHANUM4:
		if v, ok := u._u.(*[4]byte); ok {
			return v
		} else {
			var zero [4]byte
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("_AllowTrustOp_Asset.AssetCode4 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *_AllowTrustOp_Asset) AssetCode12() *[12]byte {
	switch u.Type {
	case ASSET_TYPE_CREDIT_ALPHANUM12:
		if v, ok := u._u.(*[12]byte); ok {
			return v
		} else {
			var zero [12]byte
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("_AllowTrustOp_Asset.AssetCode12 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *_AllowTrustOp_Asset) XdrValid() bool {
	switch u.Type {
	case ASSET_TYPE_CREDIT_ALPHANUM4,ASSET_TYPE_CREDIT_ALPHANUM12:
		return true
	}
	return false
}
func (u *_AllowTrustOp_Asset) XdrUnionTag() interface{} {
	return &u.Type
}
func (u *_AllowTrustOp_Asset) XdrUnionTagName() string {
	return "Type"
}
func (u *_AllowTrustOp_Asset) XdrUnionBody() interface{} {
	switch u.Type {
	case ASSET_TYPE_CREDIT_ALPHANUM4:
		return u.AssetCode4()
	case ASSET_TYPE_CREDIT_ALPHANUM12:
		return u.AssetCode12()
	}
	return nil
}
func (u *_AllowTrustOp_Asset) XdrUnionBodyName() string {
	switch u.Type {
	case ASSET_TYPE_CREDIT_ALPHANUM4:
		return "AssetCode4"
	case ASSET_TYPE_CREDIT_ALPHANUM12:
		return "AssetCode12"
	}
	return ""
}
func (v *_AllowTrustOp_Asset) XdrPointer() interface{} {
	return v
}
func (v *_AllowTrustOp_Asset) XdrValue() interface{} {
	return *v
}
func (v *_AllowTrustOp_Asset) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_AssetType(x, x.Sprintf("%stype", name), &v.Type)
	switch v.Type {
	case ASSET_TYPE_CREDIT_ALPHANUM4:
	x.Marshal(x.Sprintf("%sassetCode4", name), XdrArrayOpaque((*v.AssetCode4())[:]))
		return
	case ASSET_TYPE_CREDIT_ALPHANUM12:
	x.Marshal(x.Sprintf("%sassetCode12", name), XdrArrayOpaque((*v.AssetCode12())[:]))
		return
	}
	xdrPanic(fmt.Sprintf("invalid Type (%v) in _AllowTrustOp_Asset", v.Type))
}
func XDR__AllowTrustOp_Asset(x XDR, name string, v *_AllowTrustOp_Asset) {
	x.Marshal(name, v)
}
func (v *AllowTrustOp) XdrPointer() interface{} {
	return v
}
func (v *AllowTrustOp) XdrValue() interface{} {
	return *v
}
func (v *AllowTrustOp) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_AccountID(x, x.Sprintf("%strustor", name), &v.Trustor)
	XDR__AllowTrustOp_Asset(x, x.Sprintf("%sasset", name), &v.Asset)
	XDR_bool(x, x.Sprintf("%sauthorize", name), &v.Authorize)
}
func XDR_AllowTrustOp(x XDR, name string, v *AllowTrustOp) {
	x.Marshal(name, v)
}
type XdrPtr_DataValue struct {
	p **DataValue
}
type _ptrflag_DataValue XdrPtr_DataValue
func (v _ptrflag_DataValue) String() string {
	if *v.p == nil {
		return "nil"
	}
	return "non-nil"
}
func (v _ptrflag_DataValue) GetU32() uint32 {
	if *v.p == nil {
		return 0
	}
	return 1
}
func (v _ptrflag_DataValue) SetU32(nv uint32) {
	switch nv {
	case 0:
		*v.p = nil
	case 1:
		if *v.p == nil {
			*v.p = new(DataValue)
		}
	default:
		xdrPanic("*DataValue present flag value %d should be 0 or 1", nv)
	}
}
func (v _ptrflag_DataValue) XdrPointer() interface{} { return nil }
func (v _ptrflag_DataValue) XdrValue() interface{} { return v.GetU32() != 0 }
func (v _ptrflag_DataValue) XdrBound() uint32 { return 1 }
func (v XdrPtr_DataValue) GetPresent() bool { return *v.p != nil }
func (v XdrPtr_DataValue) SetPresent(present bool) {
	if !present {
		*v.p = nil
	} else if *v.p == nil {
		*v.p = new(DataValue)
	}
}
func (v XdrPtr_DataValue) XdrMarshalValue(x XDR, name string) {
	if *v.p != nil {
		XDR_DataValue(x, name, *v.p)
	}
}
func (v XdrPtr_DataValue) XdrMarshal(x XDR, name string) {
	x.Marshal(name, _ptrflag_DataValue(v))
	v.XdrMarshalValue(x, name)
}
func (v XdrPtr_DataValue) XdrPointer() interface{} { return v.p }
func (v XdrPtr_DataValue) XdrValue() interface{} { return *v.p }
func (v *ManageDataOp) XdrPointer() interface{} {
	return v
}
func (v *ManageDataOp) XdrValue() interface{} {
	return *v
}
func (v *ManageDataOp) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_String64(x, x.Sprintf("%sdataName", name), &v.DataName)
	x.Marshal(x.Sprintf("%sdataValue", name), XdrPtr_DataValue{&v.DataValue})
}
func XDR_ManageDataOp(x XDR, name string, v *ManageDataOp) {
	x.Marshal(name, v)
}
func (v *BumpSequenceOp) XdrPointer() interface{} {
	return v
}
func (v *BumpSequenceOp) XdrValue() interface{} {
	return *v
}
func (v *BumpSequenceOp) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_SequenceNumber(x, x.Sprintf("%sbumpTo", name), &v.BumpTo)
}
func XDR_BumpSequenceOp(x XDR, name string, v *BumpSequenceOp) {
	x.Marshal(name, v)
}
func (u *_Operation_Body) CreateAccountOp() *CreateAccountOp {
	switch u.Type {
	case CREATE_ACCOUNT:
		if v, ok := u._u.(*CreateAccountOp); ok {
			return v
		} else {
			var zero CreateAccountOp
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("_Operation_Body.CreateAccountOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *_Operation_Body) PaymentOp() *PaymentOp {
	switch u.Type {
	case PAYMENT:
		if v, ok := u._u.(*PaymentOp); ok {
			return v
		} else {
			var zero PaymentOp
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("_Operation_Body.PaymentOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *_Operation_Body) PathPaymentOp() *PathPaymentOp {
	switch u.Type {
	case PATH_PAYMENT:
		if v, ok := u._u.(*PathPaymentOp); ok {
			return v
		} else {
			var zero PathPaymentOp
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("_Operation_Body.PathPaymentOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *_Operation_Body) ManageOfferOp() *ManageOfferOp {
	switch u.Type {
	case MANAGE_OFFER:
		if v, ok := u._u.(*ManageOfferOp); ok {
			return v
		} else {
			var zero ManageOfferOp
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("_Operation_Body.ManageOfferOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *_Operation_Body) CreatePassiveOfferOp() *CreatePassiveOfferOp {
	switch u.Type {
	case CREATE_PASSIVE_OFFER:
		if v, ok := u._u.(*CreatePassiveOfferOp); ok {
			return v
		} else {
			var zero CreatePassiveOfferOp
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("_Operation_Body.CreatePassiveOfferOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *_Operation_Body) SetOptionsOp() *SetOptionsOp {
	switch u.Type {
	case SET_OPTIONS:
		if v, ok := u._u.(*SetOptionsOp); ok {
			return v
		} else {
			var zero SetOptionsOp
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("_Operation_Body.SetOptionsOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *_Operation_Body) ChangeTrustOp() *ChangeTrustOp {
	switch u.Type {
	case CHANGE_TRUST:
		if v, ok := u._u.(*ChangeTrustOp); ok {
			return v
		} else {
			var zero ChangeTrustOp
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("_Operation_Body.ChangeTrustOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *_Operation_Body) AllowTrustOp() *AllowTrustOp {
	switch u.Type {
	case ALLOW_TRUST:
		if v, ok := u._u.(*AllowTrustOp); ok {
			return v
		} else {
			var zero AllowTrustOp
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("_Operation_Body.AllowTrustOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *_Operation_Body) Destination() *AccountID {
	switch u.Type {
	case ACCOUNT_MERGE:
		if v, ok := u._u.(*AccountID); ok {
			return v
		} else {
			var zero AccountID
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("_Operation_Body.Destination accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *_Operation_Body) ManageDataOp() *ManageDataOp {
	switch u.Type {
	case MANAGE_DATA:
		if v, ok := u._u.(*ManageDataOp); ok {
			return v
		} else {
			var zero ManageDataOp
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("_Operation_Body.ManageDataOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *_Operation_Body) BumpSequenceOp() *BumpSequenceOp {
	switch u.Type {
	case BUMP_SEQUENCE:
		if v, ok := u._u.(*BumpSequenceOp); ok {
			return v
		} else {
			var zero BumpSequenceOp
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("_Operation_Body.BumpSequenceOp accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *_Operation_Body) XdrValid() bool {
	switch u.Type {
	case CREATE_ACCOUNT,PAYMENT,PATH_PAYMENT,MANAGE_OFFER,CREATE_PASSIVE_OFFER,SET_OPTIONS,CHANGE_TRUST,ALLOW_TRUST,ACCOUNT_MERGE,INFLATION,MANAGE_DATA,BUMP_SEQUENCE:
		return true
	}
	return false
}
func (u *_Operation_Body) XdrUnionTag() interface{} {
	return &u.Type
}
func (u *_Operation_Body) XdrUnionTagName() string {
	return "Type"
}
func (u *_Operation_Body) XdrUnionBody() interface{} {
	switch u.Type {
	case CREATE_ACCOUNT:
		return u.CreateAccountOp()
	case PAYMENT:
		return u.PaymentOp()
	case PATH_PAYMENT:
		return u.PathPaymentOp()
	case MANAGE_OFFER:
		return u.ManageOfferOp()
	case CREATE_PASSIVE_OFFER:
		return u.CreatePassiveOfferOp()
	case SET_OPTIONS:
		return u.SetOptionsOp()
	case CHANGE_TRUST:
		return u.ChangeTrustOp()
	case ALLOW_TRUST:
		return u.AllowTrustOp()
	case ACCOUNT_MERGE:
		return u.Destination()
	case INFLATION:
		return nil
	case MANAGE_DATA:
		return u.ManageDataOp()
	case BUMP_SEQUENCE:
		return u.BumpSequenceOp()
	}
	return nil
}
func (u *_Operation_Body) XdrUnionBodyName() string {
	switch u.Type {
	case CREATE_ACCOUNT:
		return "CreateAccountOp"
	case PAYMENT:
		return "PaymentOp"
	case PATH_PAYMENT:
		return "PathPaymentOp"
	case MANAGE_OFFER:
		return "ManageOfferOp"
	case CREATE_PASSIVE_OFFER:
		return "CreatePassiveOfferOp"
	case SET_OPTIONS:
		return "SetOptionsOp"
	case CHANGE_TRUST:
		return "ChangeTrustOp"
	case ALLOW_TRUST:
		return "AllowTrustOp"
	case ACCOUNT_MERGE:
		return "Destination"
	case INFLATION:
		return ""
	case MANAGE_DATA:
		return "ManageDataOp"
	case BUMP_SEQUENCE:
		return "BumpSequenceOp"
	}
	return ""
}
func (v *_Operation_Body) XdrPointer() interface{} {
	return v
}
func (v *_Operation_Body) XdrValue() interface{} {
	return *v
}
func (v *_Operation_Body) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_OperationType(x, x.Sprintf("%stype", name), &v.Type)
	switch v.Type {
	case CREATE_ACCOUNT:
	XDR_CreateAccountOp(x, x.Sprintf("%screateAccountOp", name), v.CreateAccountOp())
		return
	case PAYMENT:
	XDR_PaymentOp(x, x.Sprintf("%spaymentOp", name), v.PaymentOp())
		return
	case PATH_PAYMENT:
	XDR_PathPaymentOp(x, x.Sprintf("%spathPaymentOp", name), v.PathPaymentOp())
		return
	case MANAGE_OFFER:
	XDR_ManageOfferOp(x, x.Sprintf("%smanageOfferOp", name), v.ManageOfferOp())
		return
	case CREATE_PASSIVE_OFFER:
	XDR_CreatePassiveOfferOp(x, x.Sprintf("%screatePassiveOfferOp", name), v.CreatePassiveOfferOp())
		return
	case SET_OPTIONS:
	XDR_SetOptionsOp(x, x.Sprintf("%ssetOptionsOp", name), v.SetOptionsOp())
		return
	case CHANGE_TRUST:
	XDR_ChangeTrustOp(x, x.Sprintf("%schangeTrustOp", name), v.ChangeTrustOp())
		return
	case ALLOW_TRUST:
	XDR_AllowTrustOp(x, x.Sprintf("%sallowTrustOp", name), v.AllowTrustOp())
		return
	case ACCOUNT_MERGE:
	XDR_AccountID(x, x.Sprintf("%sdestination", name), v.Destination())
		return
	case INFLATION:
		return
	case MANAGE_DATA:
	XDR_ManageDataOp(x, x.Sprintf("%smanageDataOp", name), v.ManageDataOp())
		return
	case BUMP_SEQUENCE:
	XDR_BumpSequenceOp(x, x.Sprintf("%sbumpSequenceOp", name), v.BumpSequenceOp())
		return
	}
	xdrPanic(fmt.Sprintf("invalid Type (%v) in _Operation_Body", v.Type))
}
func XDR__Operation_Body(x XDR, name string, v *_Operation_Body) {
	x.Marshal(name, v)
}
func (v *Operation) XdrPointer() interface{} {
	return v
}
func (v *Operation) XdrValue() interface{} {
	return *v
}
func (v *Operation) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%ssourceAccount", name), XdrPtr_AccountID{&v.SourceAccount})
	XDR__Operation_Body(x, x.Sprintf("%sbody", name), &v.Body)
}
func XDR_Operation(x XDR, name string, v *Operation) {
	x.Marshal(name, v)
}
func XDR_MemoType(x XDR, name string, v *MemoType) {
	x.Marshal(name, v)
}
var _XdrNames_MemoType = map[int32]string{
	int32(MEMO_NONE): "MEMO_NONE",
	int32(MEMO_TEXT): "MEMO_TEXT",
	int32(MEMO_ID): "MEMO_ID",
	int32(MEMO_HASH): "MEMO_HASH",
	int32(MEMO_RETURN): "MEMO_RETURN",
}
var _XdrValues_MemoType = map[string]int32{
	"MEMO_NONE": int32(MEMO_NONE),
	"MEMO_TEXT": int32(MEMO_TEXT),
	"MEMO_ID": int32(MEMO_ID),
	"MEMO_HASH": int32(MEMO_HASH),
	"MEMO_RETURN": int32(MEMO_RETURN),
}
func (*MemoType) XdrEnumNames() map[int32]string {
	return _XdrNames_MemoType
}
func (v *MemoType) String() string {
	if s, ok := _XdrNames_MemoType[int32(*v)]; ok {
		return s
	}
	return fmt.Sprintf("MemoType#%d", *v)
}
func (v *MemoType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, xdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_MemoType[stok]; ok {
			*v = MemoType(val)
			return nil
		}
		return XdrError(fmt.Sprintf("%s is not a valid MemoType.", stok))
	}
}
func (v *MemoType) GetU32() uint32 {
	return uint32(*v)
}
func (v *MemoType) SetU32(n uint32) {
	*v = MemoType(n)
}
func (v *MemoType) XdrPointer() interface{} {
	return v
}
func (v *MemoType) XdrValue() interface{} {
	return *v
}
func (u *Memo) Text() *string {
	switch u.Type {
	case MEMO_TEXT:
		if v, ok := u._u.(*string); ok {
			return v
		} else {
			var zero string
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("Memo.Text accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *Memo) Id() *Uint64 {
	switch u.Type {
	case MEMO_ID:
		if v, ok := u._u.(*Uint64); ok {
			return v
		} else {
			var zero Uint64
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("Memo.Id accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *Memo) Hash() *Hash {
	switch u.Type {
	case MEMO_HASH:
		if v, ok := u._u.(*Hash); ok {
			return v
		} else {
			var zero Hash
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("Memo.Hash accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *Memo) RetHash() *Hash {
	switch u.Type {
	case MEMO_RETURN:
		if v, ok := u._u.(*Hash); ok {
			return v
		} else {
			var zero Hash
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("Memo.RetHash accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *Memo) XdrValid() bool {
	switch u.Type {
	case MEMO_NONE,MEMO_TEXT,MEMO_ID,MEMO_HASH,MEMO_RETURN:
		return true
	}
	return false
}
func (u *Memo) XdrUnionTag() interface{} {
	return &u.Type
}
func (u *Memo) XdrUnionTagName() string {
	return "Type"
}
func (u *Memo) XdrUnionBody() interface{} {
	switch u.Type {
	case MEMO_NONE:
		return nil
	case MEMO_TEXT:
		return u.Text()
	case MEMO_ID:
		return u.Id()
	case MEMO_HASH:
		return u.Hash()
	case MEMO_RETURN:
		return u.RetHash()
	}
	return nil
}
func (u *Memo) XdrUnionBodyName() string {
	switch u.Type {
	case MEMO_NONE:
		return ""
	case MEMO_TEXT:
		return "Text"
	case MEMO_ID:
		return "Id"
	case MEMO_HASH:
		return "Hash"
	case MEMO_RETURN:
		return "RetHash"
	}
	return ""
}
func (v *Memo) XdrPointer() interface{} {
	return v
}
func (v *Memo) XdrValue() interface{} {
	return *v
}
func (v *Memo) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_MemoType(x, x.Sprintf("%stype", name), &v.Type)
	switch v.Type {
	case MEMO_NONE:
		return
	case MEMO_TEXT:
	x.Marshal(x.Sprintf("%stext", name), XdrString{v.Text(), 28})
		return
	case MEMO_ID:
	XDR_Uint64(x, x.Sprintf("%sid", name), v.Id())
		return
	case MEMO_HASH:
	XDR_Hash(x, x.Sprintf("%shash", name), v.Hash())
		return
	case MEMO_RETURN:
	XDR_Hash(x, x.Sprintf("%sretHash", name), v.RetHash())
		return
	}
	xdrPanic(fmt.Sprintf("invalid Type (%v) in Memo", v.Type))
}
func XDR_Memo(x XDR, name string, v *Memo) {
	x.Marshal(name, v)
}
func (v *TimeBounds) XdrPointer() interface{} {
	return v
}
func (v *TimeBounds) XdrValue() interface{} {
	return *v
}
func (v *TimeBounds) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Uint64(x, x.Sprintf("%sminTime", name), &v.MinTime)
	XDR_Uint64(x, x.Sprintf("%smaxTime", name), &v.MaxTime)
}
func XDR_TimeBounds(x XDR, name string, v *TimeBounds) {
	x.Marshal(name, v)
}
func (u *_Transaction_Ext) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *_Transaction_Ext) XdrUnionTag() interface{} {
	return &u.V
}
func (u *_Transaction_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *_Transaction_Ext) XdrUnionBody() interface{} {
	switch u.V {
	case 0:
		return nil
	}
	return nil
}
func (u *_Transaction_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	}
	return ""
}
func (v *_Transaction_Ext) XdrPointer() interface{} {
	return v
}
func (v *_Transaction_Ext) XdrValue() interface{} {
	return *v
}
func (v *_Transaction_Ext) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(x, x.Sprintf("%sv", name), &v.V)
	switch v.V {
	case 0:
		return
	}
	xdrPanic(fmt.Sprintf("invalid V (%v) in _Transaction_Ext", v.V))
}
func XDR__Transaction_Ext(x XDR, name string, v *_Transaction_Ext) {
	x.Marshal(name, v)
}
type XdrPtr_TimeBounds struct {
	p **TimeBounds
}
type _ptrflag_TimeBounds XdrPtr_TimeBounds
func (v _ptrflag_TimeBounds) String() string {
	if *v.p == nil {
		return "nil"
	}
	return "non-nil"
}
func (v _ptrflag_TimeBounds) GetU32() uint32 {
	if *v.p == nil {
		return 0
	}
	return 1
}
func (v _ptrflag_TimeBounds) SetU32(nv uint32) {
	switch nv {
	case 0:
		*v.p = nil
	case 1:
		if *v.p == nil {
			*v.p = new(TimeBounds)
		}
	default:
		xdrPanic("*TimeBounds present flag value %d should be 0 or 1", nv)
	}
}
func (v _ptrflag_TimeBounds) XdrPointer() interface{} { return nil }
func (v _ptrflag_TimeBounds) XdrValue() interface{} { return v.GetU32() != 0 }
func (v _ptrflag_TimeBounds) XdrBound() uint32 { return 1 }
func (v XdrPtr_TimeBounds) GetPresent() bool { return *v.p != nil }
func (v XdrPtr_TimeBounds) SetPresent(present bool) {
	if !present {
		*v.p = nil
	} else if *v.p == nil {
		*v.p = new(TimeBounds)
	}
}
func (v XdrPtr_TimeBounds) XdrMarshalValue(x XDR, name string) {
	if *v.p != nil {
		XDR_TimeBounds(x, name, *v.p)
	}
}
func (v XdrPtr_TimeBounds) XdrMarshal(x XDR, name string) {
	x.Marshal(name, _ptrflag_TimeBounds(v))
	v.XdrMarshalValue(x, name)
}
func (v XdrPtr_TimeBounds) XdrPointer() interface{} { return v.p }
func (v XdrPtr_TimeBounds) XdrValue() interface{} { return *v.p }
type XdrVec_100_Operation []Operation
func (v *XdrVec_100_Operation) XdrBound() uint32 {
	const bound uint32 = 100 // Force error if not const or doesn't fit
	return bound
}
func (*XdrVec_100_Operation) XdrCheckLen(length uint32) {
	if length > uint32(100) {
		xdrPanic("XdrVec_100_Operation length %d exceeds bound 100", length)
	} else if int(length) < 0 {
		xdrPanic("XdrVec_100_Operation length %d exceeds max int", length)
	}
}
func (v *XdrVec_100_Operation) GetVecLen() uint32 { return uint32(len(*v)) }
func (v *XdrVec_100_Operation) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2*cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(100); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]Operation, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *XdrVec_100_Operation) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if (i >= len(*v)) {
			v.SetVecLen(uint32(i+1))
		}
		XDR_Operation(x, x.Sprintf("%s[%d]", name, i), &(*v)[i])
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *XdrVec_100_Operation) XdrMarshal(x XDR, name string) {
	size := XdrSize{ size: uint32(len(*v)), bound: 100 }
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.size)
}
func (v *XdrVec_100_Operation) XdrPointer() interface{} { return (*[]Operation)(v) }
func (v *XdrVec_100_Operation) XdrValue() interface{} { return ([]Operation)(*v) }
func (v *Transaction) XdrPointer() interface{} {
	return v
}
func (v *Transaction) XdrValue() interface{} {
	return *v
}
func (v *Transaction) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_AccountID(x, x.Sprintf("%ssourceAccount", name), &v.SourceAccount)
	XDR_Uint32(x, x.Sprintf("%sfee", name), &v.Fee)
	XDR_SequenceNumber(x, x.Sprintf("%sseqNum", name), &v.SeqNum)
	x.Marshal(x.Sprintf("%stimeBounds", name), XdrPtr_TimeBounds{&v.TimeBounds})
	XDR_Memo(x, x.Sprintf("%smemo", name), &v.Memo)
	x.Marshal(x.Sprintf("%soperations", name), (*XdrVec_100_Operation)(&v.Operations))
	XDR__Transaction_Ext(x, x.Sprintf("%sext", name), &v.Ext)
}
func XDR_Transaction(x XDR, name string, v *Transaction) {
	x.Marshal(name, v)
}
func (u *_TransactionSignaturePayload_TaggedTransaction) Tx() *Transaction {
	switch u.Type {
	case ENVELOPE_TYPE_TX:
		if v, ok := u._u.(*Transaction); ok {
			return v
		} else {
			var zero Transaction
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("_TransactionSignaturePayload_TaggedTransaction.Tx accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *_TransactionSignaturePayload_TaggedTransaction) XdrValid() bool {
	switch u.Type {
	case ENVELOPE_TYPE_TX:
		return true
	}
	return false
}
func (u *_TransactionSignaturePayload_TaggedTransaction) XdrUnionTag() interface{} {
	return &u.Type
}
func (u *_TransactionSignaturePayload_TaggedTransaction) XdrUnionTagName() string {
	return "Type"
}
func (u *_TransactionSignaturePayload_TaggedTransaction) XdrUnionBody() interface{} {
	switch u.Type {
	case ENVELOPE_TYPE_TX:
		return u.Tx()
	}
	return nil
}
func (u *_TransactionSignaturePayload_TaggedTransaction) XdrUnionBodyName() string {
	switch u.Type {
	case ENVELOPE_TYPE_TX:
		return "Tx"
	}
	return ""
}
func (v *_TransactionSignaturePayload_TaggedTransaction) XdrPointer() interface{} {
	return v
}
func (v *_TransactionSignaturePayload_TaggedTransaction) XdrValue() interface{} {
	return *v
}
func (v *_TransactionSignaturePayload_TaggedTransaction) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_EnvelopeType(x, x.Sprintf("%stype", name), &v.Type)
	switch v.Type {
	case ENVELOPE_TYPE_TX:
	XDR_Transaction(x, x.Sprintf("%stx", name), v.Tx())
		return
	}
	xdrPanic(fmt.Sprintf("invalid Type (%v) in _TransactionSignaturePayload_TaggedTransaction", v.Type))
}
func XDR__TransactionSignaturePayload_TaggedTransaction(x XDR, name string, v *_TransactionSignaturePayload_TaggedTransaction) {
	x.Marshal(name, v)
}
func (v *TransactionSignaturePayload) XdrPointer() interface{} {
	return v
}
func (v *TransactionSignaturePayload) XdrValue() interface{} {
	return *v
}
func (v *TransactionSignaturePayload) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Hash(x, x.Sprintf("%snetworkId", name), &v.NetworkId)
	XDR__TransactionSignaturePayload_TaggedTransaction(x, x.Sprintf("%staggedTransaction", name), &v.TaggedTransaction)
}
func XDR_TransactionSignaturePayload(x XDR, name string, v *TransactionSignaturePayload) {
	x.Marshal(name, v)
}
type XdrVec_20_DecoratedSignature []DecoratedSignature
func (v *XdrVec_20_DecoratedSignature) XdrBound() uint32 {
	const bound uint32 = 20 // Force error if not const or doesn't fit
	return bound
}
func (*XdrVec_20_DecoratedSignature) XdrCheckLen(length uint32) {
	if length > uint32(20) {
		xdrPanic("XdrVec_20_DecoratedSignature length %d exceeds bound 20", length)
	} else if int(length) < 0 {
		xdrPanic("XdrVec_20_DecoratedSignature length %d exceeds max int", length)
	}
}
func (v *XdrVec_20_DecoratedSignature) GetVecLen() uint32 { return uint32(len(*v)) }
func (v *XdrVec_20_DecoratedSignature) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2*cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(20); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]DecoratedSignature, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *XdrVec_20_DecoratedSignature) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if (i >= len(*v)) {
			v.SetVecLen(uint32(i+1))
		}
		XDR_DecoratedSignature(x, x.Sprintf("%s[%d]", name, i), &(*v)[i])
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *XdrVec_20_DecoratedSignature) XdrMarshal(x XDR, name string) {
	size := XdrSize{ size: uint32(len(*v)), bound: 20 }
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.size)
}
func (v *XdrVec_20_DecoratedSignature) XdrPointer() interface{} { return (*[]DecoratedSignature)(v) }
func (v *XdrVec_20_DecoratedSignature) XdrValue() interface{} { return ([]DecoratedSignature)(*v) }
func (v *TransactionEnvelope) XdrPointer() interface{} {
	return v
}
func (v *TransactionEnvelope) XdrValue() interface{} {
	return *v
}
func (v *TransactionEnvelope) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Transaction(x, x.Sprintf("%stx", name), &v.Tx)
	x.Marshal(x.Sprintf("%ssignatures", name), (*XdrVec_20_DecoratedSignature)(&v.Signatures))
}
func XDR_TransactionEnvelope(x XDR, name string, v *TransactionEnvelope) {
	x.Marshal(name, v)
}
func (v *ClaimOfferAtom) XdrPointer() interface{} {
	return v
}
func (v *ClaimOfferAtom) XdrValue() interface{} {
	return *v
}
func (v *ClaimOfferAtom) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_AccountID(x, x.Sprintf("%ssellerID", name), &v.SellerID)
	XDR_Uint64(x, x.Sprintf("%sofferID", name), &v.OfferID)
	XDR_Asset(x, x.Sprintf("%sassetSold", name), &v.AssetSold)
	XDR_Int64(x, x.Sprintf("%samountSold", name), &v.AmountSold)
	XDR_Asset(x, x.Sprintf("%sassetBought", name), &v.AssetBought)
	XDR_Int64(x, x.Sprintf("%samountBought", name), &v.AmountBought)
}
func XDR_ClaimOfferAtom(x XDR, name string, v *ClaimOfferAtom) {
	x.Marshal(name, v)
}
func XDR_CreateAccountResultCode(x XDR, name string, v *CreateAccountResultCode) {
	x.Marshal(name, v)
}
var _XdrNames_CreateAccountResultCode = map[int32]string{
	int32(CREATE_ACCOUNT_SUCCESS): "CREATE_ACCOUNT_SUCCESS",
	int32(CREATE_ACCOUNT_MALFORMED): "CREATE_ACCOUNT_MALFORMED",
	int32(CREATE_ACCOUNT_UNDERFUNDED): "CREATE_ACCOUNT_UNDERFUNDED",
	int32(CREATE_ACCOUNT_LOW_RESERVE): "CREATE_ACCOUNT_LOW_RESERVE",
	int32(CREATE_ACCOUNT_ALREADY_EXIST): "CREATE_ACCOUNT_ALREADY_EXIST",
}
var _XdrValues_CreateAccountResultCode = map[string]int32{
	"CREATE_ACCOUNT_SUCCESS": int32(CREATE_ACCOUNT_SUCCESS),
	"CREATE_ACCOUNT_MALFORMED": int32(CREATE_ACCOUNT_MALFORMED),
	"CREATE_ACCOUNT_UNDERFUNDED": int32(CREATE_ACCOUNT_UNDERFUNDED),
	"CREATE_ACCOUNT_LOW_RESERVE": int32(CREATE_ACCOUNT_LOW_RESERVE),
	"CREATE_ACCOUNT_ALREADY_EXIST": int32(CREATE_ACCOUNT_ALREADY_EXIST),
}
func (*CreateAccountResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_CreateAccountResultCode
}
func (v *CreateAccountResultCode) String() string {
	if s, ok := _XdrNames_CreateAccountResultCode[int32(*v)]; ok {
		return s
	}
	return fmt.Sprintf("CreateAccountResultCode#%d", *v)
}
func (v *CreateAccountResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, xdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_CreateAccountResultCode[stok]; ok {
			*v = CreateAccountResultCode(val)
			return nil
		}
		return XdrError(fmt.Sprintf("%s is not a valid CreateAccountResultCode.", stok))
	}
}
func (v *CreateAccountResultCode) GetU32() uint32 {
	return uint32(*v)
}
func (v *CreateAccountResultCode) SetU32(n uint32) {
	*v = CreateAccountResultCode(n)
}
func (v *CreateAccountResultCode) XdrPointer() interface{} {
	return v
}
func (v *CreateAccountResultCode) XdrValue() interface{} {
	return *v
}
func (u *CreateAccountResult) XdrValid() bool {
	return true
}
func (u *CreateAccountResult) XdrUnionTag() interface{} {
	return &u.Code
}
func (u *CreateAccountResult) XdrUnionTagName() string {
	return "Code"
}
func (u *CreateAccountResult) XdrUnionBody() interface{} {
	switch u.Code {
	case CREATE_ACCOUNT_SUCCESS:
		return nil
	default:
		return nil
	}
}
func (u *CreateAccountResult) XdrUnionBodyName() string {
	switch u.Code {
	case CREATE_ACCOUNT_SUCCESS:
		return ""
	default:
		return ""
	}
}
func (v *CreateAccountResult) XdrPointer() interface{} {
	return v
}
func (v *CreateAccountResult) XdrValue() interface{} {
	return *v
}
func (v *CreateAccountResult) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_CreateAccountResultCode(x, x.Sprintf("%scode", name), &v.Code)
	switch v.Code {
	case CREATE_ACCOUNT_SUCCESS:
		return
	default:
		return
	}
}
func XDR_CreateAccountResult(x XDR, name string, v *CreateAccountResult) {
	x.Marshal(name, v)
}
func XDR_PaymentResultCode(x XDR, name string, v *PaymentResultCode) {
	x.Marshal(name, v)
}
var _XdrNames_PaymentResultCode = map[int32]string{
	int32(PAYMENT_SUCCESS): "PAYMENT_SUCCESS",
	int32(PAYMENT_MALFORMED): "PAYMENT_MALFORMED",
	int32(PAYMENT_UNDERFUNDED): "PAYMENT_UNDERFUNDED",
	int32(PAYMENT_SRC_NO_TRUST): "PAYMENT_SRC_NO_TRUST",
	int32(PAYMENT_SRC_NOT_AUTHORIZED): "PAYMENT_SRC_NOT_AUTHORIZED",
	int32(PAYMENT_NO_DESTINATION): "PAYMENT_NO_DESTINATION",
	int32(PAYMENT_NO_TRUST): "PAYMENT_NO_TRUST",
	int32(PAYMENT_NOT_AUTHORIZED): "PAYMENT_NOT_AUTHORIZED",
	int32(PAYMENT_LINE_FULL): "PAYMENT_LINE_FULL",
	int32(PAYMENT_NO_ISSUER): "PAYMENT_NO_ISSUER",
}
var _XdrValues_PaymentResultCode = map[string]int32{
	"PAYMENT_SUCCESS": int32(PAYMENT_SUCCESS),
	"PAYMENT_MALFORMED": int32(PAYMENT_MALFORMED),
	"PAYMENT_UNDERFUNDED": int32(PAYMENT_UNDERFUNDED),
	"PAYMENT_SRC_NO_TRUST": int32(PAYMENT_SRC_NO_TRUST),
	"PAYMENT_SRC_NOT_AUTHORIZED": int32(PAYMENT_SRC_NOT_AUTHORIZED),
	"PAYMENT_NO_DESTINATION": int32(PAYMENT_NO_DESTINATION),
	"PAYMENT_NO_TRUST": int32(PAYMENT_NO_TRUST),
	"PAYMENT_NOT_AUTHORIZED": int32(PAYMENT_NOT_AUTHORIZED),
	"PAYMENT_LINE_FULL": int32(PAYMENT_LINE_FULL),
	"PAYMENT_NO_ISSUER": int32(PAYMENT_NO_ISSUER),
}
func (*PaymentResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_PaymentResultCode
}
func (v *PaymentResultCode) String() string {
	if s, ok := _XdrNames_PaymentResultCode[int32(*v)]; ok {
		return s
	}
	return fmt.Sprintf("PaymentResultCode#%d", *v)
}
func (v *PaymentResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, xdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_PaymentResultCode[stok]; ok {
			*v = PaymentResultCode(val)
			return nil
		}
		return XdrError(fmt.Sprintf("%s is not a valid PaymentResultCode.", stok))
	}
}
func (v *PaymentResultCode) GetU32() uint32 {
	return uint32(*v)
}
func (v *PaymentResultCode) SetU32(n uint32) {
	*v = PaymentResultCode(n)
}
func (v *PaymentResultCode) XdrPointer() interface{} {
	return v
}
func (v *PaymentResultCode) XdrValue() interface{} {
	return *v
}
func (u *PaymentResult) XdrValid() bool {
	return true
}
func (u *PaymentResult) XdrUnionTag() interface{} {
	return &u.Code
}
func (u *PaymentResult) XdrUnionTagName() string {
	return "Code"
}
func (u *PaymentResult) XdrUnionBody() interface{} {
	switch u.Code {
	case PAYMENT_SUCCESS:
		return nil
	default:
		return nil
	}
}
func (u *PaymentResult) XdrUnionBodyName() string {
	switch u.Code {
	case PAYMENT_SUCCESS:
		return ""
	default:
		return ""
	}
}
func (v *PaymentResult) XdrPointer() interface{} {
	return v
}
func (v *PaymentResult) XdrValue() interface{} {
	return *v
}
func (v *PaymentResult) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_PaymentResultCode(x, x.Sprintf("%scode", name), &v.Code)
	switch v.Code {
	case PAYMENT_SUCCESS:
		return
	default:
		return
	}
}
func XDR_PaymentResult(x XDR, name string, v *PaymentResult) {
	x.Marshal(name, v)
}
func XDR_PathPaymentResultCode(x XDR, name string, v *PathPaymentResultCode) {
	x.Marshal(name, v)
}
var _XdrNames_PathPaymentResultCode = map[int32]string{
	int32(PATH_PAYMENT_SUCCESS): "PATH_PAYMENT_SUCCESS",
	int32(PATH_PAYMENT_MALFORMED): "PATH_PAYMENT_MALFORMED",
	int32(PATH_PAYMENT_UNDERFUNDED): "PATH_PAYMENT_UNDERFUNDED",
	int32(PATH_PAYMENT_SRC_NO_TRUST): "PATH_PAYMENT_SRC_NO_TRUST",
	int32(PATH_PAYMENT_SRC_NOT_AUTHORIZED): "PATH_PAYMENT_SRC_NOT_AUTHORIZED",
	int32(PATH_PAYMENT_NO_DESTINATION): "PATH_PAYMENT_NO_DESTINATION",
	int32(PATH_PAYMENT_NO_TRUST): "PATH_PAYMENT_NO_TRUST",
	int32(PATH_PAYMENT_NOT_AUTHORIZED): "PATH_PAYMENT_NOT_AUTHORIZED",
	int32(PATH_PAYMENT_LINE_FULL): "PATH_PAYMENT_LINE_FULL",
	int32(PATH_PAYMENT_NO_ISSUER): "PATH_PAYMENT_NO_ISSUER",
	int32(PATH_PAYMENT_TOO_FEW_OFFERS): "PATH_PAYMENT_TOO_FEW_OFFERS",
	int32(PATH_PAYMENT_OFFER_CROSS_SELF): "PATH_PAYMENT_OFFER_CROSS_SELF",
	int32(PATH_PAYMENT_OVER_SENDMAX): "PATH_PAYMENT_OVER_SENDMAX",
}
var _XdrValues_PathPaymentResultCode = map[string]int32{
	"PATH_PAYMENT_SUCCESS": int32(PATH_PAYMENT_SUCCESS),
	"PATH_PAYMENT_MALFORMED": int32(PATH_PAYMENT_MALFORMED),
	"PATH_PAYMENT_UNDERFUNDED": int32(PATH_PAYMENT_UNDERFUNDED),
	"PATH_PAYMENT_SRC_NO_TRUST": int32(PATH_PAYMENT_SRC_NO_TRUST),
	"PATH_PAYMENT_SRC_NOT_AUTHORIZED": int32(PATH_PAYMENT_SRC_NOT_AUTHORIZED),
	"PATH_PAYMENT_NO_DESTINATION": int32(PATH_PAYMENT_NO_DESTINATION),
	"PATH_PAYMENT_NO_TRUST": int32(PATH_PAYMENT_NO_TRUST),
	"PATH_PAYMENT_NOT_AUTHORIZED": int32(PATH_PAYMENT_NOT_AUTHORIZED),
	"PATH_PAYMENT_LINE_FULL": int32(PATH_PAYMENT_LINE_FULL),
	"PATH_PAYMENT_NO_ISSUER": int32(PATH_PAYMENT_NO_ISSUER),
	"PATH_PAYMENT_TOO_FEW_OFFERS": int32(PATH_PAYMENT_TOO_FEW_OFFERS),
	"PATH_PAYMENT_OFFER_CROSS_SELF": int32(PATH_PAYMENT_OFFER_CROSS_SELF),
	"PATH_PAYMENT_OVER_SENDMAX": int32(PATH_PAYMENT_OVER_SENDMAX),
}
func (*PathPaymentResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_PathPaymentResultCode
}
func (v *PathPaymentResultCode) String() string {
	if s, ok := _XdrNames_PathPaymentResultCode[int32(*v)]; ok {
		return s
	}
	return fmt.Sprintf("PathPaymentResultCode#%d", *v)
}
func (v *PathPaymentResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, xdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_PathPaymentResultCode[stok]; ok {
			*v = PathPaymentResultCode(val)
			return nil
		}
		return XdrError(fmt.Sprintf("%s is not a valid PathPaymentResultCode.", stok))
	}
}
func (v *PathPaymentResultCode) GetU32() uint32 {
	return uint32(*v)
}
func (v *PathPaymentResultCode) SetU32(n uint32) {
	*v = PathPaymentResultCode(n)
}
func (v *PathPaymentResultCode) XdrPointer() interface{} {
	return v
}
func (v *PathPaymentResultCode) XdrValue() interface{} {
	return *v
}
func (v *SimplePaymentResult) XdrPointer() interface{} {
	return v
}
func (v *SimplePaymentResult) XdrValue() interface{} {
	return *v
}
func (v *SimplePaymentResult) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_AccountID(x, x.Sprintf("%sdestination", name), &v.Destination)
	XDR_Asset(x, x.Sprintf("%sasset", name), &v.Asset)
	XDR_Int64(x, x.Sprintf("%samount", name), &v.Amount)
}
func XDR_SimplePaymentResult(x XDR, name string, v *SimplePaymentResult) {
	x.Marshal(name, v)
}
type XdrVec_unbounded_ClaimOfferAtom []ClaimOfferAtom
func (v *XdrVec_unbounded_ClaimOfferAtom) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (*XdrVec_unbounded_ClaimOfferAtom) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		xdrPanic("XdrVec_unbounded_ClaimOfferAtom length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		xdrPanic("XdrVec_unbounded_ClaimOfferAtom length %d exceeds max int", length)
	}
}
func (v *XdrVec_unbounded_ClaimOfferAtom) GetVecLen() uint32 { return uint32(len(*v)) }
func (v *XdrVec_unbounded_ClaimOfferAtom) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2*cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]ClaimOfferAtom, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *XdrVec_unbounded_ClaimOfferAtom) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if (i >= len(*v)) {
			v.SetVecLen(uint32(i+1))
		}
		XDR_ClaimOfferAtom(x, x.Sprintf("%s[%d]", name, i), &(*v)[i])
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *XdrVec_unbounded_ClaimOfferAtom) XdrMarshal(x XDR, name string) {
	size := XdrSize{ size: uint32(len(*v)), bound: 4294967295 }
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.size)
}
func (v *XdrVec_unbounded_ClaimOfferAtom) XdrPointer() interface{} { return (*[]ClaimOfferAtom)(v) }
func (v *XdrVec_unbounded_ClaimOfferAtom) XdrValue() interface{} { return ([]ClaimOfferAtom)(*v) }
func (v *_PathPaymentResult_Success) XdrPointer() interface{} {
	return v
}
func (v *_PathPaymentResult_Success) XdrValue() interface{} {
	return *v
}
func (v *_PathPaymentResult_Success) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%soffers", name), (*XdrVec_unbounded_ClaimOfferAtom)(&v.Offers))
	XDR_SimplePaymentResult(x, x.Sprintf("%slast", name), &v.Last)
}
func XDR__PathPaymentResult_Success(x XDR, name string, v *_PathPaymentResult_Success) {
	x.Marshal(name, v)
}
func (u *PathPaymentResult) Success() *_PathPaymentResult_Success {
	switch u.Code {
	case PATH_PAYMENT_SUCCESS:
		if v, ok := u._u.(*_PathPaymentResult_Success); ok {
			return v
		} else {
			var zero _PathPaymentResult_Success
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("PathPaymentResult.Success accessed when Code == %v", u.Code)
		return nil
	}
}
func (u *PathPaymentResult) NoIssuer() *Asset {
	switch u.Code {
	case PATH_PAYMENT_NO_ISSUER:
		if v, ok := u._u.(*Asset); ok {
			return v
		} else {
			var zero Asset
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("PathPaymentResult.NoIssuer accessed when Code == %v", u.Code)
		return nil
	}
}
func (u *PathPaymentResult) XdrValid() bool {
	return true
}
func (u *PathPaymentResult) XdrUnionTag() interface{} {
	return &u.Code
}
func (u *PathPaymentResult) XdrUnionTagName() string {
	return "Code"
}
func (u *PathPaymentResult) XdrUnionBody() interface{} {
	switch u.Code {
	case PATH_PAYMENT_SUCCESS:
		return u.Success()
	case PATH_PAYMENT_NO_ISSUER:
		return u.NoIssuer()
	default:
		return nil
	}
}
func (u *PathPaymentResult) XdrUnionBodyName() string {
	switch u.Code {
	case PATH_PAYMENT_SUCCESS:
		return "Success"
	case PATH_PAYMENT_NO_ISSUER:
		return "NoIssuer"
	default:
		return ""
	}
}
func (v *PathPaymentResult) XdrPointer() interface{} {
	return v
}
func (v *PathPaymentResult) XdrValue() interface{} {
	return *v
}
func (v *PathPaymentResult) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_PathPaymentResultCode(x, x.Sprintf("%scode", name), &v.Code)
	switch v.Code {
	case PATH_PAYMENT_SUCCESS:
	XDR__PathPaymentResult_Success(x, x.Sprintf("%ssuccess", name), v.Success())
		return
	case PATH_PAYMENT_NO_ISSUER:
	XDR_Asset(x, x.Sprintf("%snoIssuer", name), v.NoIssuer())
		return
	default:
		return
	}
}
func XDR_PathPaymentResult(x XDR, name string, v *PathPaymentResult) {
	x.Marshal(name, v)
}
func XDR_ManageOfferResultCode(x XDR, name string, v *ManageOfferResultCode) {
	x.Marshal(name, v)
}
var _XdrNames_ManageOfferResultCode = map[int32]string{
	int32(MANAGE_OFFER_SUCCESS): "MANAGE_OFFER_SUCCESS",
	int32(MANAGE_OFFER_MALFORMED): "MANAGE_OFFER_MALFORMED",
	int32(MANAGE_OFFER_SELL_NO_TRUST): "MANAGE_OFFER_SELL_NO_TRUST",
	int32(MANAGE_OFFER_BUY_NO_TRUST): "MANAGE_OFFER_BUY_NO_TRUST",
	int32(MANAGE_OFFER_SELL_NOT_AUTHORIZED): "MANAGE_OFFER_SELL_NOT_AUTHORIZED",
	int32(MANAGE_OFFER_BUY_NOT_AUTHORIZED): "MANAGE_OFFER_BUY_NOT_AUTHORIZED",
	int32(MANAGE_OFFER_LINE_FULL): "MANAGE_OFFER_LINE_FULL",
	int32(MANAGE_OFFER_UNDERFUNDED): "MANAGE_OFFER_UNDERFUNDED",
	int32(MANAGE_OFFER_CROSS_SELF): "MANAGE_OFFER_CROSS_SELF",
	int32(MANAGE_OFFER_SELL_NO_ISSUER): "MANAGE_OFFER_SELL_NO_ISSUER",
	int32(MANAGE_OFFER_BUY_NO_ISSUER): "MANAGE_OFFER_BUY_NO_ISSUER",
	int32(MANAGE_OFFER_NOT_FOUND): "MANAGE_OFFER_NOT_FOUND",
	int32(MANAGE_OFFER_LOW_RESERVE): "MANAGE_OFFER_LOW_RESERVE",
}
var _XdrValues_ManageOfferResultCode = map[string]int32{
	"MANAGE_OFFER_SUCCESS": int32(MANAGE_OFFER_SUCCESS),
	"MANAGE_OFFER_MALFORMED": int32(MANAGE_OFFER_MALFORMED),
	"MANAGE_OFFER_SELL_NO_TRUST": int32(MANAGE_OFFER_SELL_NO_TRUST),
	"MANAGE_OFFER_BUY_NO_TRUST": int32(MANAGE_OFFER_BUY_NO_TRUST),
	"MANAGE_OFFER_SELL_NOT_AUTHORIZED": int32(MANAGE_OFFER_SELL_NOT_AUTHORIZED),
	"MANAGE_OFFER_BUY_NOT_AUTHORIZED": int32(MANAGE_OFFER_BUY_NOT_AUTHORIZED),
	"MANAGE_OFFER_LINE_FULL": int32(MANAGE_OFFER_LINE_FULL),
	"MANAGE_OFFER_UNDERFUNDED": int32(MANAGE_OFFER_UNDERFUNDED),
	"MANAGE_OFFER_CROSS_SELF": int32(MANAGE_OFFER_CROSS_SELF),
	"MANAGE_OFFER_SELL_NO_ISSUER": int32(MANAGE_OFFER_SELL_NO_ISSUER),
	"MANAGE_OFFER_BUY_NO_ISSUER": int32(MANAGE_OFFER_BUY_NO_ISSUER),
	"MANAGE_OFFER_NOT_FOUND": int32(MANAGE_OFFER_NOT_FOUND),
	"MANAGE_OFFER_LOW_RESERVE": int32(MANAGE_OFFER_LOW_RESERVE),
}
func (*ManageOfferResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_ManageOfferResultCode
}
func (v *ManageOfferResultCode) String() string {
	if s, ok := _XdrNames_ManageOfferResultCode[int32(*v)]; ok {
		return s
	}
	return fmt.Sprintf("ManageOfferResultCode#%d", *v)
}
func (v *ManageOfferResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, xdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_ManageOfferResultCode[stok]; ok {
			*v = ManageOfferResultCode(val)
			return nil
		}
		return XdrError(fmt.Sprintf("%s is not a valid ManageOfferResultCode.", stok))
	}
}
func (v *ManageOfferResultCode) GetU32() uint32 {
	return uint32(*v)
}
func (v *ManageOfferResultCode) SetU32(n uint32) {
	*v = ManageOfferResultCode(n)
}
func (v *ManageOfferResultCode) XdrPointer() interface{} {
	return v
}
func (v *ManageOfferResultCode) XdrValue() interface{} {
	return *v
}
func XDR_ManageOfferEffect(x XDR, name string, v *ManageOfferEffect) {
	x.Marshal(name, v)
}
var _XdrNames_ManageOfferEffect = map[int32]string{
	int32(MANAGE_OFFER_CREATED): "MANAGE_OFFER_CREATED",
	int32(MANAGE_OFFER_UPDATED): "MANAGE_OFFER_UPDATED",
	int32(MANAGE_OFFER_DELETED): "MANAGE_OFFER_DELETED",
}
var _XdrValues_ManageOfferEffect = map[string]int32{
	"MANAGE_OFFER_CREATED": int32(MANAGE_OFFER_CREATED),
	"MANAGE_OFFER_UPDATED": int32(MANAGE_OFFER_UPDATED),
	"MANAGE_OFFER_DELETED": int32(MANAGE_OFFER_DELETED),
}
func (*ManageOfferEffect) XdrEnumNames() map[int32]string {
	return _XdrNames_ManageOfferEffect
}
func (v *ManageOfferEffect) String() string {
	if s, ok := _XdrNames_ManageOfferEffect[int32(*v)]; ok {
		return s
	}
	return fmt.Sprintf("ManageOfferEffect#%d", *v)
}
func (v *ManageOfferEffect) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, xdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_ManageOfferEffect[stok]; ok {
			*v = ManageOfferEffect(val)
			return nil
		}
		return XdrError(fmt.Sprintf("%s is not a valid ManageOfferEffect.", stok))
	}
}
func (v *ManageOfferEffect) GetU32() uint32 {
	return uint32(*v)
}
func (v *ManageOfferEffect) SetU32(n uint32) {
	*v = ManageOfferEffect(n)
}
func (v *ManageOfferEffect) XdrPointer() interface{} {
	return v
}
func (v *ManageOfferEffect) XdrValue() interface{} {
	return *v
}
func (u *_ManageOfferSuccessResult_Offer) Offer() *OfferEntry {
	switch u.Effect {
	case MANAGE_OFFER_CREATED, MANAGE_OFFER_UPDATED:
		if v, ok := u._u.(*OfferEntry); ok {
			return v
		} else {
			var zero OfferEntry
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("_ManageOfferSuccessResult_Offer.Offer accessed when Effect == %v", u.Effect)
		return nil
	}
}
func (u *_ManageOfferSuccessResult_Offer) XdrValid() bool {
	return true
}
func (u *_ManageOfferSuccessResult_Offer) XdrUnionTag() interface{} {
	return &u.Effect
}
func (u *_ManageOfferSuccessResult_Offer) XdrUnionTagName() string {
	return "Effect"
}
func (u *_ManageOfferSuccessResult_Offer) XdrUnionBody() interface{} {
	switch u.Effect {
	case MANAGE_OFFER_CREATED, MANAGE_OFFER_UPDATED:
		return u.Offer()
	default:
		return nil
	}
}
func (u *_ManageOfferSuccessResult_Offer) XdrUnionBodyName() string {
	switch u.Effect {
	case MANAGE_OFFER_CREATED, MANAGE_OFFER_UPDATED:
		return "Offer"
	default:
		return ""
	}
}
func (v *_ManageOfferSuccessResult_Offer) XdrPointer() interface{} {
	return v
}
func (v *_ManageOfferSuccessResult_Offer) XdrValue() interface{} {
	return *v
}
func (v *_ManageOfferSuccessResult_Offer) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_ManageOfferEffect(x, x.Sprintf("%seffect", name), &v.Effect)
	switch v.Effect {
	case MANAGE_OFFER_CREATED, MANAGE_OFFER_UPDATED:
	XDR_OfferEntry(x, x.Sprintf("%soffer", name), v.Offer())
		return
	default:
		return
	}
}
func XDR__ManageOfferSuccessResult_Offer(x XDR, name string, v *_ManageOfferSuccessResult_Offer) {
	x.Marshal(name, v)
}
func (v *ManageOfferSuccessResult) XdrPointer() interface{} {
	return v
}
func (v *ManageOfferSuccessResult) XdrValue() interface{} {
	return *v
}
func (v *ManageOfferSuccessResult) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%soffersClaimed", name), (*XdrVec_unbounded_ClaimOfferAtom)(&v.OffersClaimed))
	XDR__ManageOfferSuccessResult_Offer(x, x.Sprintf("%soffer", name), &v.Offer)
}
func XDR_ManageOfferSuccessResult(x XDR, name string, v *ManageOfferSuccessResult) {
	x.Marshal(name, v)
}
func (u *ManageOfferResult) Success() *ManageOfferSuccessResult {
	switch u.Code {
	case MANAGE_OFFER_SUCCESS:
		if v, ok := u._u.(*ManageOfferSuccessResult); ok {
			return v
		} else {
			var zero ManageOfferSuccessResult
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("ManageOfferResult.Success accessed when Code == %v", u.Code)
		return nil
	}
}
func (u *ManageOfferResult) XdrValid() bool {
	return true
}
func (u *ManageOfferResult) XdrUnionTag() interface{} {
	return &u.Code
}
func (u *ManageOfferResult) XdrUnionTagName() string {
	return "Code"
}
func (u *ManageOfferResult) XdrUnionBody() interface{} {
	switch u.Code {
	case MANAGE_OFFER_SUCCESS:
		return u.Success()
	default:
		return nil
	}
}
func (u *ManageOfferResult) XdrUnionBodyName() string {
	switch u.Code {
	case MANAGE_OFFER_SUCCESS:
		return "Success"
	default:
		return ""
	}
}
func (v *ManageOfferResult) XdrPointer() interface{} {
	return v
}
func (v *ManageOfferResult) XdrValue() interface{} {
	return *v
}
func (v *ManageOfferResult) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_ManageOfferResultCode(x, x.Sprintf("%scode", name), &v.Code)
	switch v.Code {
	case MANAGE_OFFER_SUCCESS:
	XDR_ManageOfferSuccessResult(x, x.Sprintf("%ssuccess", name), v.Success())
		return
	default:
		return
	}
}
func XDR_ManageOfferResult(x XDR, name string, v *ManageOfferResult) {
	x.Marshal(name, v)
}
func XDR_SetOptionsResultCode(x XDR, name string, v *SetOptionsResultCode) {
	x.Marshal(name, v)
}
var _XdrNames_SetOptionsResultCode = map[int32]string{
	int32(SET_OPTIONS_SUCCESS): "SET_OPTIONS_SUCCESS",
	int32(SET_OPTIONS_LOW_RESERVE): "SET_OPTIONS_LOW_RESERVE",
	int32(SET_OPTIONS_TOO_MANY_SIGNERS): "SET_OPTIONS_TOO_MANY_SIGNERS",
	int32(SET_OPTIONS_BAD_FLAGS): "SET_OPTIONS_BAD_FLAGS",
	int32(SET_OPTIONS_INVALID_INFLATION): "SET_OPTIONS_INVALID_INFLATION",
	int32(SET_OPTIONS_CANT_CHANGE): "SET_OPTIONS_CANT_CHANGE",
	int32(SET_OPTIONS_UNKNOWN_FLAG): "SET_OPTIONS_UNKNOWN_FLAG",
	int32(SET_OPTIONS_THRESHOLD_OUT_OF_RANGE): "SET_OPTIONS_THRESHOLD_OUT_OF_RANGE",
	int32(SET_OPTIONS_BAD_SIGNER): "SET_OPTIONS_BAD_SIGNER",
	int32(SET_OPTIONS_INVALID_HOME_DOMAIN): "SET_OPTIONS_INVALID_HOME_DOMAIN",
}
var _XdrValues_SetOptionsResultCode = map[string]int32{
	"SET_OPTIONS_SUCCESS": int32(SET_OPTIONS_SUCCESS),
	"SET_OPTIONS_LOW_RESERVE": int32(SET_OPTIONS_LOW_RESERVE),
	"SET_OPTIONS_TOO_MANY_SIGNERS": int32(SET_OPTIONS_TOO_MANY_SIGNERS),
	"SET_OPTIONS_BAD_FLAGS": int32(SET_OPTIONS_BAD_FLAGS),
	"SET_OPTIONS_INVALID_INFLATION": int32(SET_OPTIONS_INVALID_INFLATION),
	"SET_OPTIONS_CANT_CHANGE": int32(SET_OPTIONS_CANT_CHANGE),
	"SET_OPTIONS_UNKNOWN_FLAG": int32(SET_OPTIONS_UNKNOWN_FLAG),
	"SET_OPTIONS_THRESHOLD_OUT_OF_RANGE": int32(SET_OPTIONS_THRESHOLD_OUT_OF_RANGE),
	"SET_OPTIONS_BAD_SIGNER": int32(SET_OPTIONS_BAD_SIGNER),
	"SET_OPTIONS_INVALID_HOME_DOMAIN": int32(SET_OPTIONS_INVALID_HOME_DOMAIN),
}
func (*SetOptionsResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_SetOptionsResultCode
}
func (v *SetOptionsResultCode) String() string {
	if s, ok := _XdrNames_SetOptionsResultCode[int32(*v)]; ok {
		return s
	}
	return fmt.Sprintf("SetOptionsResultCode#%d", *v)
}
func (v *SetOptionsResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, xdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_SetOptionsResultCode[stok]; ok {
			*v = SetOptionsResultCode(val)
			return nil
		}
		return XdrError(fmt.Sprintf("%s is not a valid SetOptionsResultCode.", stok))
	}
}
func (v *SetOptionsResultCode) GetU32() uint32 {
	return uint32(*v)
}
func (v *SetOptionsResultCode) SetU32(n uint32) {
	*v = SetOptionsResultCode(n)
}
func (v *SetOptionsResultCode) XdrPointer() interface{} {
	return v
}
func (v *SetOptionsResultCode) XdrValue() interface{} {
	return *v
}
func (u *SetOptionsResult) XdrValid() bool {
	return true
}
func (u *SetOptionsResult) XdrUnionTag() interface{} {
	return &u.Code
}
func (u *SetOptionsResult) XdrUnionTagName() string {
	return "Code"
}
func (u *SetOptionsResult) XdrUnionBody() interface{} {
	switch u.Code {
	case SET_OPTIONS_SUCCESS:
		return nil
	default:
		return nil
	}
}
func (u *SetOptionsResult) XdrUnionBodyName() string {
	switch u.Code {
	case SET_OPTIONS_SUCCESS:
		return ""
	default:
		return ""
	}
}
func (v *SetOptionsResult) XdrPointer() interface{} {
	return v
}
func (v *SetOptionsResult) XdrValue() interface{} {
	return *v
}
func (v *SetOptionsResult) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_SetOptionsResultCode(x, x.Sprintf("%scode", name), &v.Code)
	switch v.Code {
	case SET_OPTIONS_SUCCESS:
		return
	default:
		return
	}
}
func XDR_SetOptionsResult(x XDR, name string, v *SetOptionsResult) {
	x.Marshal(name, v)
}
func XDR_ChangeTrustResultCode(x XDR, name string, v *ChangeTrustResultCode) {
	x.Marshal(name, v)
}
var _XdrNames_ChangeTrustResultCode = map[int32]string{
	int32(CHANGE_TRUST_SUCCESS): "CHANGE_TRUST_SUCCESS",
	int32(CHANGE_TRUST_MALFORMED): "CHANGE_TRUST_MALFORMED",
	int32(CHANGE_TRUST_NO_ISSUER): "CHANGE_TRUST_NO_ISSUER",
	int32(CHANGE_TRUST_INVALID_LIMIT): "CHANGE_TRUST_INVALID_LIMIT",
	int32(CHANGE_TRUST_LOW_RESERVE): "CHANGE_TRUST_LOW_RESERVE",
	int32(CHANGE_TRUST_SELF_NOT_ALLOWED): "CHANGE_TRUST_SELF_NOT_ALLOWED",
}
var _XdrValues_ChangeTrustResultCode = map[string]int32{
	"CHANGE_TRUST_SUCCESS": int32(CHANGE_TRUST_SUCCESS),
	"CHANGE_TRUST_MALFORMED": int32(CHANGE_TRUST_MALFORMED),
	"CHANGE_TRUST_NO_ISSUER": int32(CHANGE_TRUST_NO_ISSUER),
	"CHANGE_TRUST_INVALID_LIMIT": int32(CHANGE_TRUST_INVALID_LIMIT),
	"CHANGE_TRUST_LOW_RESERVE": int32(CHANGE_TRUST_LOW_RESERVE),
	"CHANGE_TRUST_SELF_NOT_ALLOWED": int32(CHANGE_TRUST_SELF_NOT_ALLOWED),
}
func (*ChangeTrustResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_ChangeTrustResultCode
}
func (v *ChangeTrustResultCode) String() string {
	if s, ok := _XdrNames_ChangeTrustResultCode[int32(*v)]; ok {
		return s
	}
	return fmt.Sprintf("ChangeTrustResultCode#%d", *v)
}
func (v *ChangeTrustResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, xdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_ChangeTrustResultCode[stok]; ok {
			*v = ChangeTrustResultCode(val)
			return nil
		}
		return XdrError(fmt.Sprintf("%s is not a valid ChangeTrustResultCode.", stok))
	}
}
func (v *ChangeTrustResultCode) GetU32() uint32 {
	return uint32(*v)
}
func (v *ChangeTrustResultCode) SetU32(n uint32) {
	*v = ChangeTrustResultCode(n)
}
func (v *ChangeTrustResultCode) XdrPointer() interface{} {
	return v
}
func (v *ChangeTrustResultCode) XdrValue() interface{} {
	return *v
}
func (u *ChangeTrustResult) XdrValid() bool {
	return true
}
func (u *ChangeTrustResult) XdrUnionTag() interface{} {
	return &u.Code
}
func (u *ChangeTrustResult) XdrUnionTagName() string {
	return "Code"
}
func (u *ChangeTrustResult) XdrUnionBody() interface{} {
	switch u.Code {
	case CHANGE_TRUST_SUCCESS:
		return nil
	default:
		return nil
	}
}
func (u *ChangeTrustResult) XdrUnionBodyName() string {
	switch u.Code {
	case CHANGE_TRUST_SUCCESS:
		return ""
	default:
		return ""
	}
}
func (v *ChangeTrustResult) XdrPointer() interface{} {
	return v
}
func (v *ChangeTrustResult) XdrValue() interface{} {
	return *v
}
func (v *ChangeTrustResult) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_ChangeTrustResultCode(x, x.Sprintf("%scode", name), &v.Code)
	switch v.Code {
	case CHANGE_TRUST_SUCCESS:
		return
	default:
		return
	}
}
func XDR_ChangeTrustResult(x XDR, name string, v *ChangeTrustResult) {
	x.Marshal(name, v)
}
func XDR_AllowTrustResultCode(x XDR, name string, v *AllowTrustResultCode) {
	x.Marshal(name, v)
}
var _XdrNames_AllowTrustResultCode = map[int32]string{
	int32(ALLOW_TRUST_SUCCESS): "ALLOW_TRUST_SUCCESS",
	int32(ALLOW_TRUST_MALFORMED): "ALLOW_TRUST_MALFORMED",
	int32(ALLOW_TRUST_NO_TRUST_LINE): "ALLOW_TRUST_NO_TRUST_LINE",
	int32(ALLOW_TRUST_TRUST_NOT_REQUIRED): "ALLOW_TRUST_TRUST_NOT_REQUIRED",
	int32(ALLOW_TRUST_CANT_REVOKE): "ALLOW_TRUST_CANT_REVOKE",
	int32(ALLOW_TRUST_SELF_NOT_ALLOWED): "ALLOW_TRUST_SELF_NOT_ALLOWED",
}
var _XdrValues_AllowTrustResultCode = map[string]int32{
	"ALLOW_TRUST_SUCCESS": int32(ALLOW_TRUST_SUCCESS),
	"ALLOW_TRUST_MALFORMED": int32(ALLOW_TRUST_MALFORMED),
	"ALLOW_TRUST_NO_TRUST_LINE": int32(ALLOW_TRUST_NO_TRUST_LINE),
	"ALLOW_TRUST_TRUST_NOT_REQUIRED": int32(ALLOW_TRUST_TRUST_NOT_REQUIRED),
	"ALLOW_TRUST_CANT_REVOKE": int32(ALLOW_TRUST_CANT_REVOKE),
	"ALLOW_TRUST_SELF_NOT_ALLOWED": int32(ALLOW_TRUST_SELF_NOT_ALLOWED),
}
func (*AllowTrustResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_AllowTrustResultCode
}
func (v *AllowTrustResultCode) String() string {
	if s, ok := _XdrNames_AllowTrustResultCode[int32(*v)]; ok {
		return s
	}
	return fmt.Sprintf("AllowTrustResultCode#%d", *v)
}
func (v *AllowTrustResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, xdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_AllowTrustResultCode[stok]; ok {
			*v = AllowTrustResultCode(val)
			return nil
		}
		return XdrError(fmt.Sprintf("%s is not a valid AllowTrustResultCode.", stok))
	}
}
func (v *AllowTrustResultCode) GetU32() uint32 {
	return uint32(*v)
}
func (v *AllowTrustResultCode) SetU32(n uint32) {
	*v = AllowTrustResultCode(n)
}
func (v *AllowTrustResultCode) XdrPointer() interface{} {
	return v
}
func (v *AllowTrustResultCode) XdrValue() interface{} {
	return *v
}
func (u *AllowTrustResult) XdrValid() bool {
	return true
}
func (u *AllowTrustResult) XdrUnionTag() interface{} {
	return &u.Code
}
func (u *AllowTrustResult) XdrUnionTagName() string {
	return "Code"
}
func (u *AllowTrustResult) XdrUnionBody() interface{} {
	switch u.Code {
	case ALLOW_TRUST_SUCCESS:
		return nil
	default:
		return nil
	}
}
func (u *AllowTrustResult) XdrUnionBodyName() string {
	switch u.Code {
	case ALLOW_TRUST_SUCCESS:
		return ""
	default:
		return ""
	}
}
func (v *AllowTrustResult) XdrPointer() interface{} {
	return v
}
func (v *AllowTrustResult) XdrValue() interface{} {
	return *v
}
func (v *AllowTrustResult) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_AllowTrustResultCode(x, x.Sprintf("%scode", name), &v.Code)
	switch v.Code {
	case ALLOW_TRUST_SUCCESS:
		return
	default:
		return
	}
}
func XDR_AllowTrustResult(x XDR, name string, v *AllowTrustResult) {
	x.Marshal(name, v)
}
func XDR_AccountMergeResultCode(x XDR, name string, v *AccountMergeResultCode) {
	x.Marshal(name, v)
}
var _XdrNames_AccountMergeResultCode = map[int32]string{
	int32(ACCOUNT_MERGE_SUCCESS): "ACCOUNT_MERGE_SUCCESS",
	int32(ACCOUNT_MERGE_MALFORMED): "ACCOUNT_MERGE_MALFORMED",
	int32(ACCOUNT_MERGE_NO_ACCOUNT): "ACCOUNT_MERGE_NO_ACCOUNT",
	int32(ACCOUNT_MERGE_IMMUTABLE_SET): "ACCOUNT_MERGE_IMMUTABLE_SET",
	int32(ACCOUNT_MERGE_HAS_SUB_ENTRIES): "ACCOUNT_MERGE_HAS_SUB_ENTRIES",
	int32(ACCOUNT_MERGE_SEQNUM_TOO_FAR): "ACCOUNT_MERGE_SEQNUM_TOO_FAR",
	int32(ACCOUNT_MERGE_DEST_FULL): "ACCOUNT_MERGE_DEST_FULL",
}
var _XdrValues_AccountMergeResultCode = map[string]int32{
	"ACCOUNT_MERGE_SUCCESS": int32(ACCOUNT_MERGE_SUCCESS),
	"ACCOUNT_MERGE_MALFORMED": int32(ACCOUNT_MERGE_MALFORMED),
	"ACCOUNT_MERGE_NO_ACCOUNT": int32(ACCOUNT_MERGE_NO_ACCOUNT),
	"ACCOUNT_MERGE_IMMUTABLE_SET": int32(ACCOUNT_MERGE_IMMUTABLE_SET),
	"ACCOUNT_MERGE_HAS_SUB_ENTRIES": int32(ACCOUNT_MERGE_HAS_SUB_ENTRIES),
	"ACCOUNT_MERGE_SEQNUM_TOO_FAR": int32(ACCOUNT_MERGE_SEQNUM_TOO_FAR),
	"ACCOUNT_MERGE_DEST_FULL": int32(ACCOUNT_MERGE_DEST_FULL),
}
func (*AccountMergeResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_AccountMergeResultCode
}
func (v *AccountMergeResultCode) String() string {
	if s, ok := _XdrNames_AccountMergeResultCode[int32(*v)]; ok {
		return s
	}
	return fmt.Sprintf("AccountMergeResultCode#%d", *v)
}
func (v *AccountMergeResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, xdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_AccountMergeResultCode[stok]; ok {
			*v = AccountMergeResultCode(val)
			return nil
		}
		return XdrError(fmt.Sprintf("%s is not a valid AccountMergeResultCode.", stok))
	}
}
func (v *AccountMergeResultCode) GetU32() uint32 {
	return uint32(*v)
}
func (v *AccountMergeResultCode) SetU32(n uint32) {
	*v = AccountMergeResultCode(n)
}
func (v *AccountMergeResultCode) XdrPointer() interface{} {
	return v
}
func (v *AccountMergeResultCode) XdrValue() interface{} {
	return *v
}
func (u *AccountMergeResult) SourceAccountBalance() *Int64 {
	switch u.Code {
	case ACCOUNT_MERGE_SUCCESS:
		if v, ok := u._u.(*Int64); ok {
			return v
		} else {
			var zero Int64
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("AccountMergeResult.SourceAccountBalance accessed when Code == %v", u.Code)
		return nil
	}
}
func (u *AccountMergeResult) XdrValid() bool {
	return true
}
func (u *AccountMergeResult) XdrUnionTag() interface{} {
	return &u.Code
}
func (u *AccountMergeResult) XdrUnionTagName() string {
	return "Code"
}
func (u *AccountMergeResult) XdrUnionBody() interface{} {
	switch u.Code {
	case ACCOUNT_MERGE_SUCCESS:
		return u.SourceAccountBalance()
	default:
		return nil
	}
}
func (u *AccountMergeResult) XdrUnionBodyName() string {
	switch u.Code {
	case ACCOUNT_MERGE_SUCCESS:
		return "SourceAccountBalance"
	default:
		return ""
	}
}
func (v *AccountMergeResult) XdrPointer() interface{} {
	return v
}
func (v *AccountMergeResult) XdrValue() interface{} {
	return *v
}
func (v *AccountMergeResult) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_AccountMergeResultCode(x, x.Sprintf("%scode", name), &v.Code)
	switch v.Code {
	case ACCOUNT_MERGE_SUCCESS:
	XDR_Int64(x, x.Sprintf("%ssourceAccountBalance", name), v.SourceAccountBalance())
		return
	default:
		return
	}
}
func XDR_AccountMergeResult(x XDR, name string, v *AccountMergeResult) {
	x.Marshal(name, v)
}
func XDR_InflationResultCode(x XDR, name string, v *InflationResultCode) {
	x.Marshal(name, v)
}
var _XdrNames_InflationResultCode = map[int32]string{
	int32(INFLATION_SUCCESS): "INFLATION_SUCCESS",
	int32(INFLATION_NOT_TIME): "INFLATION_NOT_TIME",
}
var _XdrValues_InflationResultCode = map[string]int32{
	"INFLATION_SUCCESS": int32(INFLATION_SUCCESS),
	"INFLATION_NOT_TIME": int32(INFLATION_NOT_TIME),
}
func (*InflationResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_InflationResultCode
}
func (v *InflationResultCode) String() string {
	if s, ok := _XdrNames_InflationResultCode[int32(*v)]; ok {
		return s
	}
	return fmt.Sprintf("InflationResultCode#%d", *v)
}
func (v *InflationResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, xdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_InflationResultCode[stok]; ok {
			*v = InflationResultCode(val)
			return nil
		}
		return XdrError(fmt.Sprintf("%s is not a valid InflationResultCode.", stok))
	}
}
func (v *InflationResultCode) GetU32() uint32 {
	return uint32(*v)
}
func (v *InflationResultCode) SetU32(n uint32) {
	*v = InflationResultCode(n)
}
func (v *InflationResultCode) XdrPointer() interface{} {
	return v
}
func (v *InflationResultCode) XdrValue() interface{} {
	return *v
}
func (v *InflationPayout) XdrPointer() interface{} {
	return v
}
func (v *InflationPayout) XdrValue() interface{} {
	return *v
}
func (v *InflationPayout) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_AccountID(x, x.Sprintf("%sdestination", name), &v.Destination)
	XDR_Int64(x, x.Sprintf("%samount", name), &v.Amount)
}
func XDR_InflationPayout(x XDR, name string, v *InflationPayout) {
	x.Marshal(name, v)
}
type XdrVec_unbounded_InflationPayout []InflationPayout
func (v *XdrVec_unbounded_InflationPayout) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (*XdrVec_unbounded_InflationPayout) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		xdrPanic("XdrVec_unbounded_InflationPayout length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		xdrPanic("XdrVec_unbounded_InflationPayout length %d exceeds max int", length)
	}
}
func (v *XdrVec_unbounded_InflationPayout) GetVecLen() uint32 { return uint32(len(*v)) }
func (v *XdrVec_unbounded_InflationPayout) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2*cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]InflationPayout, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *XdrVec_unbounded_InflationPayout) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if (i >= len(*v)) {
			v.SetVecLen(uint32(i+1))
		}
		XDR_InflationPayout(x, x.Sprintf("%s[%d]", name, i), &(*v)[i])
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *XdrVec_unbounded_InflationPayout) XdrMarshal(x XDR, name string) {
	size := XdrSize{ size: uint32(len(*v)), bound: 4294967295 }
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.size)
}
func (v *XdrVec_unbounded_InflationPayout) XdrPointer() interface{} { return (*[]InflationPayout)(v) }
func (v *XdrVec_unbounded_InflationPayout) XdrValue() interface{} { return ([]InflationPayout)(*v) }
func (u *InflationResult) Payouts() *[]InflationPayout {
	switch u.Code {
	case INFLATION_SUCCESS:
		if v, ok := u._u.(*[]InflationPayout); ok {
			return v
		} else {
			var zero []InflationPayout
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("InflationResult.Payouts accessed when Code == %v", u.Code)
		return nil
	}
}
func (u *InflationResult) XdrValid() bool {
	return true
}
func (u *InflationResult) XdrUnionTag() interface{} {
	return &u.Code
}
func (u *InflationResult) XdrUnionTagName() string {
	return "Code"
}
func (u *InflationResult) XdrUnionBody() interface{} {
	switch u.Code {
	case INFLATION_SUCCESS:
		return u.Payouts()
	default:
		return nil
	}
}
func (u *InflationResult) XdrUnionBodyName() string {
	switch u.Code {
	case INFLATION_SUCCESS:
		return "Payouts"
	default:
		return ""
	}
}
func (v *InflationResult) XdrPointer() interface{} {
	return v
}
func (v *InflationResult) XdrValue() interface{} {
	return *v
}
func (v *InflationResult) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_InflationResultCode(x, x.Sprintf("%scode", name), &v.Code)
	switch v.Code {
	case INFLATION_SUCCESS:
	x.Marshal(x.Sprintf("%spayouts", name), (*XdrVec_unbounded_InflationPayout)(v.Payouts()))
		return
	default:
		return
	}
}
func XDR_InflationResult(x XDR, name string, v *InflationResult) {
	x.Marshal(name, v)
}
func XDR_ManageDataResultCode(x XDR, name string, v *ManageDataResultCode) {
	x.Marshal(name, v)
}
var _XdrNames_ManageDataResultCode = map[int32]string{
	int32(MANAGE_DATA_SUCCESS): "MANAGE_DATA_SUCCESS",
	int32(MANAGE_DATA_NOT_SUPPORTED_YET): "MANAGE_DATA_NOT_SUPPORTED_YET",
	int32(MANAGE_DATA_NAME_NOT_FOUND): "MANAGE_DATA_NAME_NOT_FOUND",
	int32(MANAGE_DATA_LOW_RESERVE): "MANAGE_DATA_LOW_RESERVE",
	int32(MANAGE_DATA_INVALID_NAME): "MANAGE_DATA_INVALID_NAME",
}
var _XdrValues_ManageDataResultCode = map[string]int32{
	"MANAGE_DATA_SUCCESS": int32(MANAGE_DATA_SUCCESS),
	"MANAGE_DATA_NOT_SUPPORTED_YET": int32(MANAGE_DATA_NOT_SUPPORTED_YET),
	"MANAGE_DATA_NAME_NOT_FOUND": int32(MANAGE_DATA_NAME_NOT_FOUND),
	"MANAGE_DATA_LOW_RESERVE": int32(MANAGE_DATA_LOW_RESERVE),
	"MANAGE_DATA_INVALID_NAME": int32(MANAGE_DATA_INVALID_NAME),
}
func (*ManageDataResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_ManageDataResultCode
}
func (v *ManageDataResultCode) String() string {
	if s, ok := _XdrNames_ManageDataResultCode[int32(*v)]; ok {
		return s
	}
	return fmt.Sprintf("ManageDataResultCode#%d", *v)
}
func (v *ManageDataResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, xdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_ManageDataResultCode[stok]; ok {
			*v = ManageDataResultCode(val)
			return nil
		}
		return XdrError(fmt.Sprintf("%s is not a valid ManageDataResultCode.", stok))
	}
}
func (v *ManageDataResultCode) GetU32() uint32 {
	return uint32(*v)
}
func (v *ManageDataResultCode) SetU32(n uint32) {
	*v = ManageDataResultCode(n)
}
func (v *ManageDataResultCode) XdrPointer() interface{} {
	return v
}
func (v *ManageDataResultCode) XdrValue() interface{} {
	return *v
}
func (u *ManageDataResult) XdrValid() bool {
	return true
}
func (u *ManageDataResult) XdrUnionTag() interface{} {
	return &u.Code
}
func (u *ManageDataResult) XdrUnionTagName() string {
	return "Code"
}
func (u *ManageDataResult) XdrUnionBody() interface{} {
	switch u.Code {
	case MANAGE_DATA_SUCCESS:
		return nil
	default:
		return nil
	}
}
func (u *ManageDataResult) XdrUnionBodyName() string {
	switch u.Code {
	case MANAGE_DATA_SUCCESS:
		return ""
	default:
		return ""
	}
}
func (v *ManageDataResult) XdrPointer() interface{} {
	return v
}
func (v *ManageDataResult) XdrValue() interface{} {
	return *v
}
func (v *ManageDataResult) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_ManageDataResultCode(x, x.Sprintf("%scode", name), &v.Code)
	switch v.Code {
	case MANAGE_DATA_SUCCESS:
		return
	default:
		return
	}
}
func XDR_ManageDataResult(x XDR, name string, v *ManageDataResult) {
	x.Marshal(name, v)
}
func XDR_BumpSequenceResultCode(x XDR, name string, v *BumpSequenceResultCode) {
	x.Marshal(name, v)
}
var _XdrNames_BumpSequenceResultCode = map[int32]string{
	int32(BUMP_SEQUENCE_SUCCESS): "BUMP_SEQUENCE_SUCCESS",
	int32(BUMP_SEQUENCE_BAD_SEQ): "BUMP_SEQUENCE_BAD_SEQ",
}
var _XdrValues_BumpSequenceResultCode = map[string]int32{
	"BUMP_SEQUENCE_SUCCESS": int32(BUMP_SEQUENCE_SUCCESS),
	"BUMP_SEQUENCE_BAD_SEQ": int32(BUMP_SEQUENCE_BAD_SEQ),
}
func (*BumpSequenceResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_BumpSequenceResultCode
}
func (v *BumpSequenceResultCode) String() string {
	if s, ok := _XdrNames_BumpSequenceResultCode[int32(*v)]; ok {
		return s
	}
	return fmt.Sprintf("BumpSequenceResultCode#%d", *v)
}
func (v *BumpSequenceResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, xdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_BumpSequenceResultCode[stok]; ok {
			*v = BumpSequenceResultCode(val)
			return nil
		}
		return XdrError(fmt.Sprintf("%s is not a valid BumpSequenceResultCode.", stok))
	}
}
func (v *BumpSequenceResultCode) GetU32() uint32 {
	return uint32(*v)
}
func (v *BumpSequenceResultCode) SetU32(n uint32) {
	*v = BumpSequenceResultCode(n)
}
func (v *BumpSequenceResultCode) XdrPointer() interface{} {
	return v
}
func (v *BumpSequenceResultCode) XdrValue() interface{} {
	return *v
}
func (u *BumpSequenceResult) XdrValid() bool {
	return true
}
func (u *BumpSequenceResult) XdrUnionTag() interface{} {
	return &u.Code
}
func (u *BumpSequenceResult) XdrUnionTagName() string {
	return "Code"
}
func (u *BumpSequenceResult) XdrUnionBody() interface{} {
	switch u.Code {
	case BUMP_SEQUENCE_SUCCESS:
		return nil
	default:
		return nil
	}
}
func (u *BumpSequenceResult) XdrUnionBodyName() string {
	switch u.Code {
	case BUMP_SEQUENCE_SUCCESS:
		return ""
	default:
		return ""
	}
}
func (v *BumpSequenceResult) XdrPointer() interface{} {
	return v
}
func (v *BumpSequenceResult) XdrValue() interface{} {
	return *v
}
func (v *BumpSequenceResult) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_BumpSequenceResultCode(x, x.Sprintf("%scode", name), &v.Code)
	switch v.Code {
	case BUMP_SEQUENCE_SUCCESS:
		return
	default:
		return
	}
}
func XDR_BumpSequenceResult(x XDR, name string, v *BumpSequenceResult) {
	x.Marshal(name, v)
}
func XDR_OperationResultCode(x XDR, name string, v *OperationResultCode) {
	x.Marshal(name, v)
}
var _XdrNames_OperationResultCode = map[int32]string{
	int32(OpINNER): "opINNER",
	int32(OpBAD_AUTH): "opBAD_AUTH",
	int32(OpNO_ACCOUNT): "opNO_ACCOUNT",
	int32(OpNOT_SUPPORTED): "opNOT_SUPPORTED",
}
var _XdrValues_OperationResultCode = map[string]int32{
	"opINNER": int32(OpINNER),
	"opBAD_AUTH": int32(OpBAD_AUTH),
	"opNO_ACCOUNT": int32(OpNO_ACCOUNT),
	"opNOT_SUPPORTED": int32(OpNOT_SUPPORTED),
}
func (*OperationResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_OperationResultCode
}
func (v *OperationResultCode) String() string {
	if s, ok := _XdrNames_OperationResultCode[int32(*v)]; ok {
		return s
	}
	return fmt.Sprintf("OperationResultCode#%d", *v)
}
func (v *OperationResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, xdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_OperationResultCode[stok]; ok {
			*v = OperationResultCode(val)
			return nil
		}
		return XdrError(fmt.Sprintf("%s is not a valid OperationResultCode.", stok))
	}
}
func (v *OperationResultCode) GetU32() uint32 {
	return uint32(*v)
}
func (v *OperationResultCode) SetU32(n uint32) {
	*v = OperationResultCode(n)
}
func (v *OperationResultCode) XdrPointer() interface{} {
	return v
}
func (v *OperationResultCode) XdrValue() interface{} {
	return *v
}
func (u *_OperationResult_Tr) CreateAccountResult() *CreateAccountResult {
	switch u.Type {
	case CREATE_ACCOUNT:
		if v, ok := u._u.(*CreateAccountResult); ok {
			return v
		} else {
			var zero CreateAccountResult
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("_OperationResult_Tr.CreateAccountResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *_OperationResult_Tr) PaymentResult() *PaymentResult {
	switch u.Type {
	case PAYMENT:
		if v, ok := u._u.(*PaymentResult); ok {
			return v
		} else {
			var zero PaymentResult
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("_OperationResult_Tr.PaymentResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *_OperationResult_Tr) PathPaymentResult() *PathPaymentResult {
	switch u.Type {
	case PATH_PAYMENT:
		if v, ok := u._u.(*PathPaymentResult); ok {
			return v
		} else {
			var zero PathPaymentResult
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("_OperationResult_Tr.PathPaymentResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *_OperationResult_Tr) ManageOfferResult() *ManageOfferResult {
	switch u.Type {
	case MANAGE_OFFER:
		if v, ok := u._u.(*ManageOfferResult); ok {
			return v
		} else {
			var zero ManageOfferResult
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("_OperationResult_Tr.ManageOfferResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *_OperationResult_Tr) CreatePassiveOfferResult() *ManageOfferResult {
	switch u.Type {
	case CREATE_PASSIVE_OFFER:
		if v, ok := u._u.(*ManageOfferResult); ok {
			return v
		} else {
			var zero ManageOfferResult
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("_OperationResult_Tr.CreatePassiveOfferResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *_OperationResult_Tr) SetOptionsResult() *SetOptionsResult {
	switch u.Type {
	case SET_OPTIONS:
		if v, ok := u._u.(*SetOptionsResult); ok {
			return v
		} else {
			var zero SetOptionsResult
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("_OperationResult_Tr.SetOptionsResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *_OperationResult_Tr) ChangeTrustResult() *ChangeTrustResult {
	switch u.Type {
	case CHANGE_TRUST:
		if v, ok := u._u.(*ChangeTrustResult); ok {
			return v
		} else {
			var zero ChangeTrustResult
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("_OperationResult_Tr.ChangeTrustResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *_OperationResult_Tr) AllowTrustResult() *AllowTrustResult {
	switch u.Type {
	case ALLOW_TRUST:
		if v, ok := u._u.(*AllowTrustResult); ok {
			return v
		} else {
			var zero AllowTrustResult
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("_OperationResult_Tr.AllowTrustResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *_OperationResult_Tr) AccountMergeResult() *AccountMergeResult {
	switch u.Type {
	case ACCOUNT_MERGE:
		if v, ok := u._u.(*AccountMergeResult); ok {
			return v
		} else {
			var zero AccountMergeResult
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("_OperationResult_Tr.AccountMergeResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *_OperationResult_Tr) InflationResult() *InflationResult {
	switch u.Type {
	case INFLATION:
		if v, ok := u._u.(*InflationResult); ok {
			return v
		} else {
			var zero InflationResult
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("_OperationResult_Tr.InflationResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *_OperationResult_Tr) ManageDataResult() *ManageDataResult {
	switch u.Type {
	case MANAGE_DATA:
		if v, ok := u._u.(*ManageDataResult); ok {
			return v
		} else {
			var zero ManageDataResult
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("_OperationResult_Tr.ManageDataResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *_OperationResult_Tr) BumpSeqResult() *BumpSequenceResult {
	switch u.Type {
	case BUMP_SEQUENCE:
		if v, ok := u._u.(*BumpSequenceResult); ok {
			return v
		} else {
			var zero BumpSequenceResult
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("_OperationResult_Tr.BumpSeqResult accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *_OperationResult_Tr) XdrValid() bool {
	switch u.Type {
	case CREATE_ACCOUNT,PAYMENT,PATH_PAYMENT,MANAGE_OFFER,CREATE_PASSIVE_OFFER,SET_OPTIONS,CHANGE_TRUST,ALLOW_TRUST,ACCOUNT_MERGE,INFLATION,MANAGE_DATA,BUMP_SEQUENCE:
		return true
	}
	return false
}
func (u *_OperationResult_Tr) XdrUnionTag() interface{} {
	return &u.Type
}
func (u *_OperationResult_Tr) XdrUnionTagName() string {
	return "Type"
}
func (u *_OperationResult_Tr) XdrUnionBody() interface{} {
	switch u.Type {
	case CREATE_ACCOUNT:
		return u.CreateAccountResult()
	case PAYMENT:
		return u.PaymentResult()
	case PATH_PAYMENT:
		return u.PathPaymentResult()
	case MANAGE_OFFER:
		return u.ManageOfferResult()
	case CREATE_PASSIVE_OFFER:
		return u.CreatePassiveOfferResult()
	case SET_OPTIONS:
		return u.SetOptionsResult()
	case CHANGE_TRUST:
		return u.ChangeTrustResult()
	case ALLOW_TRUST:
		return u.AllowTrustResult()
	case ACCOUNT_MERGE:
		return u.AccountMergeResult()
	case INFLATION:
		return u.InflationResult()
	case MANAGE_DATA:
		return u.ManageDataResult()
	case BUMP_SEQUENCE:
		return u.BumpSeqResult()
	}
	return nil
}
func (u *_OperationResult_Tr) XdrUnionBodyName() string {
	switch u.Type {
	case CREATE_ACCOUNT:
		return "CreateAccountResult"
	case PAYMENT:
		return "PaymentResult"
	case PATH_PAYMENT:
		return "PathPaymentResult"
	case MANAGE_OFFER:
		return "ManageOfferResult"
	case CREATE_PASSIVE_OFFER:
		return "CreatePassiveOfferResult"
	case SET_OPTIONS:
		return "SetOptionsResult"
	case CHANGE_TRUST:
		return "ChangeTrustResult"
	case ALLOW_TRUST:
		return "AllowTrustResult"
	case ACCOUNT_MERGE:
		return "AccountMergeResult"
	case INFLATION:
		return "InflationResult"
	case MANAGE_DATA:
		return "ManageDataResult"
	case BUMP_SEQUENCE:
		return "BumpSeqResult"
	}
	return ""
}
func (v *_OperationResult_Tr) XdrPointer() interface{} {
	return v
}
func (v *_OperationResult_Tr) XdrValue() interface{} {
	return *v
}
func (v *_OperationResult_Tr) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_OperationType(x, x.Sprintf("%stype", name), &v.Type)
	switch v.Type {
	case CREATE_ACCOUNT:
	XDR_CreateAccountResult(x, x.Sprintf("%screateAccountResult", name), v.CreateAccountResult())
		return
	case PAYMENT:
	XDR_PaymentResult(x, x.Sprintf("%spaymentResult", name), v.PaymentResult())
		return
	case PATH_PAYMENT:
	XDR_PathPaymentResult(x, x.Sprintf("%spathPaymentResult", name), v.PathPaymentResult())
		return
	case MANAGE_OFFER:
	XDR_ManageOfferResult(x, x.Sprintf("%smanageOfferResult", name), v.ManageOfferResult())
		return
	case CREATE_PASSIVE_OFFER:
	XDR_ManageOfferResult(x, x.Sprintf("%screatePassiveOfferResult", name), v.CreatePassiveOfferResult())
		return
	case SET_OPTIONS:
	XDR_SetOptionsResult(x, x.Sprintf("%ssetOptionsResult", name), v.SetOptionsResult())
		return
	case CHANGE_TRUST:
	XDR_ChangeTrustResult(x, x.Sprintf("%schangeTrustResult", name), v.ChangeTrustResult())
		return
	case ALLOW_TRUST:
	XDR_AllowTrustResult(x, x.Sprintf("%sallowTrustResult", name), v.AllowTrustResult())
		return
	case ACCOUNT_MERGE:
	XDR_AccountMergeResult(x, x.Sprintf("%saccountMergeResult", name), v.AccountMergeResult())
		return
	case INFLATION:
	XDR_InflationResult(x, x.Sprintf("%sinflationResult", name), v.InflationResult())
		return
	case MANAGE_DATA:
	XDR_ManageDataResult(x, x.Sprintf("%smanageDataResult", name), v.ManageDataResult())
		return
	case BUMP_SEQUENCE:
	XDR_BumpSequenceResult(x, x.Sprintf("%sbumpSeqResult", name), v.BumpSeqResult())
		return
	}
	xdrPanic(fmt.Sprintf("invalid Type (%v) in _OperationResult_Tr", v.Type))
}
func XDR__OperationResult_Tr(x XDR, name string, v *_OperationResult_Tr) {
	x.Marshal(name, v)
}
func (u *OperationResult) Tr() *_OperationResult_Tr {
	switch u.Code {
	case OpINNER:
		if v, ok := u._u.(*_OperationResult_Tr); ok {
			return v
		} else {
			var zero _OperationResult_Tr
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("OperationResult.Tr accessed when Code == %v", u.Code)
		return nil
	}
}
func (u *OperationResult) XdrValid() bool {
	return true
}
func (u *OperationResult) XdrUnionTag() interface{} {
	return &u.Code
}
func (u *OperationResult) XdrUnionTagName() string {
	return "Code"
}
func (u *OperationResult) XdrUnionBody() interface{} {
	switch u.Code {
	case OpINNER:
		return u.Tr()
	default:
		return nil
	}
}
func (u *OperationResult) XdrUnionBodyName() string {
	switch u.Code {
	case OpINNER:
		return "Tr"
	default:
		return ""
	}
}
func (v *OperationResult) XdrPointer() interface{} {
	return v
}
func (v *OperationResult) XdrValue() interface{} {
	return *v
}
func (v *OperationResult) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_OperationResultCode(x, x.Sprintf("%scode", name), &v.Code)
	switch v.Code {
	case OpINNER:
	XDR__OperationResult_Tr(x, x.Sprintf("%str", name), v.Tr())
		return
	default:
		return
	}
}
func XDR_OperationResult(x XDR, name string, v *OperationResult) {
	x.Marshal(name, v)
}
func XDR_TransactionResultCode(x XDR, name string, v *TransactionResultCode) {
	x.Marshal(name, v)
}
var _XdrNames_TransactionResultCode = map[int32]string{
	int32(TxSUCCESS): "txSUCCESS",
	int32(TxFAILED): "txFAILED",
	int32(TxTOO_EARLY): "txTOO_EARLY",
	int32(TxTOO_LATE): "txTOO_LATE",
	int32(TxMISSING_OPERATION): "txMISSING_OPERATION",
	int32(TxBAD_SEQ): "txBAD_SEQ",
	int32(TxBAD_AUTH): "txBAD_AUTH",
	int32(TxINSUFFICIENT_BALANCE): "txINSUFFICIENT_BALANCE",
	int32(TxNO_ACCOUNT): "txNO_ACCOUNT",
	int32(TxINSUFFICIENT_FEE): "txINSUFFICIENT_FEE",
	int32(TxBAD_AUTH_EXTRA): "txBAD_AUTH_EXTRA",
	int32(TxINTERNAL_ERROR): "txINTERNAL_ERROR",
}
var _XdrValues_TransactionResultCode = map[string]int32{
	"txSUCCESS": int32(TxSUCCESS),
	"txFAILED": int32(TxFAILED),
	"txTOO_EARLY": int32(TxTOO_EARLY),
	"txTOO_LATE": int32(TxTOO_LATE),
	"txMISSING_OPERATION": int32(TxMISSING_OPERATION),
	"txBAD_SEQ": int32(TxBAD_SEQ),
	"txBAD_AUTH": int32(TxBAD_AUTH),
	"txINSUFFICIENT_BALANCE": int32(TxINSUFFICIENT_BALANCE),
	"txNO_ACCOUNT": int32(TxNO_ACCOUNT),
	"txINSUFFICIENT_FEE": int32(TxINSUFFICIENT_FEE),
	"txBAD_AUTH_EXTRA": int32(TxBAD_AUTH_EXTRA),
	"txINTERNAL_ERROR": int32(TxINTERNAL_ERROR),
}
func (*TransactionResultCode) XdrEnumNames() map[int32]string {
	return _XdrNames_TransactionResultCode
}
func (v *TransactionResultCode) String() string {
	if s, ok := _XdrNames_TransactionResultCode[int32(*v)]; ok {
		return s
	}
	return fmt.Sprintf("TransactionResultCode#%d", *v)
}
func (v *TransactionResultCode) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, xdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_TransactionResultCode[stok]; ok {
			*v = TransactionResultCode(val)
			return nil
		}
		return XdrError(fmt.Sprintf("%s is not a valid TransactionResultCode.", stok))
	}
}
func (v *TransactionResultCode) GetU32() uint32 {
	return uint32(*v)
}
func (v *TransactionResultCode) SetU32(n uint32) {
	*v = TransactionResultCode(n)
}
func (v *TransactionResultCode) XdrPointer() interface{} {
	return v
}
func (v *TransactionResultCode) XdrValue() interface{} {
	return *v
}
type XdrVec_unbounded_OperationResult []OperationResult
func (v *XdrVec_unbounded_OperationResult) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (*XdrVec_unbounded_OperationResult) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		xdrPanic("XdrVec_unbounded_OperationResult length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		xdrPanic("XdrVec_unbounded_OperationResult length %d exceeds max int", length)
	}
}
func (v *XdrVec_unbounded_OperationResult) GetVecLen() uint32 { return uint32(len(*v)) }
func (v *XdrVec_unbounded_OperationResult) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2*cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]OperationResult, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *XdrVec_unbounded_OperationResult) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if (i >= len(*v)) {
			v.SetVecLen(uint32(i+1))
		}
		XDR_OperationResult(x, x.Sprintf("%s[%d]", name, i), &(*v)[i])
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *XdrVec_unbounded_OperationResult) XdrMarshal(x XDR, name string) {
	size := XdrSize{ size: uint32(len(*v)), bound: 4294967295 }
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.size)
}
func (v *XdrVec_unbounded_OperationResult) XdrPointer() interface{} { return (*[]OperationResult)(v) }
func (v *XdrVec_unbounded_OperationResult) XdrValue() interface{} { return ([]OperationResult)(*v) }
func (u *_TransactionResult_Result) Results() *[]OperationResult {
	switch u.Code {
	case TxSUCCESS, TxFAILED:
		if v, ok := u._u.(*[]OperationResult); ok {
			return v
		} else {
			var zero []OperationResult
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("_TransactionResult_Result.Results accessed when Code == %v", u.Code)
		return nil
	}
}
func (u *_TransactionResult_Result) XdrValid() bool {
	return true
}
func (u *_TransactionResult_Result) XdrUnionTag() interface{} {
	return &u.Code
}
func (u *_TransactionResult_Result) XdrUnionTagName() string {
	return "Code"
}
func (u *_TransactionResult_Result) XdrUnionBody() interface{} {
	switch u.Code {
	case TxSUCCESS, TxFAILED:
		return u.Results()
	default:
		return nil
	}
}
func (u *_TransactionResult_Result) XdrUnionBodyName() string {
	switch u.Code {
	case TxSUCCESS, TxFAILED:
		return "Results"
	default:
		return ""
	}
}
func (v *_TransactionResult_Result) XdrPointer() interface{} {
	return v
}
func (v *_TransactionResult_Result) XdrValue() interface{} {
	return *v
}
func (v *_TransactionResult_Result) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_TransactionResultCode(x, x.Sprintf("%scode", name), &v.Code)
	switch v.Code {
	case TxSUCCESS, TxFAILED:
	x.Marshal(x.Sprintf("%sresults", name), (*XdrVec_unbounded_OperationResult)(v.Results()))
		return
	default:
		return
	}
}
func XDR__TransactionResult_Result(x XDR, name string, v *_TransactionResult_Result) {
	x.Marshal(name, v)
}
func (u *_TransactionResult_Ext) XdrValid() bool {
	switch u.V {
	case 0:
		return true
	}
	return false
}
func (u *_TransactionResult_Ext) XdrUnionTag() interface{} {
	return &u.V
}
func (u *_TransactionResult_Ext) XdrUnionTagName() string {
	return "V"
}
func (u *_TransactionResult_Ext) XdrUnionBody() interface{} {
	switch u.V {
	case 0:
		return nil
	}
	return nil
}
func (u *_TransactionResult_Ext) XdrUnionBodyName() string {
	switch u.V {
	case 0:
		return ""
	}
	return ""
}
func (v *_TransactionResult_Ext) XdrPointer() interface{} {
	return v
}
func (v *_TransactionResult_Ext) XdrValue() interface{} {
	return *v
}
func (v *_TransactionResult_Ext) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_int32(x, x.Sprintf("%sv", name), &v.V)
	switch v.V {
	case 0:
		return
	}
	xdrPanic(fmt.Sprintf("invalid V (%v) in _TransactionResult_Ext", v.V))
}
func XDR__TransactionResult_Ext(x XDR, name string, v *_TransactionResult_Ext) {
	x.Marshal(name, v)
}
func (v *TransactionResult) XdrPointer() interface{} {
	return v
}
func (v *TransactionResult) XdrValue() interface{} {
	return *v
}
func (v *TransactionResult) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Int64(x, x.Sprintf("%sfeeCharged", name), &v.FeeCharged)
	XDR__TransactionResult_Result(x, x.Sprintf("%sresult", name), &v.Result)
	XDR__TransactionResult_Ext(x, x.Sprintf("%sext", name), &v.Ext)
}
func XDR_TransactionResult(x XDR, name string, v *TransactionResult) {
	x.Marshal(name, v)
}
func XDR_Hash(x XDR, name string, v *Hash) {
	if xs, ok := x.(interface{
		Marshal_Hash(string, *Hash)
	}); ok {
		xs.Marshal_Hash(name, v)
	} else {
		x.Marshal(name, XdrArrayOpaque((*v)[:]))
	}
}
func XDR_Uint256(x XDR, name string, v *Uint256) {
	if xs, ok := x.(interface{
		Marshal_Uint256(string, *Uint256)
	}); ok {
		xs.Marshal_Uint256(name, v)
	} else {
		x.Marshal(name, XdrArrayOpaque((*v)[:]))
	}
}
func XDR_Uint32(x XDR, name string, v *Uint32) {
	if xs, ok := x.(interface{
		Marshal_Uint32(string, *Uint32)
	}); ok {
		xs.Marshal_Uint32(name, v)
	} else {
		XDR_uint32(x, name, v)
	}
}
func XDR_Int32(x XDR, name string, v *Int32) {
	if xs, ok := x.(interface{
		Marshal_Int32(string, *Int32)
	}); ok {
		xs.Marshal_Int32(name, v)
	} else {
		XDR_int32(x, name, v)
	}
}
func XDR_Uint64(x XDR, name string, v *Uint64) {
	if xs, ok := x.(interface{
		Marshal_Uint64(string, *Uint64)
	}); ok {
		xs.Marshal_Uint64(name, v)
	} else {
		XDR_uint64(x, name, v)
	}
}
func XDR_Int64(x XDR, name string, v *Int64) {
	if xs, ok := x.(interface{
		Marshal_Int64(string, *Int64)
	}); ok {
		xs.Marshal_Int64(name, v)
	} else {
		XDR_int64(x, name, v)
	}
}
func XDR_CryptoKeyType(x XDR, name string, v *CryptoKeyType) {
	x.Marshal(name, v)
}
var _XdrNames_CryptoKeyType = map[int32]string{
	int32(KEY_TYPE_ED25519): "KEY_TYPE_ED25519",
	int32(KEY_TYPE_PRE_AUTH_TX): "KEY_TYPE_PRE_AUTH_TX",
	int32(KEY_TYPE_HASH_X): "KEY_TYPE_HASH_X",
}
var _XdrValues_CryptoKeyType = map[string]int32{
	"KEY_TYPE_ED25519": int32(KEY_TYPE_ED25519),
	"KEY_TYPE_PRE_AUTH_TX": int32(KEY_TYPE_PRE_AUTH_TX),
	"KEY_TYPE_HASH_X": int32(KEY_TYPE_HASH_X),
}
func (*CryptoKeyType) XdrEnumNames() map[int32]string {
	return _XdrNames_CryptoKeyType
}
func (v *CryptoKeyType) String() string {
	if s, ok := _XdrNames_CryptoKeyType[int32(*v)]; ok {
		return s
	}
	return fmt.Sprintf("CryptoKeyType#%d", *v)
}
func (v *CryptoKeyType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, xdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_CryptoKeyType[stok]; ok {
			*v = CryptoKeyType(val)
			return nil
		}
		return XdrError(fmt.Sprintf("%s is not a valid CryptoKeyType.", stok))
	}
}
func (v *CryptoKeyType) GetU32() uint32 {
	return uint32(*v)
}
func (v *CryptoKeyType) SetU32(n uint32) {
	*v = CryptoKeyType(n)
}
func (v *CryptoKeyType) XdrPointer() interface{} {
	return v
}
func (v *CryptoKeyType) XdrValue() interface{} {
	return *v
}
func XDR_PublicKeyType(x XDR, name string, v *PublicKeyType) {
	x.Marshal(name, v)
}
var _XdrNames_PublicKeyType = map[int32]string{
	int32(PUBLIC_KEY_TYPE_ED25519): "PUBLIC_KEY_TYPE_ED25519",
}
var _XdrValues_PublicKeyType = map[string]int32{
	"PUBLIC_KEY_TYPE_ED25519": int32(PUBLIC_KEY_TYPE_ED25519),
}
func (*PublicKeyType) XdrEnumNames() map[int32]string {
	return _XdrNames_PublicKeyType
}
func (v *PublicKeyType) String() string {
	if s, ok := _XdrNames_PublicKeyType[int32(*v)]; ok {
		return s
	}
	return fmt.Sprintf("PublicKeyType#%d", *v)
}
func (v *PublicKeyType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, xdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_PublicKeyType[stok]; ok {
			*v = PublicKeyType(val)
			return nil
		}
		return XdrError(fmt.Sprintf("%s is not a valid PublicKeyType.", stok))
	}
}
func (v *PublicKeyType) GetU32() uint32 {
	return uint32(*v)
}
func (v *PublicKeyType) SetU32(n uint32) {
	*v = PublicKeyType(n)
}
func (v *PublicKeyType) XdrPointer() interface{} {
	return v
}
func (v *PublicKeyType) XdrValue() interface{} {
	return *v
}
func XDR_SignerKeyType(x XDR, name string, v *SignerKeyType) {
	x.Marshal(name, v)
}
var _XdrNames_SignerKeyType = map[int32]string{
	int32(SIGNER_KEY_TYPE_ED25519): "SIGNER_KEY_TYPE_ED25519",
	int32(SIGNER_KEY_TYPE_PRE_AUTH_TX): "SIGNER_KEY_TYPE_PRE_AUTH_TX",
	int32(SIGNER_KEY_TYPE_HASH_X): "SIGNER_KEY_TYPE_HASH_X",
}
var _XdrValues_SignerKeyType = map[string]int32{
	"SIGNER_KEY_TYPE_ED25519": int32(SIGNER_KEY_TYPE_ED25519),
	"SIGNER_KEY_TYPE_PRE_AUTH_TX": int32(SIGNER_KEY_TYPE_PRE_AUTH_TX),
	"SIGNER_KEY_TYPE_HASH_X": int32(SIGNER_KEY_TYPE_HASH_X),
}
func (*SignerKeyType) XdrEnumNames() map[int32]string {
	return _XdrNames_SignerKeyType
}
func (v *SignerKeyType) String() string {
	if s, ok := _XdrNames_SignerKeyType[int32(*v)]; ok {
		return s
	}
	return fmt.Sprintf("SignerKeyType#%d", *v)
}
func (v *SignerKeyType) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, xdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_SignerKeyType[stok]; ok {
			*v = SignerKeyType(val)
			return nil
		}
		return XdrError(fmt.Sprintf("%s is not a valid SignerKeyType.", stok))
	}
}
func (v *SignerKeyType) GetU32() uint32 {
	return uint32(*v)
}
func (v *SignerKeyType) SetU32(n uint32) {
	*v = SignerKeyType(n)
}
func (v *SignerKeyType) XdrPointer() interface{} {
	return v
}
func (v *SignerKeyType) XdrValue() interface{} {
	return *v
}
func (u *PublicKey) Ed25519() *Uint256 {
	switch u.Type {
	case PUBLIC_KEY_TYPE_ED25519:
		if v, ok := u._u.(*Uint256); ok {
			return v
		} else {
			var zero Uint256
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("PublicKey.Ed25519 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *PublicKey) XdrValid() bool {
	switch u.Type {
	case PUBLIC_KEY_TYPE_ED25519:
		return true
	}
	return false
}
func (u *PublicKey) XdrUnionTag() interface{} {
	return &u.Type
}
func (u *PublicKey) XdrUnionTagName() string {
	return "Type"
}
func (u *PublicKey) XdrUnionBody() interface{} {
	switch u.Type {
	case PUBLIC_KEY_TYPE_ED25519:
		return u.Ed25519()
	}
	return nil
}
func (u *PublicKey) XdrUnionBodyName() string {
	switch u.Type {
	case PUBLIC_KEY_TYPE_ED25519:
		return "Ed25519"
	}
	return ""
}
func (v *PublicKey) XdrPointer() interface{} {
	return v
}
func (v *PublicKey) XdrValue() interface{} {
	return *v
}
func (v *PublicKey) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_PublicKeyType(x, x.Sprintf("%stype", name), &v.Type)
	switch v.Type {
	case PUBLIC_KEY_TYPE_ED25519:
	XDR_Uint256(x, x.Sprintf("%sed25519", name), v.Ed25519())
		return
	}
	xdrPanic(fmt.Sprintf("invalid Type (%v) in PublicKey", v.Type))
}
func XDR_PublicKey(x XDR, name string, v *PublicKey) {
	x.Marshal(name, v)
}
func (u *SignerKey) Ed25519() *Uint256 {
	switch u.Type {
	case SIGNER_KEY_TYPE_ED25519:
		if v, ok := u._u.(*Uint256); ok {
			return v
		} else {
			var zero Uint256
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("SignerKey.Ed25519 accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SignerKey) PreAuthTx() *Uint256 {
	switch u.Type {
	case SIGNER_KEY_TYPE_PRE_AUTH_TX:
		if v, ok := u._u.(*Uint256); ok {
			return v
		} else {
			var zero Uint256
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("SignerKey.PreAuthTx accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SignerKey) HashX() *Uint256 {
	switch u.Type {
	case SIGNER_KEY_TYPE_HASH_X:
		if v, ok := u._u.(*Uint256); ok {
			return v
		} else {
			var zero Uint256
			u._u = &zero
			return &zero
		}
	default:
		xdrPanic("SignerKey.HashX accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *SignerKey) XdrValid() bool {
	switch u.Type {
	case SIGNER_KEY_TYPE_ED25519,SIGNER_KEY_TYPE_PRE_AUTH_TX,SIGNER_KEY_TYPE_HASH_X:
		return true
	}
	return false
}
func (u *SignerKey) XdrUnionTag() interface{} {
	return &u.Type
}
func (u *SignerKey) XdrUnionTagName() string {
	return "Type"
}
func (u *SignerKey) XdrUnionBody() interface{} {
	switch u.Type {
	case SIGNER_KEY_TYPE_ED25519:
		return u.Ed25519()
	case SIGNER_KEY_TYPE_PRE_AUTH_TX:
		return u.PreAuthTx()
	case SIGNER_KEY_TYPE_HASH_X:
		return u.HashX()
	}
	return nil
}
func (u *SignerKey) XdrUnionBodyName() string {
	switch u.Type {
	case SIGNER_KEY_TYPE_ED25519:
		return "Ed25519"
	case SIGNER_KEY_TYPE_PRE_AUTH_TX:
		return "PreAuthTx"
	case SIGNER_KEY_TYPE_HASH_X:
		return "HashX"
	}
	return ""
}
func (v *SignerKey) XdrPointer() interface{} {
	return v
}
func (v *SignerKey) XdrValue() interface{} {
	return *v
}
func (v *SignerKey) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_SignerKeyType(x, x.Sprintf("%stype", name), &v.Type)
	switch v.Type {
	case SIGNER_KEY_TYPE_ED25519:
	XDR_Uint256(x, x.Sprintf("%sed25519", name), v.Ed25519())
		return
	case SIGNER_KEY_TYPE_PRE_AUTH_TX:
	XDR_Uint256(x, x.Sprintf("%spreAuthTx", name), v.PreAuthTx())
		return
	case SIGNER_KEY_TYPE_HASH_X:
	XDR_Uint256(x, x.Sprintf("%shashX", name), v.HashX())
		return
	}
	xdrPanic(fmt.Sprintf("invalid Type (%v) in SignerKey", v.Type))
}
func XDR_SignerKey(x XDR, name string, v *SignerKey) {
	x.Marshal(name, v)
}
func XDR_Signature(x XDR, name string, v *Signature) {
	if xs, ok := x.(interface{
		Marshal_Signature(string, *Signature)
	}); ok {
		xs.Marshal_Signature(name, v)
	} else {
		x.Marshal(name, XdrVecOpaque{v, 64})
	}
}
func XDR_SignatureHint(x XDR, name string, v *SignatureHint) {
	if xs, ok := x.(interface{
		Marshal_SignatureHint(string, *SignatureHint)
	}); ok {
		xs.Marshal_SignatureHint(name, v)
	} else {
		x.Marshal(name, XdrArrayOpaque((*v)[:]))
	}
}
func XDR_NodeID(x XDR, name string, v *NodeID) {
	if xs, ok := x.(interface{
		Marshal_NodeID(string, *NodeID)
	}); ok {
		xs.Marshal_NodeID(name, v)
	} else {
		XDR_PublicKey(x, name, v)
	}
}
func (v *Curve25519Secret) XdrPointer() interface{} {
	return v
}
func (v *Curve25519Secret) XdrValue() interface{} {
	return *v
}
func (v *Curve25519Secret) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%skey", name), XdrArrayOpaque((v.Key)[:]))
}
func XDR_Curve25519Secret(x XDR, name string, v *Curve25519Secret) {
	x.Marshal(name, v)
}
func (v *Curve25519Public) XdrPointer() interface{} {
	return v
}
func (v *Curve25519Public) XdrValue() interface{} {
	return *v
}
func (v *Curve25519Public) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%skey", name), XdrArrayOpaque((v.Key)[:]))
}
func XDR_Curve25519Public(x XDR, name string, v *Curve25519Public) {
	x.Marshal(name, v)
}
func (v *HmacSha256Key) XdrPointer() interface{} {
	return v
}
func (v *HmacSha256Key) XdrValue() interface{} {
	return *v
}
func (v *HmacSha256Key) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%skey", name), XdrArrayOpaque((v.Key)[:]))
}
func XDR_HmacSha256Key(x XDR, name string, v *HmacSha256Key) {
	x.Marshal(name, v)
}
func (v *HmacSha256Mac) XdrPointer() interface{} {
	return v
}
func (v *HmacSha256Mac) XdrValue() interface{} {
	return *v
}
func (v *HmacSha256Mac) XdrMarshal(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%smac", name), XdrArrayOpaque((v.Mac)[:]))
}
func XDR_HmacSha256Mac(x XDR, name string, v *HmacSha256Mac) {
	x.Marshal(name, v)
}
